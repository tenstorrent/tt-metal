<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vector addition using SFPI &mdash; TT-Metalium  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tt_theme.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
    <link rel="canonical" href="/tt-metal/latest/tt-metalium/tt_metal/examples/custom_sfpi_add.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../_static/posthog.js?v=aa5946f9"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Smoothstep using SFPI" href="custom_sfpi_smoothstep.html" />
    <link rel="prev" title="Writing Custom SFPU Operations using SFPI" href="custom_sfpi.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >



<a href="https://docs.tenstorrent.com/">
    <img src="../../_static/tt_logo.svg" class="logo" alt="Logo"/>
</a>

<a href="../../index.html">
    TT-Metalium
</a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installing.html">Install</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TT-Metalium</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../programming_model/index.html">Programming Model</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programming Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="dram_loopback.html">DRAM Loopback</a></li>
<li class="toctree-l2"><a class="reference internal" href="eltwise_binary.html">Eltwise binary</a></li>
<li class="toctree-l2"><a class="reference internal" href="eltwise_sfpu.html">Eltwise SFPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="matmul_single_core.html">Matmul (Single Core)</a></li>
<li class="toctree-l2"><a class="reference internal" href="matmul_multi_core.html">Matmul (Multi Core)</a></li>
<li class="toctree-l2"><a class="reference internal" href="matmul_multi_core_optimized.html">Matmul (Multi Core Optimized)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="custom_sfpi.html">Writing Custom SFPU Operations using SFPI</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Vector addition using SFPI</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#program-setup">Program setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-kernels">The Kernels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#custom-sfpi-implementation">Custom SFPI Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-arguments-and-execution">Runtime Arguments and Execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="custom_sfpi_smoothstep.html">Smoothstep using SFPI</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apis/index.html">APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../environment_variables/index.html">Environment Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../resources/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources/contributing.html">Contributing as a developer</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TT-Metalium</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Programming Examples</a></li>
          <li class="breadcrumb-item"><a href="custom_sfpi.html">Writing Custom SFPU Operations using SFPI</a></li>
      <li class="breadcrumb-item active">Vector addition using SFPI</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/tt_metal/examples/custom_sfpi_add.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="vector-addition-using-sfpi">
<span id="custom-sfpi-add"></span><h1>Vector addition using SFPI<a class="headerlink" href="#vector-addition-using-sfpi" title="Permalink to this heading"></a>
</h1>
<p>This example demonstrates how to program the vector engine to perform the simplest operation - vector addition. This example serves as a starting point for users looking to implement custom operations using SFPI. We’ll go through this code section by section. The full source code for this example is available under the <code class="docutils literal notranslate"><span class="pre">tt_metal/programming_examples/custom_sfpi_add</span></code> directory.</p>
<p>Building the example can be done by adding a <code class="docutils literal notranslate"><span class="pre">--build-programming-examples</span></code> flag to the build script or adding the <code class="docutils literal notranslate"><span class="pre">-DBUILD_PROGRAMMING_EXAMPLES=ON</span></code> flag to the cmake command and results in the <code class="docutils literal notranslate"><span class="pre">metal_example_custom_sfpi_add</span></code> executable in the <code class="docutils literal notranslate"><span class="pre">build/programming_examples</span></code> directory. For example:</p>
<div class="highlight-bash notranslate">
<div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">TT_METAL_HOME</span><span class="o">=</span>&lt;/path/to/tt-metal&gt;
./build_metal.sh<span class="w"> </span>--build-programming-examples
<span class="c1"># To run the example</span>
./build/programming_examples/metal_example_custom_sfpi_add
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Tenstorrent does not guarantee backward compatibility for user-implemented SFPI functions. Keep your implementations up to date with the latest Metalium releases. APIs that call low-level SFPI functions may change without notice, and SFPI specifications may also change in future hardware versions.</p>
</div>
<section id="program-setup">
<h2>Program setup<a class="headerlink" href="#program-setup" title="Permalink to this heading"></a>
</h2>
<p>This example assumes familiarity with basic Metalium concepts like device initialization, buffer creation, circular buffers, and kernel setup. If you’re new to these concepts, we recommend starting with the <a class="reference internal" href="eltwise_sfpu.html#eltwise-sfpu-example"><span class="std std-ref">Eltwise sfpu example</span></a> for a gentler introduction to programming Metalium kernels.</p>
<p>The host-side setup for this custom SFPI example follows the standard pattern: device initialization, DRAM buffer creation for two inputs and one output, circular buffer allocation for kernel communication, and kernel creation. The key difference from simpler examples is that we need two input circular buffers (<code class="docutils literal notranslate"><span class="pre">cb_in0</span></code>, <code class="docutils literal notranslate"><span class="pre">cb_in1</span></code>) to handle the binary operation, plus the standard output buffer (<code class="docutils literal notranslate"><span class="pre">cb_out0</span></code>).</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// Standard device and program setup</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">device_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">mesh_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distributed</span><span class="o">::</span><span class="n">MeshDevice</span><span class="o">::</span><span class="n">create_unit_mesh</span><span class="p">(</span><span class="n">device_id</span><span class="p">);</span>

<span class="c1">// Submit work via the mesh command queue: uploads/downloads and program execution</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">MeshCommandQueue</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh_device</span><span class="o">-&gt;</span><span class="n">mesh_command_queue</span><span class="p">();</span>
<span class="c1">// Allocate mesh buffers: two inputs + one output (replicated across mesh)</span>
<span class="k">auto</span><span class="w"> </span><span class="n">src0_dram_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distributed</span><span class="o">::</span><span class="n">MeshBuffer</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">dram_buffer_config</span><span class="p">,</span><span class="w"> </span><span class="n">dram_config</span><span class="p">,</span><span class="w"> </span><span class="n">mesh_device</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="k">auto</span><span class="w"> </span><span class="n">src1_dram_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distributed</span><span class="o">::</span><span class="n">MeshBuffer</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">dram_buffer_config</span><span class="p">,</span><span class="w"> </span><span class="n">dram_config</span><span class="p">,</span><span class="w"> </span><span class="n">mesh_device</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="k">auto</span><span class="w"> </span><span class="n">dst_dram_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distributed</span><span class="o">::</span><span class="n">MeshBuffer</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">dram_buffer_config</span><span class="p">,</span><span class="w"> </span><span class="n">dram_config</span><span class="p">,</span><span class="w"> </span><span class="n">mesh_device</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>

<span class="n">Program</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateProgram</span><span class="p">();</span>

<span class="c1">// Create mesh workload for program execution across the mesh</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">MeshWorkload</span><span class="w"> </span><span class="n">workload</span><span class="p">;</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">MeshCoordinateRange</span><span class="w"> </span><span class="n">device_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distributed</span><span class="o">::</span><span class="n">MeshCoordinateRange</span><span class="p">(</span><span class="n">mesh_device</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">());</span>

<span class="c1">// Circular buffers for kernel communication</span>
<span class="n">CreateCircularBuffer</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="cm">/* cb_in0 config */</span><span class="p">);</span>
<span class="n">CreateCircularBuffer</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="cm">/* cb_in1 config */</span><span class="p">);</span>
<span class="n">CreateCircularBuffer</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="cm">/* cb_out0 config */</span><span class="p">);</span>

<span class="c1">// Kernels: reader, writer, and custom SFPU compute</span>
<span class="k">auto</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateKernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">"..../read_tiles.cpp"</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="n">DataMovementConfig</span><span class="p">{...});</span>
<span class="k">auto</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateKernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">"..../write_tile.cpp"</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="n">DataMovementConfig</span><span class="p">{...});</span>
<span class="k">auto</span><span class="w"> </span><span class="n">compute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateKernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">"..../tiles_add.cpp"</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="n">ComputeConfig</span><span class="p">{});</span>
</pre></div>
</div>
</section>
<section id="the-kernels">
<h2>The Kernels<a class="headerlink" href="#the-kernels" title="Permalink to this heading"></a>
</h2>
<section id="data-movement-kernels">
<h3>Data Movement Kernels<a class="headerlink" href="#data-movement-kernels" title="Permalink to this heading"></a>
</h3>
<p>The reader kernel reads tiles from two source DRAM buffers and pushes them into two separate input circular buffers.</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// tt_metal/programming_examples/custom_sfpi_add/kernels/dataflow/read_tiles.cpp</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">kernel_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_tiles</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cb_reserve_back</span><span class="p">(</span><span class="n">cb_in0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">cb_reserve_back</span><span class="p">(</span><span class="n">cb_in1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cb_in0_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_write_ptr</span><span class="p">(</span><span class="n">cb_in0</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cb_in1_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_write_ptr</span><span class="p">(</span><span class="n">cb_in1</span><span class="p">);</span>
<span class="w">        </span><span class="n">noc_async_read_tile</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">in0</span><span class="p">,</span><span class="w"> </span><span class="n">cb_in0_addr</span><span class="p">);</span>
<span class="w">        </span><span class="n">noc_async_read_tile</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">in1</span><span class="p">,</span><span class="w"> </span><span class="n">cb_in1_addr</span><span class="p">);</span>

<span class="w">        </span><span class="n">noc_async_read_barrier</span><span class="p">();</span>
<span class="w">        </span><span class="n">cb_push_back</span><span class="p">(</span><span class="n">cb_in0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">cb_push_back</span><span class="p">(</span><span class="n">cb_in1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The writer kernel is straightforward: it reads result tiles from the output circular buffer and writes them to the destination DRAM buffer.</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// tt_metal/programming_examples/custom_sfpi_add/kernels/dataflow/write_tile.cpp</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">kernel_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_tiles</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cb_wait_front</span><span class="p">(</span><span class="n">cb_out0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cb_out0_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_read_ptr</span><span class="p">(</span><span class="n">cb_out0</span><span class="p">);</span>
<span class="w">        </span><span class="n">noc_async_write_tile</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">out0</span><span class="p">,</span><span class="w"> </span><span class="n">cb_out0_addr</span><span class="p">);</span>
<span class="w">        </span><span class="n">noc_async_write_barrier</span><span class="p">();</span>
<span class="w">        </span><span class="n">cb_pop_front</span><span class="p">(</span><span class="n">cb_out0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="sfpi-compute-kernel">
<h3>SFPI Compute Kernel<a class="headerlink" href="#sfpi-compute-kernel" title="Permalink to this heading"></a>
</h3>
<p>The compute kernel is where the custom SFPI logic resides. It waits for tiles from the input CBs, performs the addition using the SFPI, and pushes the result to the output CB.</p>
<p>The overall flow follows the same pattern as other compute kernels:</p>
<ol class="arabic simple">
<li><p>Wait for input tiles to be available in <code class="docutils literal notranslate"><span class="pre">cb_in0</span></code> and <code class="docutils literal notranslate"><span class="pre">cb_in1</span></code>.</p></li>
<li><p>Acquire destination registers. These registers will be used as a scratchpad for the computation.</p></li>
<li><p>Copy tiles from CBs to the destination registers.</p></li>
<li><p>Execute the custom SFPI addition function on the data in the destination registers.</p></li>
<li><p>Transfer the ownership of the destination registers to the packer</p></li>
<li><p>Reserve space in the output CB, pack the result tile, and push it.</p></li>
<li><p>Pop the input tiles from the input CBs.</p></li>
<li><p>Release the destination registers.</p></li>
</ol>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// tt_metal/programming_examples/custom_sfpi_add/kernels/compute/tiles_add.cpp</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">NAMESPACE</span><span class="w"> </span><span class="p">{</span>
<span class="kt">void</span><span class="w"> </span><span class="n">MAIN</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n_tiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_arg_val</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">cb_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tt</span><span class="o">::</span><span class="n">CBIndex</span><span class="o">::</span><span class="n">c_0</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">cb_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tt</span><span class="o">::</span><span class="n">CBIndex</span><span class="o">::</span><span class="n">c_1</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">cb_out0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tt</span><span class="o">::</span><span class="n">CBIndex</span><span class="o">::</span><span class="n">c_16</span><span class="p">;</span>

<span class="w">    </span><span class="n">init_sfpu</span><span class="p">(</span><span class="n">cb_in0</span><span class="p">,</span><span class="w"> </span><span class="n">cb_out0</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_tiles</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cb_wait_front</span><span class="p">(</span><span class="n">cb_in0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">cb_wait_front</span><span class="p">(</span><span class="n">cb_in1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="n">tile_regs_acquire</span><span class="p">();</span>
<span class="w">        </span><span class="n">copy_tile</span><span class="p">(</span><span class="n">cb_in0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="n">copy_tile</span><span class="p">(</span><span class="n">cb_in1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="n">my_add_tiles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;-- Call to custom SFPI addition function</span>

<span class="w">        </span><span class="n">tile_regs_commit</span><span class="p">();</span>

<span class="w">        </span><span class="n">cb_reserve_back</span><span class="p">(</span><span class="n">cb_out0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">pack_tile</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cb_out0</span><span class="p">);</span>
<span class="w">        </span><span class="n">cb_push_back</span><span class="p">(</span><span class="n">cb_out0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="n">cb_pop_front</span><span class="p">(</span><span class="n">cb_in0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">cb_pop_front</span><span class="p">(</span><span class="n">cb_in1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">tile_regs_release</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace NAMESPACE</span>
</pre></div>
</div>
</section>
</section>
<section id="custom-sfpi-implementation">
<h2>Custom SFPI Implementation<a class="headerlink" href="#custom-sfpi-implementation" title="Permalink to this heading"></a>
</h2>
<p>The core of this example is the custom SFPI function <code class="docutils literal notranslate"><span class="pre">my_add_tiles</span></code>. It’s implemented in a layered way, which is a common pattern for SFPI programming to enable easy consumption and maintainability.</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// tt_metal/programming_examples/custom_sfpi_add/kernels/compute/tiles_add.cpp</span>
<span class="cp">#ifdef TRISC_MATH</span>

<span class="c1">// Low-level function operating on a tile face</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">my_add_tile_face</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst_index_in0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst_index_in1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst_index_out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n_vector_in_tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Calculate base indices for each tile in the Dst register array.</span>
<span class="w">    </span><span class="c1">// Each tile occupies 32 consecutive Dst registers (n_vector_in_tile) in WH and BH</span>
<span class="w">    </span><span class="c1">// For example: tile 0 uses dst_reg[0-31], tile 1 uses dst_reg[32-63], etc.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">in0_base_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dst_index_in0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_vector_in_tile</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">in1_base_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dst_index_in1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_vector_in_tile</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">out_base_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dst_index_out</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_vector_in_tile</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Process one face of the tile (8 SIMD operations covering 256 elements).</span>
<span class="w">    </span><span class="c1">// Each iteration processes 32 elements, so 8 iterations = 256 elements = one 16x16 face.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vFloat</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dst_reg</span><span class="p">[</span><span class="n">in0_base_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">vFloat</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dst_reg</span><span class="p">[</span><span class="n">in1_base_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">dst_reg</span><span class="p">[</span><span class="n">out_base_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// TRISC_MATH</span>

<span class="c1">// High-level API function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">my_add_tile</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx_dst0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx_dst1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx_out0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MATH</span><span class="p">(</span><span class="n">_llk_math_eltwise_binary_sfpu_params_</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span><span class="n">add_tile_face</span><span class="p">,</span><span class="w"> </span><span class="n">idx_dst0</span><span class="p">,</span><span class="w"> </span><span class="n">idx_dst1</span><span class="p">,</span><span class="w"> </span><span class="n">idx_out0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here’s a breakdown of the layers. The <code class="docutils literal notranslate"><span class="pre">add_tile_face</span></code> must be inside a <code class="docutils literal notranslate"><span class="pre">#ifdef</span> <span class="pre">TRISC_MATH</span></code> block, since they use math-thread-specific code that will not compile for other RISC-V cores.</p>
<ol class="arabic">
<li><p><strong>`my_add_tiles`</strong>: This is the main function called by the compute kernel. It wraps the internal function with the <code class="docutils literal notranslate"><span class="pre">MATH()</span></code> macro, which ensures the code only runs on the math thread of the Tensix core.  <code class="docutils literal notranslate"><span class="pre">_llk_math_eltwise_binary_sfpu_params_</span></code> is an internal helper that sets up the SFPU, iterates over all faces of a tile, calls <code class="docutils literal notranslate"><span class="pre">add_tile_face</span></code> for each face, and then cleans up. This avoids manual setup and state management.</p></li>
<li>
<p><strong>`add_tile_face`</strong>: This is the most basic function, performing the actual addition on a single tile face. A 32x32 tile is divided into four 16x16 faces, and this function is called for each face. It uses the <code class="docutils literal notranslate"><span class="pre">dst_reg</span></code> array, which represents the SFPU’s destination registers. The number of available <code class="docutils literal notranslate"><span class="pre">dst_reg</span></code> registers can be found in the <a class="reference internal" href="../advanced_topics/compute_engines_and_dataflow_within_tensix.html#compute-engines-and-dataflow-within-tensix"><span class="std std-ref">Compute Engines and Data Flow within Tensix</span></a> documentation.</p>
<p>The function calculates base indices (<code class="docutils literal notranslate"><span class="pre">in0_base_idx</span></code>, <code class="docutils literal notranslate"><span class="pre">in1_base_idx</span></code>, <code class="docutils literal notranslate"><span class="pre">out_base_idx</span></code>) to map tile indices to register addresses within <code class="docutils literal notranslate"><span class="pre">dst_reg</span></code>. Each tile occupies 32 registers; the base index is calculated by multiplying the tile index by 32 (refer to <a class="reference internal" href="../advanced_topics/tiles.html#internal-structure-of-a-tile"><span class="std std-ref">Internal structure of a Tile</span></a> for more information on tile structure). For example, processing tiles at indices 0, 1, and 0 results in base indices of 0, 32, and 0, respectively. This means the first input tile starts at <code class="docutils literal notranslate"><span class="pre">dst_reg[0]</span></code>, the second at <code class="docutils literal notranslate"><span class="pre">dst_reg[32]</span></code>, and the output overwrites the first input tile at <code class="docutils literal notranslate"><span class="pre">dst_reg[0]</span></code>.</p>
<p>Within each face, the function loads SIMD vectors (<code class="docutils literal notranslate"><span class="pre">vFloat</span></code>) from the input registers, adds them, and writes the result back to the output registers.</p>
<p>Each time the SFPI function is called, the helper automatically offsets <code class="docutils literal notranslate"><span class="pre">dst_reg</span></code> to point to the start of the current face. So, on the first call, <code class="docutils literal notranslate"><span class="pre">dst_reg</span></code> has an offset of 0; on the second, the offset is 8, and so on. The programmer does not need to manage this offset manually.</p>
</li>
</ol>
<p>This layered structure keeps high-level logic separate from hardware-specific details, making the code easier to read and maintain.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">n_vector_in_face</span></code> is architecture dependent. The example above assumes a Tensix architecture where each vector is 32 wide. Which is true for currently shipping Tensix Processors (Wormhole and Blackhole). But may change in future versions. Users should verify this value against their target architecture specifications when adapting this example.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are 3 internal APIs to invoke custom SFPI functions, depending on the number of input tiles. Please view the header file for the most up-to-date information.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_llk_math_eltwise_unary_sfpu_params_</span></code>: For functions with one input tile (e.g., <code class="docutils literal notranslate"><span class="pre">sin</span></code>, <code class="docutils literal notranslate"><span class="pre">exp</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_llk_math_eltwise_binary_sfpu_params_</span></code>: For functions with two input tiles (e.g., <code class="docutils literal notranslate"><span class="pre">add</span></code>, <code class="docutils literal notranslate"><span class="pre">sub</span></code>, <code class="docutils literal notranslate"><span class="pre">mul</span></code>, <code class="docutils literal notranslate"><span class="pre">div</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_llk_math_eltwise_ternary_sfpu_params_</span></code>: For functions with three input tiles (e.g., <code class="docutils literal notranslate"><span class="pre">where</span></code>).</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">_llk_math_eltwise_binary_sfpu_params_</span></code> and similar LLK helpers are internal APIs and may change in future releases. Tenstorrent does not guarantee backward compatibility for these internal functions. Users should keep their use up to date with the latest Metalium releases.</p>
</div>
</section>
<section id="runtime-arguments-and-execution">
<h2>Runtime Arguments and Execution<a class="headerlink" href="#runtime-arguments-and-execution" title="Permalink to this heading"></a>
</h2>
<p>Back on the host, we set the runtime arguments for the kernels. The reader and writer kernels need the DRAM buffer addresses, and all three kernels need to know the number of tiles to process.</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// tt_metal/programming_examples/custom_sfpi_add/custom_sfpi_add.cpp</span>
<span class="n">SetRuntimeArgs</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">reader</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">src0_dram_buffer</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">(),</span>
<span class="w">    </span><span class="n">src1_dram_buffer</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">(),</span>
<span class="w">    </span><span class="n">n_tiles</span>
<span class="p">});</span>

<span class="n">SetRuntimeArgs</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">writer</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">dst_dram_buffer</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">(),</span>
<span class="w">    </span><span class="n">n_tiles</span>
<span class="p">});</span>

<span class="n">SetRuntimeArgs</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">compute</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">n_tiles</span>
<span class="p">});</span>
</pre></div>
</div>
<p>For mesh execution, we add the program to a mesh workload and enqueue it for execution across the mesh. We also upload input data using the mesh buffer API.</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// tt_metal/programming_examples/custom_sfpi_add/custom_sfpi_add.cpp</span>

<span class="c1">// Upload input data to mesh buffers (non-blocking)</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">EnqueueWriteMeshBuffer</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span><span class="w"> </span><span class="n">src0_dram_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">a_data</span><span class="p">,</span><span class="w"> </span><span class="cm">/*blocking=*/</span><span class="nb">false</span><span class="p">);</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">EnqueueWriteMeshBuffer</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span><span class="w"> </span><span class="n">src1_dram_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">b_data</span><span class="p">,</span><span class="w"> </span><span class="cm">/*blocking=*/</span><span class="nb">false</span><span class="p">);</span>

<span class="c1">// Add program to mesh workload and execute</span>
<span class="n">workload</span><span class="p">.</span><span class="n">add_program</span><span class="p">(</span><span class="n">device_range</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">program</span><span class="p">));</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">EnqueueMeshWorkload</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span><span class="w"> </span><span class="n">workload</span><span class="p">,</span><span class="w"> </span><span class="cm">/*blocking=*/</span><span class="nb">false</span><span class="p">);</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">Finish</span><span class="p">(</span><span class="n">cq</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, we read back the results from the mesh buffer using the distributed API to verify correctness.</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span><span class="c1">// tt_metal/programming_examples/custom_sfpi_add/custom_sfpi_add.cpp</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bfloat16</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result_vec</span><span class="p">;</span>
<span class="n">distributed</span><span class="o">::</span><span class="n">EnqueueReadMeshBuffer</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span><span class="w"> </span><span class="n">result_vec</span><span class="p">,</span><span class="w"> </span><span class="n">dst_dram_buffer</span><span class="p">,</span><span class="w"> </span><span class="cm">/*blocking=*/</span><span class="nb">true</span><span class="p">);</span>

<span class="c1">// Validation against golden output...</span>
</pre></div>
</div>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading"></a>
</h2>
<p>This example demonstrated how to create a custom SFPI kernel for vector addition using the Mesh API. Key takeaways include:</p>
<ul class="simple">
<li><p>The layered approach to SFPI kernel development (high-level API, LLK wrapper, low-level face function).</p></li>
<li><p>The use of destination registers (<code class="docutils literal notranslate"><span class="pre">dst_reg</span></code>) for SFPU computations.</p></li>
<li><p>The role of the LLK API (e.g., <code class="docutils literal notranslate"><span class="pre">_llk_math_eltwise_binary_sfpu_params_</span></code>) in simplifying SFPI programming by handling tile face iteration.</p></li>
<li><p>The standard pipeline of reader, compute, and writer kernels for processing data on Tensix cores.</p></li>
</ul>
<p>By following this pattern, you can implement a wide variety of custom element-wise operations on the SFPU to accelerate your specific workloads while leveraging the distributed programming capabilities of the Mesh API.</p>
</section>
</section>



           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="custom_sfpi.html" class="btn btn-neutral float-left" title="Writing Custom SFPU Operations using SFPI" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="custom_sfpi_smoothstep.html" class="btn btn-neutral float-right" title="Smoothstep using SFPI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Tenstorrent.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        Version: <span id="current-version">latest</span>
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl id="version-list">
            <dt>Versions</dt>
        </dl>
        <br>
        </dl>
    </div>
</div>

<script>
const VERSIONS_URL = 'https://raw.githubusercontent.com/tenstorrent/tt-metal/refs/heads/main/docs/published_versions.json';

async function loadVersions() {
    try {
        const response = await fetch(VERSIONS_URL);
        const data = await response.json();
        const versionList = document.getElementById('version-list');
        const projectCode = location.pathname.split('/')[3];

        data.versions.forEach(version => {
            const dd = document.createElement('dd');
            const link = document.createElement('a');
            link.href = `https://docs.tenstorrent.com/tt-metal/${version}/${projectCode}/index.html`;
            link.textContent = version;
            dd.appendChild(link);
            versionList.appendChild(dd);
        });
    } catch (error) {
        console.error('Error loading versions:', error);
    }
}

loadVersions();

function getCurrentVersion() {
    return window.location.pathname.split('/')[2];
}
document.getElementById('current-version').textContent = getCurrentVersion();

const versionEl = document.createElement("span");
versionEl.innerText = getCurrentVersion();
versionEl.className = "project-versions";
const wySideSearchEl = document.getElementsByClassName("wy-side-nav-search").item(0);
if (wySideSearchEl) {
    const projectNameEl = wySideSearchEl.children.item(1);
    if (projectNameEl) projectNameEl.appendChild(versionEl);
}

</script><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
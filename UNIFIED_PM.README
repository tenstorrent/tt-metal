# Unified Programming Model

This document outlines the designs and features required to enable a unified programming model for both single- and multi-device Tensor and OP execution on Tenstorrent systems. The goal is to eliminate device boundaries from the user's perspective, allowing a program written for one device to "just work" across 2, 20, or 200 devices—without rewriting kernels or managing collectives manually.

It builds on top of work for a unified DM interface. See: https://docs.google.com/document/d/1DltQArjcl6cCBl_nghk5ihm7u1av6YJPIJal9jFEM6o/edit?tab=t.0

## Background

### Multi-device Tensor

Layouts of multi-device tensors are fully described by a global and local config. The global config enables reasoning of distribution across devices, while the local config captures all metadata describing the distribution of each shard on a device.

#### GlobalConfig (TensorTopology)

This defines how a tensor is partitioned or replicated across the entire MeshDevice. It captures the global sharding and replication strategy, specifying which dimensions are split across which devices and how the tensor is distributed across the mesh.

#### Local Config (TensorSpec)

For each device, TensorSpec describes the local configuration of its shard of the tensor. This includes shape, dtype, layout (RM/TILE), memory placement (DRAM/L1), and distribution (interleaved/sharded).

## Programming Model

Designing a programming model spans the full stack—from high-level model writers to low-level kernel execution—and requires tight integration between the following components:

### Model Writers

At the top level, users define models using a library of high-level operations (OPs), such as matmul, convolution, or layernorm. These OPs serve as the primary programming interface and encapsulate both computation and data movement logic.

### OP Writers

Each OP operates on some input tensor(s) to produce some output tensor(s), whose global layout (via TensorTopology) and local layout (via TensorSpec) describe how data is sharded, replicated, and locally distributed.

### Tensor Access at the Kernel Level

At the lowest level, device kernels access data through a unified TensorAccessor API. This API abstracts away the physical location of data and provides the necessary logic to perform arbitrary tile-based reads/writes. TensorAccessor is the backbone of generic OPs.

Together, these components form a layered and unified programming model that supports both ease of use for model authors and flexibility and performance for OP/kernel developers.

## Design

### Goals

A cohesive model should achieve the following:

| Goal | Description |
|------|-------------|
| Ease of Use | Everything should "just work" for the user. No manual collectives, re-sharding, or layout hacks. |
| Scalable by Default | OPs and kernels should be written once and scale automatically across device count and topology. |
| Optimizable When Needed | There should be a clean path to incrementally optimize for data locality and minimal cross-chip/core communication, without rewriting the entire OP or kernel logic. |

This approach enables rapid prototyping, large-scale model training, and flexible deployment while keeping low-level control and performance optimization within reach when needed.

### Requirements

To enable scalable, flexible, and maintainable multi-device programs, the programming model must meet the following requirements across the stack:

#### Model Writers: "It Just Works"

Model writers should be able to pass any multi-device tensor into an OP, regardless of how it's sharded or replicated. The OP must be capable of:

- Producing a correct output tensor, automatically inferring required collective communication and reshaping.
- Supporting an optional output tensor specification, allowing users to override defaults and control the output sharding when needed.
- Falling back to a reasonable default layout, derived from inputs, if no output layout is specified.

The user should not need to manually insert collectives or re-layouts. Multi-device tensor inputs should "just work."

#### OP Writers: One Setup, Any Scale

OP authors should be able to write an OP once and have it run correctly on 2, 20, or 200 devices, without rewriting for each topology. This requires:

- Abstractions like TensorTopology and TensorSpec to handle device-aware layout logic.
- A consistent programming interface for describing input/output layouts and deriving valid dataflow patterns (e.g., all-reduce, reduce-scatter) based on input topology.

The goal is to separate correctness from optimization: correctness is automatic; performance tuning is optional and incremental.

#### Kernel APIs: Universal Access

At the lowest level, kernels should expose seamless APIs that support:

- Generic read/write access to any tile on any core or device.
- Abstraction over whether a tile is local or remote (with the system handling routing, collectives, or synchronization as needed).
- A unified TensorAccessor model that encapsulates sharding, replication, and memory layout without requiring explicit fabric or NoC calls.

This enables writing generic kernels that can operate over the global tensor namespace and be reused across different topologies.

## Out of Scope

There are other topics to explore for enabling rapid kernel prototyping that are either orthogonal or an extension of this proposal and will be considered out of scope:

- **Unified Kernels Proposal**: https://docs.google.com/document/d/1I4zNe-fM3ybtMpf7IZbSea8DtGzOsLc-PLgLIxYGaqw/edit?tab=t.0
  - Reduce complexity of writing a kernel by consolidating to one kernel per OP
  - Abstract away as many unnecessary concepts as possible
- **Python DSLs**
  - Ability to prototype kernels natively in Python
  - Example: https://github.com/tile-ai/tilelang/tree/main/examples/gemm

## State of Things

Today, the programming model is defined at the single-device level for almost all OPs other than CCLs. Here is what these OPs look like:

Each program is written for a single device with local device access only. Examples of local device access include:

- Using the TensorAccessor API to read and write data that is local to that device.
- Working with data local to each core directly

To run across multiple devices, the same single-device program is naively replicated (or "stamped") across all devices in the MeshDevice.

For CCLs, there are some key differences that enable a slightly smarter programming model:

- Each single-device program specializes on concepts like NESW neighbours, links, etc.. to reason about multi-device properties.
- Communication with other devices is programmed explicitly with fabric APIs (currently all write-based).

This programming model places the burden on the user of the OPs (ie. model writers) or higher-level systems to explicitly and manually manage the global layout of the tensors and cross-device communications (e.g., AllGather, ReduceScatter) to ensure correct behaviour. Here are some examples that highlight shortcomings of this approach:

- If you AllGather on a replicated dim, should the CCL just error out? What's the user intent of performing such an operation?
- If you AllGather on a sharded dim, should the output tensor be considered replicated along that dim?
- If you call matmul, the user must carefully consider the resulting output based on the input tensor layouts and insert CCLs to get the correct result. Based on the desired output tensor, there is some sequence of pre-/post-matmul CCLs that must be inserted. Why do users have to figure this out?

### Table of Issues

This table summarizes top priority issues with our current programming model. It highlights a couple of key high-level issues with downstream impacts/side effects in a separate column.

| Issues | Impact | Comments |
|--------|--------|----------|
| **Model/OP Writers** | | |
| Programs are written per device and naively replicated across the mesh. | Manual tracking of global config + CCLs are required in models. | Need to leak multi-device logic as configurable params, which puts more burden on users. Instead, if lower-level concepts (eg. OPs, kernels) are multi-device native, users can not think about multi-device. |
| OPs are not natively multi-device aware. Primarily, they do not consider TensorTopology for input and output tensors. | *Manual tracking of global config + CCLs are required in models.<br><br>Duplicate point as first issue, because you need to solve both to address this. | |
| TensorTopology isn't consistently enforced or interpreted across OPs. Composition of OPs can lead to incorrect TensorTopology. | | |
| Defaults exist for output tensors, but are they correct for OPs like TMs and CCLs? | | |
| No option for specifying output TensorTopology. Need to insert CCLs to change global layout. | | Can we directly support arbitrary output tensor topology?<br><br>Or, decompose into pre-/post-OP CCLs + local OP? |
| **Kernel APIs/OP Infra** | | |
| Missing virtualization of device boundaries across OP infra | Cannot write a (set of) kernel(s) that work across any number of devices. | |
| Missing concrete definition of global tensor shape | Hard to reason about work distribution at multi-device tensor level. We need to answer this question: "What is the shape of a replicated dim?" | |
| TensorAccessor has no support for TensorTopology. | Only device-local read/writes are possible. This means, we cannot really virtualize device boundaries cleanly.<br><br>Unicasts should be doable, but how do you handle generic multicasts that span devices? | |
| Cross-device reads/writes must use low-level fabric/NOC APIs.<br><br>Or, any-to-any core communication is simply not possible (yet) | Eg. Fabric reads are not possible yet<br><br>Cannot cleanly build TensorAccessor support for any generic TensorTopology. | Core proposal of this doc:<br>https://docs.google.com/document/d/1DltQArjcl6cCBl_nghk5ihm7u1av6YJPIJal9jFEM6o/edit?tab=t.0 |

### Open Questions

- What does it mean to iterate work over a multi-device tensor? How do you handle replication? What is the shape?
- How do we support generic input and output TensorTopology? Native in kernels or decompose into pre-/post-OP CCLs + local OP?

## Proposal

### Overview

Key ideas:

- Distributed OPs with output tensor topology
- Virtualize MeshDevice so we just get sea of cores
- Write one (multi-device) kernel that targets sea of cores
- RT/CT args are virtualized
- Work distribution will be across full multi-device tensor
- Under the hood, we need to lower this program into single-device programs for dispatch

Assumptions/fundamental primitives that we need:

- TensorAccessor supports TensorTopology as well
- Build TensorAccessor with unified DM APIs

Key deliverable/MVP:

One distributed matmul that supports (all?) OP/kernel that:

- Runs on any number of devices
- Supports all input/output global layouts

Constraints:

- No mcasting primitives
- Every core greedily reads from whatever data it needs
- No re-use or blocking; purely single-tile based granularity
  - ie. No performance guarantee whatsoever
- Essentially, we are rewriting our DUMB_MULTI_CORE matmul but for multi-device

Minor points:

- For validation, we need to validate all shards of a multi-device tensor. Typically, for replicated dims, users manually use MeshComposer to extract just one shard/copy of replicated dims, but for testing we should check all replicated shards are actually the same

### Prototype Implementation Plan

#### Goal

Prototype a programming model where a MeshDevice can be programmed as a sea of cores without device boundaries. For example, a 2×4 grid of devices (each with 8×8 cores) is virtualized as a 16×32 sea of cores.

- Write programs that iterate through a virtualized coordinate system (e.g., 16×32)
- Use the same programming model as single-device programs (runtime/compile-time args, CBs, etc.)
- Lower the virtualized program into valid single-device programs and mesh workload for dispatch

#### 1. MeshDevice Virtual Coordinate APIs

Extend `MeshDevice` directly with virtual coordinate methods:

```cpp
class MeshDevice {
    // Existing methods...

    // New virtual coordinate APIs
    std::pair<size_t, size_t> get_virtual_core_grid() const;
    // Returns (16, 32) for 2×4 mesh of 8×8 devices

    std::tuple<Device*, size_t, size_t> virtual_to_physical(size_t vx, size_t vy) const;
    // Returns (device_ptr, local_x, local_y)

    std::pair<size_t, size_t> physical_to_virtual(Device* device, size_t lx, size_t ly) const;

    bool is_valid_virtual_coord(size_t vx, size_t vy) const;
};
```

**Design:**
- No wrapper class needed - extend MeshDevice directly
- Coordinate mapping: `device_id = (vx / 8) * 4 + (vy / 8)` for 2×4 mesh
- Local coords: `local_x = vx % 8, local_y = vy % 8`

#### 2. Virtualized Program Interface

Users write programs targeting virtual coordinate space:

```cpp
// User writes this - targeting virtual 16×32 grid
void configure_virtualized_program(MeshDevice& mesh) {
    auto [vx_max, vy_max] = mesh.get_virtual_core_grid();

    for (size_t vx = 0; vx < vx_max; vx++) {
        for (size_t vy = 0; vy < vy_max; vy++) {
            // Configure kernel using virtual coordinates
            configure_kernel(
                VirtualCoreCoord{vx, vy},
                runtime_args,
                compile_time_args,
                cb_config
            );
        }
    }
}
```

#### 3. Program Lowering

Transform virtualized programs into per-device programs:

```cpp
// Lowering process
std::map<Device*, Program> lower_virtual_program(
    MeshDevice& mesh,
    const VirtualProgram& vprogram
) {
    std::map<Device*, Program> device_programs;
    auto [vx_max, vy_max] = mesh.get_virtual_core_grid();

    for (size_t vx = 0; vx < vx_max; vx++) {
        for (size_t vy = 0; vy < vy_max; vy++) {
            auto [device, lx, ly] = mesh.virtual_to_physical(vx, vy);

            // Add this core's work to its device's program
            device_programs[device].add_kernel_config(
                CoreCoord{lx, ly},  // Physical local coords
                transform_runtime_args(vprogram, vx, vy),
                vprogram.compile_time_args
            );
        }
    }

    return device_programs;
}
```

#### 4. Component Breakdown

| Component | Description | Location |
|-----------|-------------|----------|
| Virtual coordinate APIs | `get_virtual_core_grid()`, `virtual_to_physical()`, etc. | MeshDevice class |
| `VirtualCoreCoord` | Struct holding (vx, vy) | New lightweight type |
| `VirtualProgram` | Program using virtual coords | New program type or builder |
| Lowering pass | Transforms VirtualProgram → per-device Programs | New compiler pass |
| Virtual TensorAccessor | TensorAccessor taking virtual coords | Extension of TensorAccessor |

#### 5. Implementation Phases

**Phase 1: MeshDevice Virtual Coord APIs (1 week)**
- Add virtual coordinate methods to MeshDevice
- Implement coordinate translation logic
- Unit tests for various mesh configurations (2×4, 1×2, 4×4)

**Phase 2: VirtualProgram Builder (1-2 weeks)**
- Design VirtualProgram representation
- API for configuring kernels with virtual coordinates
- Maintain same structure as single-device Program

**Phase 3: Simple Lowering (2 weeks)**
- Implement lowering for stateless kernels (no cross-device reads)
- Transform virtual coords → physical coords per device
- Test with element-wise OP on replicated tensor

**Phase 4: Cross-Device Access (3-4 weeks)**
- Extend TensorAccessor to accept virtual coordinates
- Use unified DM APIs for remote data access
- Handle sharded tensors across device boundaries

**Phase 5: Matmul Prototype (2-3 weeks)**
- Implement "DUMB_MULTI_DEVICE" matmul
- Single-tile granularity, no optimization
- Validate correct output for various TensorTopology configurations

#### 6. Example: Element-wise Kernel

**Step 1: User writes virtualized program**
```cpp
Program create_eltwise_virtual_program(MeshDevice& mesh, ...) {
    auto [vx_max, vy_max] = mesh.get_virtual_core_grid();

    VirtualProgram vprogram;
    for (size_t vx = 0; vx < vx_max; vx++) {
        for (size_t vy = 0; vy < vy_max; vy++) {
            vprogram.add_kernel(
                VirtualCoreCoord{vx, vy},
                "eltwise_kernel.cpp",
                {input_cb, output_cb},
                {/* runtime args based on vx, vy */}
            );
        }
    }
    return vprogram;
}
```

**Step 2: Lowering produces per-device programs**
```cpp
auto device_programs = lower_to_mesh(mesh, vprogram);
// Returns map: Device* → Program for that device's 8×8 cores
```

**Step 3: Dispatch to mesh**
```cpp
mesh.dispatch(device_programs);  // Existing dispatch infrastructure
```

#### 7. Key Design Decisions

- **Virtual coordinate system**: Row-major layout (vx traverses row across devices, vy traverses column)
- **API exposure**: Direct methods on MeshDevice (no wrapper class)
- **Lowering timing**: Compile-time pass before dispatch
- **Backward compatibility**: Existing single-device programs remain unchanged

diff --git a/models/demos/deepseek_v3/utils/config_helpers.py b/models/demos/deepseek_v3/utils/config_helpers.py
index da218d7947..b27a6ed862 100644
--- a/models/demos/deepseek_v3/utils/config_helpers.py
+++ b/models/demos/deepseek_v3/utils/config_helpers.py
@@ -656,16 +656,24 @@ def shard_and_save(

     # Always convert absolute paths to relative paths for portability
     # This ensures SavedWeight objects always have relative paths
-    if path.is_absolute():
-        path_str = str(path)
-        mesh_idx = path_str.find("mesh_")
-        if mesh_idx == -1:
-            raise ValueError(f"Expected 'mesh_' in path: {path}")
-        # Skip past "mesh_<rows>x<cols>/" to get relative path
-        parts = path_str[mesh_idx:].split("/", 1)
-        if len(parts) < 2:
-            raise ValueError(f"Invalid path structure after 'mesh_': {path}")
-        path = Path(parts[1])
+    # The path should be relative to the mesh directory (e.g., "embedding.weight.tensorbin")
+    path_str = str(path)
+    mesh_idx = path_str.find("mesh_")
+    if mesh_idx == -1:
+        raise ValueError(f"Expected 'mesh_' in path: {path}")
+
+    # Find the "/" after "mesh_<rows>x<cols>" to get past the mesh directory
+    # Look for the pattern "mesh_<rows>x<cols>/" and extract everything after it
+    mesh_part_end = path_str.find("/", mesh_idx)
+    if mesh_part_end == -1:
+        # No "/" after mesh_, so just use the filename
+        path = Path(path.name)
+    else:
+        # Extract everything after "mesh_<rows>x<cols>/"
+        relative_part = path_str[mesh_part_end + 1 :]
+        if not relative_part:
+            raise ValueError(f"Invalid path structure after 'mesh_<rows>x<cols>/': {path}")
+        path = Path(relative_part)

     return SavedWeight(path, memory_config)

diff --git a/models/demos/deepseek_v3/utils/test_utils.py b/models/demos/deepseek_v3/utils/test_utils.py
index 05055d0d30..4cb9ebac7d 100644
--- a/models/demos/deepseek_v3/utils/test_utils.py
+++ b/models/demos/deepseek_v3/utils/test_utils.py
@@ -628,7 +628,27 @@ def get_test_weight_config(
     force_recalculate: bool,
 ) -> Any:
     """Get the weight config, either by loading from cache or recalculating."""
-    per_test_weight_cache_path = cache_path / "tests_cache" / os.environ.get("PYTEST_CURRENT_TEST")
+    # Sanitize the test name from PYTEST_CURRENT_TEST to create a shorter, filesystem-safe path
+    # PYTEST_CURRENT_TEST format: "path/to/test_file.py::test_function[param1-param2-...] (call)"
+    pytest_test = os.environ.get("PYTEST_CURRENT_TEST", "unknown_test")
+
+    # Extract just the test function name and parameters, removing the file path
+    if "::" in pytest_test:
+        # Get the part after the last "::" (test function name with params)
+        test_part = pytest_test.split("::")[-1]
+        # Remove the " (call)" suffix if present
+        test_part = test_part.replace(" (call)", "").replace(" (setup)", "").replace(" (teardown)", "")
+        # Replace special characters that are problematic in file paths
+        sanitized = test_part.replace("::", "_").replace("[", "_").replace("]", "_").replace(" ", "_")
+        # Limit length to avoid filesystem issues (most filesystems have 255 char limit per component)
+        if len(sanitized) > 200:
+            sanitized = sanitized[:200]
+    else:
+        # Fallback: use a hash of the full test name if it doesn't match expected format
+        import hashlib
+        sanitized = hashlib.md5(pytest_test.encode()).hexdigest()[:16]
+
+    per_test_weight_cache_path = cache_path / "tests_cache" / sanitized
     return get_weight_config(
         ModuleClass, hf_config, state_dicts, per_test_weight_cache_path, mesh_device, force_recalculate
     )

// SPDX-FileCopyrightText: Â© 2025 Tenstorrent AI ULC
//
// SPDX-License-Identifier: Apache-2.0

// tt-smi: nvidia-smi style monitor for Tenstorrent devices
// Shows all processes using Tenstorrent devices with their memory usage
// Uses TT-UMD APIs for direct telemetry access

#include <iostream>
#include <iomanip>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <sstream>
#include <fstream>
#include <filesystem>
#include <chrono>
#include <thread>
#include <memory>
#include <optional>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <cstring>
#include <algorithm>
#include <dirent.h>
#include <limits.h>

// TT-Metal includes (which wrap UMD)
#include <tt-metalium/host_api.hpp>

#define TT_ALLOC_SERVER_SOCKET "/tmp/tt_allocation_server.sock"

namespace fs = std::filesystem;

// Message protocol (must match server)
struct __attribute__((packed)) AllocMessage {
    enum Type : uint8_t {
        ALLOC = 1,
        FREE = 2,
        QUERY = 3,
        RESPONSE = 4,
        DUMP_REMAINING = 5,
        DEVICE_INFO_QUERY = 6,
        DEVICE_INFO_RESPONSE = 7
    };

    Type type;
    uint8_t pad1[3];
    int32_t device_id;
    uint64_t size;
    uint8_t buffer_type;
    uint8_t pad2[3];
    int32_t process_id;
    uint64_t buffer_id;
    uint64_t timestamp;

    uint64_t dram_allocated;
    uint64_t l1_allocated;
    uint64_t l1_small_allocated;
    uint64_t trace_allocated;

    uint64_t total_dram_size;
    uint64_t total_l1_size;
    uint32_t arch_type;
    uint32_t num_dram_channels;
    uint32_t dram_size_per_channel;
    uint32_t l1_size_per_core;
    uint32_t is_available;
    uint32_t num_devices;
};

struct ProcessInfo {
    pid_t pid;
    std::string name;
    int device_id;
    uint64_t dram_used;
    uint64_t l1_used;
    bool connected_to_server;
};

struct TelemetryData {
    double asic_temperature = -1.0;
    std::optional<double> board_temperature;
    std::optional<uint32_t> aiclk;      // MHz
    std::optional<uint32_t> axiclk;     // MHz
    std::optional<uint32_t> arcclk;     // MHz
    std::optional<uint32_t> fan_speed;  // RPM
    std::optional<uint32_t> tdp;        // Watts
    std::optional<uint32_t> tdc;        // Amps
    std::optional<uint32_t> vcore;      // mV
};

struct DeviceInfo {
    int device_id;
    std::string arch_name;
    uint64_t total_dram;
    uint64_t total_l1;
    uint64_t used_dram;
    uint64_t used_l1;
    TelemetryData telemetry;
    std::vector<ProcessInfo> processes;
};

// ANSI colors
namespace Color {
    const char* RESET = "\033[0m";
    const char* BOLD = "\033[1m";
    const char* GREEN = "\033[32m";
    const char* YELLOW = "\033[33m";
    const char* RED = "\033[31m";
    const char* CYAN = "\033[36m";
    const char* WHITE = "\033[37m";
    const char* BLUE = "\033[34m";
    const char* MAGENTA = "\033[35m";
}

class TTSmi {
private:
    int socket_fd_;
    bool server_available_;

    // Get process name from PID
    std::string get_process_name(pid_t pid) {
        std::string comm_path = "/proc/" + std::to_string(pid) + "/comm";
        std::ifstream comm_file(comm_path);
        if (comm_file) {
            std::string name;
            std::getline(comm_file, name);
            return name;
        }
        return "unknown";
    }

    // Get command line for a process
    std::string get_process_cmdline(pid_t pid) {
        std::string cmdline_path = "/proc/" + std::to_string(pid) + "/cmdline";
        std::ifstream cmdline_file(cmdline_path);
        if (cmdline_file) {
            std::string cmdline;
            std::getline(cmdline_file, cmdline, '\0');
            // Extract just the executable name
            size_t last_slash = cmdline.find_last_of('/');
            if (last_slash != std::string::npos) {
                return cmdline.substr(last_slash + 1);
            }
            return cmdline.empty() ? get_process_name(pid) : cmdline;
        }
        return get_process_name(pid);
    }

    // Discover processes using Tenstorrent devices by scanning /proc
    std::set<pid_t> discover_processes_using_devices() {
        std::set<pid_t> pids;

        try {
            // Walk through /proc/[pid]/fd/ to find processes with tenstorrent devices open
            for (const auto& entry : fs::directory_iterator("/proc")) {
                if (!entry.is_directory()) continue;

                std::string dirname = entry.path().filename().string();
                if (!std::all_of(dirname.begin(), dirname.end(), ::isdigit)) continue;

                pid_t pid = std::stoi(dirname);

                // Check /proc/[pid]/fd/ for tenstorrent device files
                std::string fd_path = entry.path().string() + "/fd";
                try {
                    for (const auto& fd_entry : fs::directory_iterator(fd_path)) {
                        if (!fs::is_symlink(fd_entry)) continue;

                        fs::path target = fs::read_symlink(fd_entry);
                        std::string target_str = target.string();

                        if (target_str.find("/dev/tenstorrent/") != std::string::npos) {
                            pids.insert(pid);
                            break;
                        }
                    }
                } catch (...) {
                    // Permission denied or process exited
                    continue;
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "Warning: Error scanning /proc: " << e.what() << std::endl;
        }

        return pids;
    }

    // Try to connect to allocation server
    bool try_connect_to_server() {
        socket_fd_ = socket(AF_UNIX, SOCK_STREAM, 0);
        if (socket_fd_ < 0) {
            return false;
        }

        struct sockaddr_un addr;
        memset(&addr, 0, sizeof(addr));
        addr.sun_family = AF_UNIX;
        strncpy(addr.sun_path, TT_ALLOC_SERVER_SOCKET, sizeof(addr.sun_path) - 1);

        if (connect(socket_fd_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            close(socket_fd_);
            socket_fd_ = -1;
            return false;
        }

        return true;
    }

    // Query device info from server
    AllocMessage query_device_info(int device_id) {
        AllocMessage query;
        memset(&query, 0, sizeof(query));
        query.type = AllocMessage::DEVICE_INFO_QUERY;
        query.device_id = device_id;

        send(socket_fd_, &query, sizeof(query), 0);

        AllocMessage response;
        recv(socket_fd_, &response, sizeof(response), 0);
        return response;
    }

    // Query allocation stats from server
    AllocMessage query_device_stats(int device_id) {
        AllocMessage query;
        memset(&query, 0, sizeof(query));
        query.type = AllocMessage::QUERY;
        query.device_id = device_id;

        send(socket_fd_, &query, sizeof(query), 0);

        AllocMessage response;
        recv(socket_fd_, &response, sizeof(response), 0);
        return response;
    }

    // Get number of devices
    uint32_t get_num_devices() {
        AllocMessage query;
        memset(&query, 0, sizeof(query));
        query.type = AllocMessage::DEVICE_INFO_QUERY;
        query.device_id = -1;  // Special: query for count

        send(socket_fd_, &query, sizeof(query), 0);

        AllocMessage response;
        recv(socket_fd_, &response, sizeof(response), 0);
        return response.num_devices;
    }

    // Helper to read sysfs file as string
    static std::string read_sysfs_string(const std::string& path) {
        std::ifstream file(path);
        if (!file.is_open()) {
            return "";
        }
        std::string value;
        std::getline(file, value);
        return value;
    }

    // Helper to read sysfs file as integer
    static int64_t read_sysfs_int(const std::string& path) {
        std::string value = read_sysfs_string(path);
        if (value.empty()) {
            return -1;
        }
        try {
            return std::stoll(value);
        } catch (...) {
            return -1;
        }
    }

    // Read telemetry from sysfs (hwmon and tenstorrent driver)
    TelemetryData read_telemetry_from_device(int device_id) {
        TelemetryData data;

        // Find the PCIe device path for this device
        // The hwmon subsystem is at /sys/devices/pci.../hwmon/hwmonN/
        // We need to find the hwmon number for this device

        // First, find the device's PCIe path via tenstorrent class
        std::string class_path = "/sys/class/tenstorrent/tenstorrent!" + std::to_string(device_id);

        // Resolve the symlink to get the actual device path
        char real_path[PATH_MAX];
        ssize_t len = readlink(class_path.c_str(), real_path, sizeof(real_path) - 1);
        if (len == -1) {
            return data;  // Device not found
        }
        real_path[len] = '\0';

        // Convert relative path to absolute
        std::string device_path = class_path;
        if (real_path[0] != '/') {
            // Relative path, resolve it
            size_t last_slash = class_path.find_last_of('/');
            device_path = class_path.substr(0, last_slash + 1) + real_path;
        } else {
            device_path = real_path;
        }

        // Now find the hwmon directory under this device
        // Typically at /sys/devices/pci.../0000:XX:YY.Z/hwmon/hwmonN/
        std::string pci_base = device_path;
        // Navigate up to PCI device: tenstorrent!N -> tenstorrent -> PCI device
        size_t pos = pci_base.find("/tenstorrent/");
        if (pos != std::string::npos) {
            pci_base = pci_base.substr(0, pos);
        }

        // Find hwmon subdirectory
        std::string hwmon_base = pci_base + "/hwmon";
        DIR* dir = opendir(hwmon_base.c_str());
        if (!dir) {
            return data;
        }

        std::string hwmon_path;
        struct dirent* entry;
        while ((entry = readdir(dir)) != nullptr) {
            if (strncmp(entry->d_name, "hwmon", 5) == 0) {
                hwmon_path = hwmon_base + "/" + entry->d_name;
                break;
            }
        }
        closedir(dir);

        if (hwmon_path.empty()) {
            return data;
        }

        // Read telemetry from hwmon
        // Temperature (in millidegrees Celsius)
        int64_t temp = read_sysfs_int(hwmon_path + "/temp1_input");
        if (temp > 0) {
            data.asic_temperature = temp / 1000.0;  // Convert mC to C
        }

        // Power (in microwatts)
        int64_t power = read_sysfs_int(hwmon_path + "/power1_input");
        if (power >= 0) {
            data.tdp = static_cast<uint32_t>(power / 1000000);  // Convert ÂµW to W
        }

        // Current (in milliamps)
        int64_t current = read_sysfs_int(hwmon_path + "/curr1_input");
        if (current > 0) {
            data.tdc = static_cast<uint32_t>(current / 1000);  // Convert mA to A
        }

        // Voltage (in millivolts)
        int64_t voltage = read_sysfs_int(hwmon_path + "/in0_input");
        if (voltage > 0) {
            data.vcore = static_cast<uint32_t>(voltage);  // Already in mV
        }

        // Fan speed (in RPM)
        int64_t fan = read_sysfs_int(hwmon_path + "/fan1_input");
        if (fan > 0) {
            data.fan_speed = static_cast<uint32_t>(fan);
        }

        // Clock frequencies from tenstorrent driver
        int64_t aiclk = read_sysfs_int(class_path + "/tt_aiclk");
        if (aiclk > 0) data.aiclk = static_cast<uint32_t>(aiclk);

        int64_t axiclk = read_sysfs_int(class_path + "/tt_axiclk");
        if (axiclk > 0) data.axiclk = static_cast<uint32_t>(axiclk);

        int64_t arcclk = read_sysfs_int(class_path + "/tt_arcclk");
        if (arcclk > 0) data.arcclk = static_cast<uint32_t>(arcclk);

        return data;
    }

    // Format bytes
    std::string format_bytes(uint64_t bytes) {
        const char* units[] = {"B", "KB", "MB", "GB", "TB"};
        int unit = 0;
        double size = static_cast<double>(bytes);

        while (size >= 1024.0 && unit < 4) {
            size /= 1024.0;
            unit++;
        }

        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << size << units[unit];
        return oss.str();
    }

    // Get architecture name
    const char* get_arch_name(uint32_t arch_type) {
        switch (arch_type) {
            case 1: return "Grayskull";
            case 2: return "Wormhole_B0";
            case 3: return "Blackhole";
            case 4: return "Quasar";
            default: return "Unknown";
        }
    }

    // Print progress bar
    std::string get_bar(double percentage, int width = 20) {
        std::ostringstream bar;
        bar << "[";
        int filled = static_cast<int>((percentage / 100.0) * width);

        const char* color = Color::GREEN;
        if (percentage >= 90.0) color = Color::RED;
        else if (percentage >= 75.0) color = Color::YELLOW;

        for (int i = 0; i < width; ++i) {
            if (i < filled) {
                bar << color << "â–ˆ" << Color::RESET;
            } else {
                bar << "â–‘";
            }
        }
        bar << "]";
        return bar.str();
    }

    // Print horizontal line
    void print_line(int width = 100, char c = '-') {
        std::cout << std::string(width, c) << std::endl;
    }

    // Print device table header
    void print_device_header() {
        std::cout << Color::BOLD << Color::CYAN;
        std::cout << "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" << std::endl;
        std::cout << "â”‚ ";

        // Get current time
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        auto tm = *std::localtime(&time_t);

        std::cout << std::left << std::setw(40) << "tt-smi v1.0";
        std::cout << std::right << std::setw(59);

        std::ostringstream time_str;
        time_str << std::put_time(&tm, "%a %b %d %H:%M:%S %Y");
        std::cout << time_str.str();
        std::cout << " â”‚" << std::endl;

        std::cout << "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤" << std::endl;
        std::cout << "â”‚ " << std::left << std::setw(4) << "GPU"
                  << std::setw(16) << "Name"
                  << std::setw(10) << "Temp"
                  << std::setw(10) << "Power"
                  << std::setw(12) << "AICLK"
                  << std::setw(46) << "Memory-Usage"
                  << " â”‚" << std::endl;
        std::cout << "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤" << Color::RESET << std::endl;
    }

    void print_device_footer() {
        std::cout << Color::BOLD << Color::CYAN;
        std::cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜";
        std::cout << Color::RESET << std::endl;
    }

    void print_process_header() {
        std::cout << "\n" << Color::BOLD << Color::CYAN;
        std::cout << "Processes:" << Color::RESET << std::endl;
        std::cout << Color::BOLD << Color::CYAN;
        std::cout << "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" << std::endl;
        std::cout << "â”‚ " << std::left << std::setw(8) << "PID"
                  << std::setw(20) << "Name"
                  << std::setw(8) << "Device"
                  << std::setw(12) << "DRAM"
                  << std::setw(12) << "L1"
                  << std::setw(36) << "Status"
                  << " â”‚" << std::endl;
        std::cout << "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤" << Color::RESET << std::endl;
    }

    void print_process_footer() {
        std::cout << Color::BOLD << Color::CYAN;
        std::cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜";
        std::cout << Color::RESET << std::endl;
    }

public:
    TTSmi() : socket_fd_(-1), server_available_(false) {}

    ~TTSmi() {
        if (socket_fd_ >= 0) {
            close(socket_fd_);
        }
    }

    void run(bool watch_mode = false, int refresh_ms = 1000) {
        do {
            if (watch_mode) {
                // Clear screen
                std::cout << "\033[2J\033[H";
            }

            // Try to connect to allocation server
            server_available_ = try_connect_to_server();

            if (!server_available_) {
                std::cout << Color::YELLOW << "âš  Allocation server not running" << Color::RESET << std::endl;
                std::cout << "  Start it with: ./allocation_server_poc" << std::endl;
                std::cout << "\n  Showing system-level info only (no memory tracking)\n" << std::endl;
            }

            // Discover processes
            auto pids = discover_processes_using_devices();

            // Get device info
            std::vector<DeviceInfo> devices;
            uint32_t num_devices = 0;

            if (server_available_) {
                num_devices = get_num_devices();

                for (uint32_t i = 0; i < num_devices; ++i) {
                    auto dev_info = query_device_info(i);
                    auto stats = query_device_stats(i);

                    DeviceInfo dev;
                    dev.device_id = i;
                    dev.arch_name = get_arch_name(dev_info.arch_type);
                    dev.total_dram = dev_info.total_dram_size;
                    dev.total_l1 = dev_info.total_l1_size;
                    dev.used_dram = stats.dram_allocated;
                    dev.used_l1 = stats.l1_allocated;
                    dev.telemetry = read_telemetry_from_device(i);

                    devices.push_back(dev);
                }
            } else {
                // Without server, use TT-Metal device enumeration
                try {
                    size_t num_available = tt::tt_metal::GetNumAvailableDevices();
                    for (size_t i = 0; i < num_available; ++i) {
                        DeviceInfo dev;
                        dev.device_id = i;
                        dev.arch_name = "Unknown";
                        dev.total_dram = 0;
                        dev.total_l1 = 0;
                        dev.used_dram = 0;
                        dev.used_l1 = 0;
                        dev.telemetry = read_telemetry_from_device(i);

                        devices.push_back(dev);
                    }
                    num_devices = devices.size();
                } catch (const std::exception& e) {
                    std::cerr << "Warning: Failed to enumerate devices: " << e.what() << std::endl;
                }
            }

            // Populate process info
            for (pid_t pid : pids) {
                ProcessInfo proc;
                proc.pid = pid;
                proc.name = get_process_cmdline(pid);
                proc.device_id = 0;  // TODO: Detect which device the process is using
                proc.dram_used = 0;
                proc.l1_used = 0;
                proc.connected_to_server = false;  // We don't know without server extension

                // Associate with device 0 for now
                if (!devices.empty()) {
                    devices[0].processes.push_back(proc);
                }
            }

            // Print device table
            print_device_header();

            for (const auto& dev : devices) {
                std::cout << Color::BOLD << "â”‚ " << Color::RESET;
                std::cout << std::left << std::setw(4) << dev.device_id;
                std::cout << std::setw(16) << dev.arch_name;

                // Temperature (from UMD telemetry)
                if (dev.telemetry.asic_temperature >= 0) {
                    std::cout << std::fixed << std::setprecision(1)
                              << std::setw(10) << (std::to_string(static_cast<int>(dev.telemetry.asic_temperature)) + "Â°C");
                } else {
                    std::cout << std::setw(10) << "N/A";
                }

                // Power (from UMD telemetry - use TDP)
                if (dev.telemetry.tdp.has_value()) {
                    std::cout << std::setw(10) << (std::to_string(dev.telemetry.tdp.value()) + "W");
                } else {
                    std::cout << std::setw(10) << "N/A";
                }

                // AICLK (from sysfs telemetry)
                if (dev.telemetry.aiclk.has_value()) {
                    std::cout << std::setw(12) << (std::to_string(dev.telemetry.aiclk.value()) + " MHz");
                } else {
                    std::cout << std::setw(12) << "N/A";
                }

                // Memory usage (DRAM only in summary)
                if (server_available_ && dev.total_dram > 0) {
                    std::ostringstream mem_str;
                    mem_str << format_bytes(dev.used_dram) << "/" << format_bytes(dev.total_dram);
                    std::cout << std::setw(20) << mem_str.str();

                    double util = (static_cast<double>(dev.used_dram) / dev.total_dram) * 100.0;
                    std::cout << get_bar(util, 25);
                    std::cout << " " << std::fixed << std::setprecision(0) << util << "%";
                } else {
                    std::cout << std::setw(20) << "N/A";
                    std::cout << std::setw(38) << "";
                }

                std::cout << " â”‚" << std::endl;
            }

            print_device_footer();

            // Print detailed memory breakdown (if server available)
            if (server_available_ && !devices.empty()) {
                std::cout << "\n" << Color::BOLD << Color::CYAN << "Memory Breakdown:" << Color::RESET << std::endl;
                for (const auto& dev : devices) {
                    if (dev.total_dram == 0) continue;  // Skip devices without info

                    std::cout << "\n" << Color::BOLD << "Device " << dev.device_id << " (" << dev.arch_name << "):" << Color::RESET << std::endl;
                    std::cout << std::string(70, '-') << std::endl;

                    // DRAM
                    double dram_util = (dev.total_dram > 0) ?
                        (static_cast<double>(dev.used_dram) / dev.total_dram) * 100.0 : 0.0;
                    std::cout << "  DRAM:     " << std::setw(12) << format_bytes(dev.used_dram)
                              << " / " << std::setw(12) << format_bytes(dev.total_dram) << "  ";
                    std::cout << get_bar(dram_util, 25) << std::endl;

                    // L1
                    double l1_util = (dev.total_l1 > 0) ?
                        (static_cast<double>(dev.used_l1) / dev.total_l1) * 100.0 : 0.0;
                    std::cout << "  L1:       " << std::setw(12) << format_bytes(dev.used_l1)
                              << " / " << std::setw(12) << format_bytes(dev.total_l1) << "  ";
                    std::cout << get_bar(l1_util, 25) << std::endl;

                    // Query for additional memory types (L1_SMALL, TRACE)
                    auto stats = query_device_stats(dev.device_id);

                    // L1_SMALL
                    if (stats.l1_small_allocated > 0) {
                        std::cout << "  L1_SMALL: " << format_bytes(stats.l1_small_allocated) << std::endl;
                    }

                    // TRACE
                    if (stats.trace_allocated > 0) {
                        std::cout << "  TRACE:    " << format_bytes(stats.trace_allocated) << std::endl;
                    }
                }
            }

            // Print detailed telemetry section
            if (!devices.empty()) {
                std::cout << "\n" << Color::BOLD << Color::CYAN << "Device Telemetry:" << Color::RESET << std::endl;
                for (const auto& dev : devices) {
                    std::cout << "\n" << Color::BOLD << "Device " << dev.device_id << " (" << dev.arch_name << "):" << Color::RESET << std::endl;
                    std::cout << std::string(70, '-') << std::endl;

                    // Temperature
                    std::cout << "  Temperature: ";
                    if (dev.telemetry.asic_temperature >= 0) {
                        std::cout << Color::GREEN << std::fixed << std::setprecision(1)
                                  << dev.telemetry.asic_temperature << "Â°C" << Color::RESET;
                    } else {
                        std::cout << Color::YELLOW << "N/A" << Color::RESET;
                    }

                    if (dev.telemetry.board_temperature.has_value()) {
                        std::cout << "  (Board: " << std::fixed << std::setprecision(1)
                                  << dev.telemetry.board_temperature.value() << "Â°C)";
                    }
                    std::cout << std::endl;

                    // Power & Current
                    std::cout << "  Power:       ";
                    if (dev.telemetry.tdp.has_value()) {
                        std::cout << Color::GREEN << dev.telemetry.tdp.value() << "W" << Color::RESET;
                    } else {
                        std::cout << Color::YELLOW << "N/A" << Color::RESET;
                    }

                    if (dev.telemetry.tdc.has_value()) {
                        std::cout << "  (Current: " << dev.telemetry.tdc.value() << "A)";
                    }
                    std::cout << std::endl;

                    // Voltage
                    std::cout << "  Voltage:     ";
                    if (dev.telemetry.vcore.has_value()) {
                        std::cout << Color::GREEN << dev.telemetry.vcore.value() << "mV" << Color::RESET
                                  << " (" << std::fixed << std::setprecision(3)
                                  << (dev.telemetry.vcore.value() / 1000.0) << "V)";
                    } else {
                        std::cout << Color::YELLOW << "N/A" << Color::RESET;
                    }
                    std::cout << std::endl;

                    // Clock Frequencies
                    std::cout << "  Clocks:" << std::endl;
                    std::cout << "    AICLK:     ";
                    if (dev.telemetry.aiclk.has_value()) {
                        std::cout << Color::GREEN << dev.telemetry.aiclk.value() << " MHz" << Color::RESET;
                    } else {
                        std::cout << Color::YELLOW << "N/A" << Color::RESET;
                    }
                    std::cout << std::endl;

                    std::cout << "    AXICLK:    ";
                    if (dev.telemetry.axiclk.has_value()) {
                        std::cout << Color::GREEN << dev.telemetry.axiclk.value() << " MHz" << Color::RESET;
                    } else {
                        std::cout << Color::YELLOW << "N/A" << Color::RESET;
                    }
                    std::cout << std::endl;

                    std::cout << "    ARCCLK:    ";
                    if (dev.telemetry.arcclk.has_value()) {
                        std::cout << Color::GREEN << dev.telemetry.arcclk.value() << " MHz" << Color::RESET;
                    } else {
                        std::cout << Color::YELLOW << "N/A" << Color::RESET;
                    }
                    std::cout << std::endl;

                    // Fan Speed
                    if (dev.telemetry.fan_speed.has_value()) {
                        std::cout << "  Fan Speed:   " << Color::GREEN << dev.telemetry.fan_speed.value()
                                  << " RPM" << Color::RESET << std::endl;
                    }
                }
            }

            // Print process table
            if (!pids.empty()) {
                print_process_header();

                for (const auto& dev : devices) {
                    for (const auto& proc : dev.processes) {
                        std::cout << "â”‚ ";
                        std::cout << std::left << std::setw(8) << proc.pid;

                        // Truncate name if too long
                        std::string name = proc.name;
                        if (name.length() > 18) {
                            name = name.substr(0, 15) + "...";
                        }
                        std::cout << std::setw(20) << name;
                        std::cout << std::setw(8) << proc.device_id;

                        if (server_available_ && proc.connected_to_server) {
                            std::cout << std::setw(12) << format_bytes(proc.dram_used);
                            std::cout << std::setw(12) << format_bytes(proc.l1_used);
                            std::cout << std::setw(36) << (Color::GREEN + std::string("Connected to server") + Color::RESET);
                        } else {
                            std::cout << std::setw(12) << "N/A";
                            std::cout << std::setw(12) << "N/A";
                            std::cout << std::setw(36) << (Color::YELLOW + std::string("Device open (no tracking)") + Color::RESET);
                        }

                        std::cout << " â”‚" << std::endl;
                    }
                }

                print_process_footer();
            } else {
                std::cout << "\n" << Color::YELLOW << "No processes using Tenstorrent devices" << Color::RESET << std::endl;
            }

            // Print footer info
            if (!server_available_) {
                std::cout << "\n" << Color::CYAN << "ðŸ’¡ TIP:" << Color::RESET << " For memory tracking, start the allocation server:" << std::endl;
                std::cout << "   ./allocation_server_poc" << std::endl;
            } else {
                std::cout << "\n" << Color::CYAN << "ðŸ’¡ TIP:" << Color::RESET << " Processes must be instrumented to report memory to the server" << std::endl;
            }

            if (watch_mode) {
                std::this_thread::sleep_for(std::chrono::milliseconds(refresh_ms));
            }

            // Close connection for this iteration
            if (socket_fd_ >= 0) {
                close(socket_fd_);
                socket_fd_ = -1;
            }

        } while (watch_mode);
    }
};

int main(int argc, char* argv[]) {
    bool watch_mode = false;
    int refresh_ms = 1000;

    // Parse arguments
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-w" || arg == "--watch") {
            watch_mode = true;
        } else if (arg == "-r" && i + 1 < argc) {
            refresh_ms = std::stoi(argv[++i]);
        } else if (arg == "-h" || arg == "--help") {
            std::cout << "tt-smi: Tenstorrent System Management Interface (like nvidia-smi)" << std::endl;
            std::cout << "\nUsage: " << argv[0] << " [OPTIONS]" << std::endl;
            std::cout << "\nOptions:" << std::endl;
            std::cout << "  -w, --watch    Watch mode (refresh continuously)" << std::endl;
            std::cout << "  -r <ms>        Refresh interval in milliseconds (default: 1000)" << std::endl;
            std::cout << "  -h, --help     Show this help" << std::endl;
            std::cout << "\nExamples:" << std::endl;
            std::cout << "  " << argv[0] << "              # Show current state" << std::endl;
            std::cout << "  " << argv[0] << " -w            # Watch mode (like 'watch tt-smi')" << std::endl;
            std::cout << "  " << argv[0] << " -w -r 500     # Watch with 500ms refresh" << std::endl;
            std::cout << "\nNote:" << std::endl;
            std::cout << "  For full memory tracking, the allocation server must be running:" << std::endl;
            std::cout << "    ./allocation_server_poc" << std::endl;
            return 0;
        }
    }

    try {
        TTSmi smi;
        smi.run(watch_mode, refresh_ms);
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

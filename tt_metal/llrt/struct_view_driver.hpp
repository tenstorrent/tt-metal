// SPDX-FileCopyrightText: Â© 2025 Tenstorrent AI ULC.
//
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <ostream>
#include <span>
#include <type_traits>

#include <enchantum/enchantum.hpp>

namespace tt::tt_metal::hal_structs {

// Accessor for offsets arrays generated by code generator.
class StructInfo {
private:
    // For a struct with n fields, x distinct array sizes and y distinct structs:
    // [0] -> size of entire struct
    // [1..n) -> offset of field 1..n-1 (field 0's offset is always 0, not stored)
    // [n..n+x) -> distinct array sizes
    // [n+x..n+x+y) -> pointers to offsets of the struct fields
    const uintptr_t* offsets_;

public:
    StructInfo(const uintptr_t* offsets) : offsets_(offsets) {}

    size_t get(size_t index) const { return reinterpret_cast<size_t>(offsets_[index]); }
    StructInfo get_info(size_t index) const { return {reinterpret_cast<uintptr_t*>(offsets_[index])}; }
    size_t get_size() const { return get(0); }
    size_t offset_of(size_t i) const { return i ? offsets_[i] : 0; }
};

template <typename Struct>
class StructSpan {
private:
    using view_type = std::conditional_t<std::is_const_v<Struct>, typename Struct::ConstView, typename Struct::View>;
    using byte_type = view_type::byte_type;

public:
    StructSpan(const StructInfo info, byte_type* base, size_t size) : info_(info), base_(base), size_(size) {}
    size_t size() const { return size_; }

    view_type operator[](size_t i) const { return {info_, base_ + i * info_.get_size()}; }
    class iterator {
    private:
        const StructInfo info_;
        byte_type* ptr_;
        iterator(const StructInfo info, byte_type* ptr) : info_(info), ptr_(ptr) {}
        friend class StructSpan;

    public:
        iterator& operator++() {
            ptr_ += info_.get_size();
            return *this;
        }
        bool operator!=(const iterator& other) const { return ptr_ != other.ptr_; }
        view_type operator*() const { return {info_, ptr_}; }
    };
    iterator begin() const { return {info_, base_}; }
    iterator end() const { return {info_, base_ + size_ * info_.get_size()}; }

private:
    StructInfo info_;
    byte_type* base_;
    size_t size_;
};

template <bool Const, typename Struct>
class BaseStructView {
private:
    template <typename T>
    using same_const_t = std::conditional_t<Const, const T, T>;
    template <Struct::Field F>
    using FieldTraits = typename Struct::template FieldTraits<Const, F>;

public:
    using byte_type = same_const_t<std::byte>;
    BaseStructView(const StructInfo info, byte_type* base) : info_(info), base_(base) {}

    // Allow getting const view from non-const view
    operator typename Struct::ConstView() const { return {info_, base_}; }

    byte_type* data() const { return base_; }
    size_t size() const { return info_.get_size(); }
    size_t offset_of(Struct::Field i) const { return info_.offset_of(static_cast<size_t>(i)); }

    template <typename T, size_t I>
    struct ScalarField {
        using element_type = same_const_t<T>;
        using type = element_type&;
        static type get(const BaseStructView& view) { return *reinterpret_cast<element_type*>(view.ptr_of(I)); }
    };
    template <typename T, size_t I, size_t A>
    struct ScalarArray {
        using element_type = same_const_t<T>;
        using type = std::span<element_type>;
        static type get(const BaseStructView& view) {
            return {reinterpret_cast<element_type*>(view.ptr_of(I)), view.info_.get(A)};
        }
    };
    template <typename T, size_t I, size_t S>
    struct StructField {
        using struct_type = T;
        using type = std::conditional_t<Const, typename struct_type::ConstView, typename struct_type::View>;
        static type get(const BaseStructView& view) { return {view.info_.get_info(S), view.ptr_of(I)}; }
    };
    template <typename T, size_t I, size_t S, size_t A>
    struct StructArray {
        using element_type = same_const_t<T>;
        using type = StructSpan<element_type>;
        static type get(const BaseStructView& view) {
            return {view.info_.get_info(S), view.ptr_of(I), view.info_.get(A)};
        }
    };
    template <Struct::Field F>
    decltype(auto) get() const {
        return FieldTraits<F>::get(*this);
    }

private:
    byte_type* ptr_of(size_t i) const { return base_ + info_.offset_of(i); }
    StructInfo info_;
    byte_type* base_;
};

template <typename Struct>
class StructBuffer {
public:
    StructBuffer(const StructInfo info) : info_(info), storage_(std::make_unique<std::byte[]>(info.get_size())) {}
    StructBuffer(const StructBuffer& other) : StructBuffer(other.info_) {
        std::copy(other.data(), other.data() + size(), data());
    }
    StructBuffer& operator=(const StructBuffer& other) {
        *this = StructBuffer(other);
        return *this;
    }
    StructBuffer(StructBuffer&&) = default;
    StructBuffer& operator=(StructBuffer&&) = default;

    std::byte* data() { return storage_.get(); }
    const std::byte* data() const { return storage_.get(); }

    auto view() { return typename Struct::View{info_, data()}; }
    auto view() const { return typename Struct::ConstView{info_, data()}; }

    size_t size() const { return info_.get_size(); }

protected:
    StructInfo info_;
    std::unique_ptr<std::byte[]> storage_;
};

namespace stream_suppliments {

// dump char in numeric value, not characters
inline std::ostream& operator<<(std::ostream& os, char c) { return os << static_cast<unsigned>(c); }
inline std::ostream& operator<<(std::ostream& os, unsigned char c) { return os << static_cast<unsigned>(c); }

template <typename T>
std::ostream& operator<<(std::ostream& os, const std::span<T>& span) {
    os << "{";
    const char* sep = " ";
    for (const auto& elem : span) {
        os << sep << elem;
        sep = ", ";
    }
    os << " }";
    return os;
}

}  // namespace stream_suppliments

template <typename Struct>
std::ostream& operator<<(std::ostream& os, const BaseStructView<true, Struct>& view) {
    [&]<size_t... Is>(std::index_sequence<Is...>) {
        using namespace stream_suppliments;
        os << "{";
        ((os << (Is == 0 ? " ." : ", .") << enchantum::to_string(static_cast<typename Struct::Field>(Is)) << " = "
             << view.template get<static_cast<typename Struct::Field>(Is)>()),
         ...);
        os << " }";
    }(std::make_index_sequence<Struct::fields_count>());
    return os;
}

template <typename Struct>
std::ostream& operator<<(std::ostream& os, const BaseStructView<false, Struct>& view) {
    return os << typename Struct::ConstView(view);
}

template <typename Struct>
std::ostream& operator<<(std::ostream& os, const StructSpan<Struct>& span) {
    using namespace stream_suppliments;
    os << "{";
    const char* sep = " ";
    for (size_t i = 0; i < span.size(); ++i) {
        os << sep << span[i];
        sep = ", ";
    }
    os << " }";
    return os;
}

}  // namespace tt::tt_metal::hal_structs

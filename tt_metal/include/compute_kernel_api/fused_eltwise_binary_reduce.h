/*
The algorithm is as follows:

// Initialize eltwise binary operation (sets up ALU for binary ops)
binary_op_init_common(cb_inp0, cb_inp1, cb_intermediate);

// Initialize binary tiles (conditional compilation from original eltwise_binary.cpp)
binary_tiles_init<true, ELTWISE_OP_TYPE>(cb_in0, cb_in1);

mul_tiles

mul_tiles is called with the last argument being 0, meaning the index of the result in dest register.

after this we should call: eltwise_binary_reuse_dest_as_src, moving the result to srcA, so the exact call should look
like: <EltwiseBinaryReuseDestType::DEST_TO_SRCA>eltwise_binary_reuse_dest_as_src().

after reusing dest, we should overwrite the first tile in dest with ones and move that tile to srcB. the code should
look like this:
  // populate dest with ones, something like the method bellow (generated by deep-wiki)
  inline void _populate_first_tile_with_ones_()
  {
    // Second tile starts at offset 64 (32x32 tile = 64 rows in dest layout)
    constexpr uint first_tile_offset = 0;

    // Populate the entire first tile with LCONST_1 (value 1.0)
    for (uint row = 0; row < 32; row += 4) {
        // Store LCONST_1 to all positions in the first tile
        TT_SFPSTORE(p_sfpu::LCONST_1, 0, ADDR_MOD_3, first_tile_offset + row);
        TT_SFPSTORE(p_sfpu::LCONST_1, 0, ADDR_MOD_3, first_tile_offset + row + 2);
        TT_SFPSTORE(p_sfpu::LCONST_1, 0, ADDR_MOD_3, first_tile_offset + row + 32);
        TT_SFPSTORE(p_sfpu::LCONST_1, 0, ADDR_MOD_3, first_tile_offset + row + 34);
    }
  }

after this we should call: eltwise_binary_reuse_dest_as_src, moving the result to srcB, so the exact call should look
like: <EltwiseBinaryReuseDestType::DEST_TO_SRCB>eltwise_binary_reuse_dest_as_src().

the remainig part of the algorithm should be reduce_init, reduce, reduce_uninit.

Claude should figure out the best interface for the algorithm and generate this file (without deleting this comment)
*/

#pragma once

#include "compute_kernel_api/common.h"
#include "compute_kernel_api/eltwise_binary.h"
#include "compute_kernel_api/reduce.h"

#ifdef TRISC_MATH
#include "llk_math_eltwise_binary.h"
#include "llk_math_reduce_api.h"
#include "ckernel_sfpu.h"
#endif

namespace ckernel {

// clang-format off
/**
 * Simplified interface that handles the complete fused operation
 * Following the exact algorithm step by step as specified
 *
 * | Argument       | Description                                                   | Type     | Valid Range | Required |
 * |----------------|---------------------------------------------------------------|----------|-------------|----------|
 * | cb_inp0        | Input circular buffer 0                                       | uint32_t | 0 to 31     | True     |
 * | cb_inp1        | Input circular buffer 1                                       | uint32_t | 0 to 31     | True     |
 * | cb_scaler      | Scaler circular buffer                                        | uint32_t | 0 to 31     | True     |
 * | cb_out         | Output circular buffer                                        | uint32_t | 0 to 31     | True     |
 * | itile0         | Input tile 0 index                                           | uint32_t | 0+          | True     |
 * | itile1         | Input tile 1 index                                           | uint32_t | 0+          | True     |
 * | iscaler        | Scaler tile index                                             | uint32_t | 0+          | True     |
 * | idst           | Destination tile index                                        | uint32_t | 0+          | True     |
 */
// clang-format on
// =============================================================================
// PHASE 1: ELTWISE BINARY INITIALIZATION (NO PACKER)
// =============================================================================
template <EltwiseBinaryType eltwise_binary_type = ELTWISE_OP_TYPE, bool full_init = true>
ALWI void fused_eltwise_binary_init(uint32_t cb_inp0, uint32_t cb_inp1, bool acc_to_dest = false) {
    // UNPACK initialization - configure and init for both input CBs
    UNPACK((llk_unpack_AB_hw_configure_disaggregated<DST_ACCUM_MODE>(cb_inp0, cb_inp1)));
    UNPACK((llk_unpack_AB_init<BroadcastType::NONE>(cb_inp0, cb_inp1)));

    // MATH initialization - configure sync and hardware, then init eltwise binary
    MATH((llk_math_pack_sync_init<DST_ACCUM_MODE>()));
    MATH((llk_math_hw_configure_disaggregated(cb_inp0, cb_inp1)));
    MATH((llk_math_eltwise_binary_init<eltwise_binary_type, NONE, MATH_FIDELITY>(0 /*transpose*/, acc_to_dest)));

    // Optional full initialization for UNPACK (conditional compilation)
    if constexpr (full_init) {
        UNPACK((llk_unpack_AB_init<BroadcastType::NONE>(cb_inp0, cb_inp1, 0 /*transpose*/, acc_to_dest)));
    }
}

// =============================================================================
// PHASE 2: ELTWISE BINARY OPERATION
// =============================================================================
template <EltwiseBinaryType eltwise_binary_type = ELTWISE_OP_TYPE, uint32_t idst = 0>
ALWI void fused_eltwise_binary_compute(uint32_t cb_inp0, uint32_t cb_inp1, uint32_t itile0, uint32_t itile1) {
    // 3. Eltwise binary operation (with last argument being 0, meaning the index of the result in dest register)
    static_assert(idst == 0, "idst must be 0");  // since we are reusing dest as srcA

    // Use the low-level LLK calls directly since we're in a fused operation
    UNPACK((llk_unpack_AB(cb_inp0, cb_inp1, itile0, itile1)));
    MATH((llk_math_eltwise_binary<
          eltwise_binary_type,
          NONE,
          DST_ACCUM_MODE,
          MATH_FIDELITY,
          EltwiseBinaryReuseDestType::NONE>(idst)));
}

// =============================================================================
// PHASE 3: DESTINATION REUSE
// =============================================================================
ALWI void fused_eltwise_binary_reuse_dest() {
    // 4. eltwise_binary_reuse_dest_as_src, moving the result to srcA
    MATH(eltwise_binary_reuse_dest_as_src<EltwiseBinaryReuseDestType::DEST_TO_SRCA>());

    // tensix_sync(); // todo: remove unnecessary sync

    // 5. populate dest with ones
    MATH(ckernel::sfpu::_populate_first_tile_with_ones_());

    // tensix_sync();

    // 6. eltwise_binary_reuse_dest_as_src, moving the result to srcB
    MATH(eltwise_binary_reuse_dest_as_src<EltwiseBinaryReuseDestType::DEST_TO_SRCB>());
}

// =============================================================================
// PHASE 4: REDUCE INITIALIZATION (NO UNPACKER)
// =============================================================================
template <PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM>
ALWI void fused_reduce_init() {
    // MATH initialization - init reduce operation (no unpacker calls)
    MATH((llk_math_reduce_init<reduce_type, reduce_dim, MATH_FIDELITY>()));

    // PACK initialization - configure reduce mask for the specified dimension
    PACK((llk_pack_reduce_mask_config<false /*untilize*/, reduce_dim>()));
}

// =============================================================================
// PHASE 5: REDUCE OPERATION
// =============================================================================
template <PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM, bool fp32_transpose = false>
ALWI void fused_reduce_compute(uint32_t idst) {
    // 8. reduce operation (using srcA from dest reuse, cb_scaler used as dummy first param)
    // reduce_tile<reduce_type, reduce_dim>(cb_scaler, cb_scaler, iscaler, iscaler, idst); - under comment bcs of
    // UNPACKER
    MATH((llk_math_reduce<reduce_type, reduce_dim, DST_ACCUM_MODE, MATH_FIDELITY, false, fp32_transpose>(idst)));
}

// =============================================================================
// PHASE 6: REDUCE CLEANUP
// =============================================================================
ALWI void fused_reduce_uninit() {
    // 9. reduce_uninit
    reduce_uninit();
}
}  // namespace ckernel

<%-

header = "\
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AUTO_GENERATED! DO NOT MODIFY!                                                                              //
// Please run                                                                                                  //
//                                                                                                             //
// (echo '<\% type=:c_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.h     //
// (echo '<\% type=:cpp_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.hpp //
// Open noc_overlay_parameters.hpp and move static class varaible definitions to noc_overlay_parameters.cpp    //
// overriding existing ones.                                                                                   //
//                                                                                                             //
// to regenerate                                                                                               //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
"

c_header_basic = "\
#ifndef NOC_OVERLAY_PARAMETERS_BASIC_H
#define NOC_OVERLAY_PARAMETERS_BASIC_H

#define NOC_NUM_STREAMS 64

#define NUM_MCAST_STREAM_ID_START 0
#define NUM_MCAST_STREAM_ID_END   3
#define NUM_RECEIVER_ENDPOINT_STREAM_ID_START 4
#define NUM_RECEIVER_ENDPOINT_STREAM_ID_END   5
#define NUM_REMOTE_RECEIVER_STREAM_ID_START 0
#define NUM_REMOTE_RECEIVER_STREAM_ID_END 63
#define RECEIVER_ENDPOINT_STREAM_MSG_GROUP_SIZE 4
#define RECEIVER_ENDPOINT_STREAM_MSG_INFO_FIFO_GROUPS     2
#define NON_RECEIVER_ENDPOINT_STREAM_MSG_INFO_FIFO_GROUPS 2
#define DEST_READY_COMMON_CACHE_NUM_ENTRIES 24
#define DEST_READY_MCAST_CACHE_NUM_ENTRIES 8

#define NOC_OVERLAY_START_ADDR     0xFFB40000
#define NOC_STREAM_REG_SPACE_SIZE  0x1000

#define STREAM_REG_ADDR(stream_id, reg_id) ((NOC_OVERLAY_START_ADDR) + (((uint32_t)(stream_id))*(NOC_STREAM_REG_SPACE_SIZE)) + (((uint32_t)(reg_id)) << 2))

#define NOC0_REGS_START_ADDR       0xFFB20000
#define NOC1_REGS_START_ADDR       0xFFB30000

#define NCRISC_STREAM_RANGE_1_START 0
#define NCRISC_STREAM_RANGE_1_END   3
#define NCRISC_STREAM_RANGE_2_START 8
#define NCRISC_STREAM_RANGE_2_END   11
#define NCRISC_PIC_CONFIG_PHASE_DEFAULT           0

#define NOC_STREAM_WRITE_REG(stream_id, reg_id, val)  ((*((volatile uint32_t*)(STREAM_REG_ADDR(stream_id, reg_id)))) = (val))
#define NOC_STREAM_READ_REG(stream_id, reg_id)        (*((volatile uint32_t*)(STREAM_REG_ADDR(stream_id, reg_id))))

#define NOC_STREAM_WRITE_REG_FIELD(stream_id, reg_id, field, val) (NOC_STREAM_WRITE_REG(stream_id, reg_id, ((NOC_STREAM_READ_REG(stream_id, reg_id) & ~((1 << field##_WIDTH) - 1)) | ((val & ((1 << field##_WIDTH) - 1)) << field))))
#define NOC_STREAM_READ_REG_FIELD(stream_id, reg_id, field)       ((NOC_STREAM_READ_REG(stream_id, reg_id) >> field) & ((1 << field##_WIDTH) - 1))
#define NOC_STREAM_GET_REG_FIELD(reg_val, field)       (((reg_val) >> field) & ((1 << field##_WIDTH) - 1))

#define NOC_WRITE_REG(addr, val) ((*((volatile uint32_t*)(addr)))) = (val)
#define NOC_READ_REG(addr)       (*((volatile uint32_t*)(addr)))


#define NOC_ID_WIDTH     6
#define STREAM_ID_WIDTH  6

#define DEST_CNT_WIDTH   6
#define NOC_NUM_WIDTH     1

#define STREAM_REG_INDEX_WIDTH 8
#define STREAM_REG_CFG_DATA_WIDTH 24

#define MEM_WORD_WIDTH 16
#define MEM_WORD_ADDR_WIDTH 17

#define MEM_WORD_BIT_OFFSET_WIDTH 7

#endif
"

registers = [
    {
        :index => 0,
        :name => "STREAM_REMOTE_SRC",
        :description  => "\
        // Properties of the remote source stream (coorindates, stream ID, and this streams destination index).
        // Dont-care unless REMOTE_SOURCE == 1.
        ",
        :fields =>  [
            { :name => "STREAM_REMOTE_SRC_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_SRC_Y", :offset => "(STREAM_REMOTE_SRC_X+STREAM_REMOTE_SRC_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "REMOTE_SRC_STREAM_ID", :offset => "(STREAM_REMOTE_SRC_Y+STREAM_REMOTE_SRC_Y_WIDTH)", :width => "STREAM_ID_WIDTH" },
            { :name => "STREAM_REMOTE_SRC_DEST_INDEX", :offset => "(REMOTE_SRC_STREAM_ID+REMOTE_SRC_STREAM_ID_WIDTH)", :width => "STREAM_ID_WIDTH" },
            { :name => "DRAM_READS__TRANS_SIZE_WORDS_LO", :offset => "(STREAM_REMOTE_SRC_Y+STREAM_REMOTE_SRC_Y_WIDTH)", :width => "12" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_SRC_PHASE",
        :description  => "\
        // Remote source phase (may be different from the destination stream phase.)
        // We use 20-bit phase ID, so phase count doesnt wrap until 1M phases.
        // Dont-care unless REMOTE_SOURCE == 1.
        ",
        :fields =>  [
            { :name => "DRAM_READS__SCRATCH_1_PTR", :offset => "0", :width => "19" },
            { :name => "DRAM_READS__TRANS_SIZE_WORDS_HI", :offset => "(DRAM_READS__SCRATCH_1_PTR+DRAM_READS__SCRATCH_1_PTR_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST",
        :description  => "\
        // Properties of the remote destination stream (coorindates, stream ID).  Dont-care unless REMOTE_RECEIVER == 1.
        // If destination is multicast, this register specifies the starting coordinates of the destination
        // multicast group/rectangle. (The end coordinates are in STREAM_MCAST_DEST below.)
        ",
        :fields =>  [
            { :name => "STREAM_REMOTE_DEST_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_DEST_Y", :offset => "(STREAM_REMOTE_DEST_X+STREAM_REMOTE_DEST_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_DEST_STREAM_ID", :offset => "(STREAM_REMOTE_DEST_Y+STREAM_REMOTE_DEST_Y_WIDTH)", :width => "STREAM_ID_WIDTH" },
        ],
    },
    {
        :index => :same_as_prev,
        :name => "STREAM_LOCAL_DEST",
        :description  => "\
        // Properties of the local destination gather stream connection.
        // Dont-care unless LOCAL_RECEIVER == 1.
        // Shares register space with STREAM_REMOTE_DEST_REG_INDEX.
        ",
        :fields =>  [
            { :name => "STREAM_LOCAL_DEST_MSG_CLEAR_NUM", :offset => "0", :width => "12" },
            { :name => "STREAM_LOCAL_DEST_STREAM_ID", :offset => "(STREAM_LOCAL_DEST_MSG_CLEAR_NUM+STREAM_LOCAL_DEST_MSG_CLEAR_NUM_WIDTH)", :width => "STREAM_ID_WIDTH" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_BUF_START",
        :description  => "\
        // Start address (in words) of the remote destination stream memory buffer.
        ",
        :fields =>  [
            { :name => "DRAM_WRITES__SCRATCH_1_PTR_LO", :offset => "0", :width => "16" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_BUF_SIZE",
        :description  => "\
        // Size (in words) of the remote destination stream memory buffer.
        ",
        :fields =>  [
            { :name => "REMOTE_DEST_BUF_SIZE_WORDS", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "DRAM_WRITES__SCRATCH_1_PTR_HI", :offset => "0", :width => "3" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_WR_PTR",
        :description  => "\
        // Write pointer for the remote destination stream memory buffer.
        // Can be written directly; automatically reset to 0 when
        // STREAM_REMOTE_DEST_BUF_START is written.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_BUF_START",
        :description  => "\
        // Start address (in words) of the memory buffer associated with this stream.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_BUF_SIZE",
        :description  => "\
        // Stream buffer size (in words).
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_PTR",
        :description  => "\
        // Stream message info buffer address.
        //
        // This register needs to be initialized to the start of the message info buffer during
        // phase configuration.  Subsequently it will be incremented by hardware as data are read
        // from the buffer, thus doubling as the read pointer during phase execution.
        //
        // Stream hardware will assume that this buffer is large enough to hold info for all messages
        // within a phase, so unlike the buffer, it never needs to wrap.
        //
        // The buffer is filled automatically by snooping for streams with remote source.
        // For source enpoints, the buffer is written explicitly (along with the data buffer), after which
        // STREAM_NUM_MSGS_RECEIVED_INC is written to notify the stream that messages are available for
        // sending.
        //
        // Write pointer is also managed automatically by hardware, but can be read or reset using
        // STREAM_MSG_INFO_WR_PTR_REG. Write pointer is also reset when writing this register.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_WR_PTR",
        :description  => "\
        // Write pointer for the remote destination message info buffer.
        // Dont-care unless REMOTE_RECEIVER==1.
        // Needs to be initialized to the start of the message info buffer of the remote destination
        // at phase start, if destination is changed.
        // Subsequently its incremented automatically as messages are forwarded.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MISC_CFG",
        :description  => "\
        // The ID of NOCs used for incoming and outgoing data, followed by misc. stream configuration options:
        //   * Source - set exactly one of these to 1:
        //        SOURCE_ENDPOINT = source is local math/packer
        //        REMOTE_SOURCE = source is remote sender stream
        //        LOCAL_SOURCES_CONNECTED = source is one or more local connected streams
        //   * Destination - set one or zero of these to 1:
        //        RECEIVER_ENDPOINT = stream is read by local unpacker/math
        //        REMOTE_RECEIVER = stream forwards data to a remote destination or multicast group
        //        LOCAL_RECEIVER = stream is connected to a local destination stream
        //        None set = stream just stores data in a local buffer, without forwarding/clearing, and
        //                   finishes the phase once all messages have been received
        //   * Phase/data forward options:
        //      PHASE_AUTO_CONFIG = set to 1 for stream to fetch next phase configuration automatically.
        //      PHASE_AUTO_ADVANCE = set to 1 for stream to advance to next phase automatically
        //            (otherwise need to write STREAM_PHASE_ADVANCE below)
        //      DATA_AUTO_SEND = set to 1 to forward data automatically based on read/write pointers;
        //             set to 0 to forward data only when STREAM_NEXT_MSG_SEND is written
        ",
        :fields =>  [
            { :name => "INCOMING_DATA_NOC", :offset => "0", :width => "NOC_NUM_WIDTH" },
            { :name => "OUTGOING_DATA_NOC", :offset => "(INCOMING_DATA_NOC+INCOMING_DATA_NOC_WIDTH)", :width => "NOC_NUM_WIDTH" },
            { :name => "REMOTE_SRC_UPDATE_NOC", :offset => "(OUTGOING_DATA_NOC+OUTGOING_DATA_NOC_WIDTH)", :width => "NOC_NUM_WIDTH" },
            { :name => "LOCAL_SOURCES_CONNECTED", :offset => "(REMOTE_SRC_UPDATE_NOC+REMOTE_SRC_UPDATE_NOC_WIDTH)", :width => "1" },
            { :name => "SOURCE_ENDPOINT", :offset => "(LOCAL_SOURCES_CONNECTED+LOCAL_SOURCES_CONNECTED_WIDTH)", :width => "1" },
            { :name => "REMOTE_SOURCE", :offset => "(SOURCE_ENDPOINT+SOURCE_ENDPOINT_WIDTH)", :width => "1" },
            { :name => "RECEIVER_ENDPOINT", :offset => "(REMOTE_SOURCE+REMOTE_SOURCE_WIDTH)", :width => "1" },
            { :name => "LOCAL_RECEIVER", :offset => "(RECEIVER_ENDPOINT+RECEIVER_ENDPOINT_WIDTH)", :width => "1" },
            { :name => "REMOTE_RECEIVER", :offset => "(LOCAL_RECEIVER+LOCAL_RECEIVER_WIDTH)", :width => "1" },
            { :name => "PHASE_AUTO_CONFIG", :offset => "(REMOTE_RECEIVER+REMOTE_RECEIVER_WIDTH)", :width => "1" },
            { :name => "PHASE_AUTO_ADVANCE", :offset => "(PHASE_AUTO_CONFIG+PHASE_AUTO_CONFIG_WIDTH)", :width => "1" },
            { :name => "DATA_AUTO_SEND", :offset => "(PHASE_AUTO_ADVANCE+PHASE_AUTO_ADVANCE_WIDTH)", :width => "1" },
            { :name => "NEXT_PHASE_SRC_CHANGE", :offset => "(DATA_AUTO_SEND+DATA_AUTO_SEND_WIDTH)", :width => "1" },
            { :name => "NEXT_PHASE_DEST_CHANGE", :offset => "(NEXT_PHASE_SRC_CHANGE+NEXT_PHASE_SRC_CHANGE_WIDTH)", :width => "1" },
            {
                :name => "DATA_BUF_NO_FLOW_CTRL", :offset => "(NEXT_PHASE_DEST_CHANGE+NEXT_PHASE_DEST_CHANGE_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_SOURCE==1 and the buffer is large enough to accept full phase data without wrapping:
                ",
            },
            {
                :name => "DEST_DATA_BUF_NO_FLOW_CTRL", :offset => "(DATA_BUF_NO_FLOW_CTRL+DATA_BUF_NO_FLOW_CTRL_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_RECEIVER==1 and the destination buffer is large enough to accept full phase data without wrapping:
                ",

            },
            {
                :name => "REMOTE_SRC_IS_MCAST", :offset => "(DEST_DATA_BUF_NO_FLOW_CTRL+DEST_DATA_BUF_NO_FLOW_CTRL_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_SOURCE==1 and has mulicast enabled (i.e. this stream is part of a multicast group)
                ",

            },
            {
                :name => "NO_PREV_PHASE_OUTGOING_DATA_FLUSH", :offset => "(REMOTE_SRC_IS_MCAST+REMOTE_SRC_IS_MCAST_WIDTH)", :width => "1",
                :description  => "\
                // set if no need to flush outgoing remote data from previous phase
                ",

            },
            {
                :name => "UNICAST_VC_REG", :offset => "(NO_PREV_PHASE_OUTGOING_DATA_FLUSH+NO_PREV_PHASE_OUTGOING_DATA_FLUSH_WIDTH)", :width => "3",
                :description  => "\
                // set to one of the values (0-5) to select which VC unicast requests will be sent on
                ",

            },
            {
                :name => "REG_UPDATE_VC_REG", :offset => "(UNICAST_VC_REG+UNICAST_VC_REG_WIDTH)", :width => "3",
                :description  => "\
                // set to one of the values (0-5) to select which VC control flow updates will be sent on
                ",

            },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_CURR_PHASE",
        :description  => "\
        // Current phase number executed by the stream.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_AUTO_CFG_PTR",
        :description  => "\
        // Pointer to the stream auto-config data. Initialized to the start of
        // the auto-config structure at workload start, automatically updated
        // subsequenty.
        // Specified as byte address, needs to be multiple of 4B.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MCAST_DEST",
        :description  => "\
        // Destination spec for multicasting streams. STREAM_MCAST_END_X/Y are
        // the end coordinate for the multicast rectangle, with the ones from
        // STREAM_REMOTE_DEST taken as start.
        // Dont-care if STREAM_MCAST_EN == 0.
        ",
        :fields =>  [
            { :name => "STREAM_MCAST_END_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_MCAST_END_Y", :offset => "(STREAM_MCAST_END_X+STREAM_MCAST_END_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_MCAST_EN", :offset => "(STREAM_MCAST_END_Y+STREAM_MCAST_END_Y_WIDTH)", :width => "1" },
            { :name => "STREAM_MCAST_LINKED", :offset => "(STREAM_MCAST_EN+STREAM_MCAST_EN_WIDTH)", :width => "1" },
            {
                :name => "STREAM_MCAST_VC", :offset => "(STREAM_MCAST_LINKED+STREAM_MCAST_LINKED_WIDTH)", :width => "1",
                :description  => "\
                // Set to 0 to select VC 4, and 1 to select VC 5 (default 0)
                ",
            },
            { :name => "STREAM_MCAST_NO_PATH_RES", :offset => "(STREAM_MCAST_VC+STREAM_MCAST_VC_WIDTH)", :width => "1" },
            { :name => "STREAM_MCAST_XY", :offset => "(STREAM_MCAST_NO_PATH_RES+STREAM_MCAST_NO_PATH_RES_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MCAST_DEST_NUM",
        :description  => "\
        // Number of multicast destinations (dont-care for non-multicast streams)
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_GATHER",
        :description  => "\
        // Specifies MSG_ARB_GROUP_SIZE. Valid values are 1 (round-robin
        // arbitration between each incoming stream) or 4 (round-robin arbitration
        // between groups of 4 incoming streams).
        ",
        :fields =>  [
            { :name => "MSG_ARB_GROUP_SIZE", :offset => "0", :width => "3" },
            { :name => "MSG_SRC_IN_ORDER_FWD", :offset => "(MSG_ARB_GROUP_SIZE+MSG_ARB_GROUP_SIZE_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_SRC_IN_ORDER_FWD_NUM_MSGS",
        :description  => "\
        // When using in-order message forwarding, number of messages after which the source
        // pointer goes back to zero (without phase change).
        // Dont-care if STREAM_MCAST_EN == 0 or MSG_SRC_IN_ORDER_FWD == 0.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_HEADER_FORMAT",
        :description  => "\
        // Offset & size of the size field in the message header. Only valid offsets are multiples of 8
        // (i.e. byte-aligned).
        ",
        :fields =>  [
            { :name => "MSG_HEADER_WORD_CNT_OFFSET", :offset => "0", :width => "MEM_WORD_BIT_OFFSET_WIDTH" },
            { :name => "MSG_HEADER_WORD_CNT_BITS", :offset => "(MSG_HEADER_WORD_CNT_OFFSET+MSG_HEADER_WORD_CNT_OFFSET_WIDTH)", :width => "MEM_WORD_BIT_OFFSET_WIDTH" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NUM_MSGS_RECEIVED",
        :description  => "\
        // Number of received & stored messages (read-only).
        // To get the total number of messages penidng in memory read
        // STREAM_NUM_MSGS_RECEIVED_IN_BUF_AND_MEM_REG_INDEX
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NEXT_RECEIVED_MSG_ADDR",
        :description  => "\
        // Memory address (in words) of the next in line received message (read-only).
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NEXT_RECEIVED_MSG_SIZE",
        :description  => "\
        // Size in words of the next in line received message (read-only).
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_CLEAR",
        :description  => "\
        // Clear message info for one or more stored messages.  Only valid values are 1, 2, or 4.
        // No effect on the read pointer.
        // Should be used only for streams where RECEIVER_ENDPOINT == 1.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_DATA_CLEAR",
        :description  => "\
        // Move read pointer & reclaim buffer space for one or more stored messages.
        // Sends flow control update to the source if REMOTE_SOURCE==1.
        // Only valid values are 1, 2, or 4.
        // Should be used only for streams where RECEIVER_ENDPOINT == 1, after
        // STREAM_MSG_INFO_CLEAR_REG has been written with the same value.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NEXT_MSG_SEND",
        :description  => "\
        // Write to send the next in line stored message. Used when DATA_AUTO_SEND == 0.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_RD_PTR",
        :description  => "\
        // Read pointer value (word offset relative to buffer start). Can be updated by
        // writing the register (e.g. to force resend).
        // Value does not guarantee that all data up to the current value have been sent
        // off (forwarding command may be  ongoing).  To find out free space in the buffer,
        // read STREAM_BUF_SPACE_AVAILABLE.
        // Automatically reset to 0 when STREAM_BUF_START_REG is updated.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_WR_PTR",
        :description  => "\
        // Write pointer value (word offset relative to buffer start).
        // Can be read to determine the location at which to write new data.
        // In normal operation, should be updated only by writing
        // STREAM_NUM_MSGS_RECEIVED_INC_REG or STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO_REG.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_WR_PTR",
        :description  => "\
        // Write pointer value for message info buffer (absolute word address).
        // In normal operation, should be updated only by writing
        // STREAM_NUM_MSGS_RECEIVED_INC_REG or STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO_REG.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_ADVANCE",
        :description  => "\
        // Write-only. Write 1 to advance to the next phase if PHASE_AUTO_ADVANCE == 0.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_BUF_SPACE_AVAILABLE",
        :description  => "\
        // Available buffer space at the stream (in 16B words).
        // Source cant send data unless available space > 0.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO",
        :description  => "\
        // For endpoints with SOURCE_ENDPOINT == 1, this register is for firmware
        // to register new message for sending.
        // This updates the msg_info register structure directly, rather than writing to the message info
        // buffer in memory.
        // Must not be written when the message info register structure is full, or if
        // there are message info entries in the memory buffer. (This would cause a race
        // condition.)
        ",
        :fields =>  [
            { :name => "SOURCE_ENDPOINT_NEW_MSG_ADDR", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "SOURCE_ENDPOINT_NEW_MSG_SIZE", :offset => "(SOURCE_ENDPOINT_NEW_MSG_ADDR+SOURCE_ENDPOINT_NEW_MSG_ADDR_WIDTH)", :width => "(32-MEM_WORD_ADDR_WIDTH)" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NUM_MSGS_RECEIVED_INC",
        :description  => "\
        // For endpoints with SOURCE_ENDPOINT == 1, this register is for firmware
        // to update the number of messages whose data & header are available in the memory buffer.
        // Hardware register is incremented atomically if sending of previous messages is in progress.
        ",
        :fields =>  [
            { :name => "SOURCE_ENDPOINT_NEW_MSGS_NUM", :offset => "0", :width => "12" },
            { :name => "SOURCE_ENDPOINT_NEW_MSGS_TOTAL_SIZE", :offset => "(SOURCE_ENDPOINT_NEW_MSGS_NUM+SOURCE_ENDPOINT_NEW_MSGS_NUM_WIDTH)", :width => "MEM_WORD_ADDR_WIDTH" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_RESET",
        :description  => "\
        // Write to reset & stop stream.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_DEST_PHASE_READY_UPDATE",
        :description  => "\
        // Write phase number to indicate destination ready for the given phase.
        // (This is done automatically by stream hardware when starting a phase with REMOTE_SOURCE=1.)
        // The phase number is the one indicated by STREAM_REMOTE_SRC_PHASE_REG at destination.
        // This register is mapped to the shared destination ready table, not a per-stream register.
        // (Stream index is taken from the register address, and stored into the table along with the
        // phase number.)
        ",
        :fields =>  [
            { :name => "PHASE_READY_DEST_NUM", :offset => "0", :width => "6" },
            { :name => "PHASE_READY_NUM", :offset => "(PHASE_READY_DEST_NUM+PHASE_READY_DEST_NUM_WIDTH)", :width => "20" },
            {
                :name => "PHASE_READY_MCAST", :offset => "(PHASE_READY_NUM+PHASE_READY_NUM_WIDTH)", :width => "1",
                :description  => "\
                // set if this stream is part of multicast group (i.e. if REMOTE_SRC_IS_MCAST==1)
                ",
            },
            {
                :name => "PHASE_READY_TWO_WAY_RESP", :offset => "(PHASE_READY_MCAST+PHASE_READY_MCAST_WIDTH)", :width => "1",
                :description  => "\
                // set if the message is in response to 2-way handshake
                ",
            },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SRC_READY_UPDATE",
        :description  => "\
        // Source ready message register for two-way handshake (sent by source in
        // case destination ready entry is not found in the table).
        // If received by a stream that already sent its ready update, it prompts resending.
        ",
        :fields =>  [
            { :name => "STREAM_REMOTE_RDY_SRC_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_RDY_SRC_Y", :offset => "(STREAM_REMOTE_RDY_SRC_X+STREAM_REMOTE_RDY_SRC_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "REMOTE_RDY_SRC_STREAM_ID", :offset => "(STREAM_REMOTE_RDY_SRC_Y+STREAM_REMOTE_RDY_SRC_Y_WIDTH)", :width => "STREAM_ID_WIDTH" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE",
        :description  => "\
        // Update available buffer space at remote destination stream.
        // this is rd_ptr increment issued when a message is forwarded
        ",
        :fields =>  [
            { :name => "REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE_DEST_NUM", :offset => "0", :width => "6" },
            { :name => "REMOTE_DEST_BUF_WORDS_FREE_INC", :offset => "(REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE_DEST_NUM+REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE_DEST_NUM_WIDTH)", :width => "MEM_WORD_ADDR_WIDTH" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_WAIT_STATUS",
        :description  => "\
        // Status info for the stream.
        ",
        :fields =>  [
            {
                :name => "WAIT_SW_PHASE_ADVANCE_SIGNAL", :offset => "0", :width => "1",
                :description  => "\
                // Set when stream is in START state with auto-config disabled, or if auto-config is enabled
                // but PHASE_AUTO_ADVANCE=0
                ",
            },
            {
                :name => "WAIT_PREV_PHASE_DATA_FLUSH", :offset => "(WAIT_SW_PHASE_ADVANCE_SIGNAL+WAIT_SW_PHASE_ADVANCE_SIGNAL_WIDTH)", :width => "1",
                :description  => "\
                // Set when stream has configured the current phase, but waits data from the previous one to be flushed.
                ",
            },
            {
                :name => "MSG_FWD_ONGOING", :offset => "(WAIT_PREV_PHASE_DATA_FLUSH+WAIT_PREV_PHASE_DATA_FLUSH_WIDTH)", :width => "1",
                :description  => "\
                // Set when stream is in data forwarding state.
                ",
            },
            { :name => "STREAM_CURR_STATE", :offset => "(MSG_FWD_ONGOING+MSG_FWD_ONGOING_WIDTH)", :width => "4" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_AUTO_CFG_HEADER",
        :description  => "\
        // Register corresponding to the auto-configuration header. Written by each auto-config access
        // at phase start, can be also written by software for initial configuration or if auto-config
        // is disabled.
        // PHASE_NUM_INCR is phase number increment relative to the previous executed phase (or 0 right
        // after reset). The increment happens after auto-config is done, and before the phase is executed.
        // (Therefore reading  STREAM_CURR_PHASE_REG while auto-config is ongoing, or if it hasnt started
        // yet, may return the old phase number.)
        // This enables up to 2^12-1 phases to be skipped. If more phases need to be skipped, it is
        // necessary to insert an intermediate phase with zero messages, whose only purpose is to provide
        // an additional skip offset.
        ",
        :fields =>  [
            { :name => "PHASE_NUM_INCR", :offset => "0", :width => "12" },
            { :name => "CURR_PHASE_NUM_MSGS", :offset => "(PHASE_NUM_INCR+PHASE_NUM_INCR_WIDTH)", :width => "12" },
            { :name => "NEXT_PHASE_NUM_CFG_REG_WRITES", :offset => "(CURR_PHASE_NUM_MSGS+CURR_PHASE_NUM_MSGS_WIDTH)", :width => "8" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_PERF_CONFIG",
        :description  => "\
        // Should be written only for stream 0, applies to all streams.
        ",
        :fields =>  [
            { :name => "CLOCK_GATING_EN", :offset => "0", :width => "1" },
            { :name => "CLOCK_GATING_HYST", :offset => "(CLOCK_GATING_EN+CLOCK_GATING_EN_WIDTH)", :width => "7" },
            {
                :name => "PARTIAL_SEND_WORDS_THR", :offset => "(CLOCK_GATING_HYST+CLOCK_GATING_HYST_WIDTH)", :width => "8",
                :description  => "\
                // PARTIAL_SEND_WORDS_THR contols the minimum number of 16-byte words of a tile to accumulate in a relay stream before sending it off to the destination.
                // If the size of the tile is less than or equal to PARTIAL_SEND_WORDS_THR, then this feild is ignored.
                // Default is 16 words
                ",
            },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_GROUP_ZERO_MASK_AND",
        :description  => "\
        // AND value of zero masks for the pending message group.
        // (Header bits [95:64].)
        // Read-only.  Valid only for receiver endpoint streams.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_FULL",
        :description  => "\
        // Returns 1 if the message info register is full (read-only).
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MEM_BUF_SPACE_AVAILABLE_ACK_THRESHOLD",
        :description  => "\
        // 4-bit wide register that determines the threshold at which a stream
        // with remote source sends an update message to STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE.
        // Dont-care unless REMOTE_SOURCE==1.
        // Values:
        //   value[3:0] == 0 => disable threshold. Acks send as soon as any data are cleared/forwarded.
        //   value[3:0] >  0 => threshold calculated according to the following formula:
        //         if (value[3])
        //              threshold = buf_size - (buf_size >> value[2:0])
        //         else
        //              threshold = (buf_size >> value[2:0])
        //
        // This enables setting thresholds of buf_size/2, buf_size/4, buf_size/8, ... buf_size/256,
        // as well as  3*buf_size/4, 7*buf_size/8, etc.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_CAN_PUSH_NEW_MSG",
        :description  => "\
        // Returns 1 if the message info register can accept new message push (read-only).
        // Equivalent to checking the condition:
        //   (STREAM_MSG_INFO_FULL_REG_INDEX == 0) && (STREAM_MSG_INFO_PTR_REG_INDEX == STREAM_MSG_INFO_WR_PTR_REG_INDEX)
        // (I.e. ther is free space in the msg info register, and we dont have any message info headers in the
        //  memory buffer about to be fetched.)
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_GROUP_COMPRESS",
        :description  => "\
        // Concat compress flags from 4 tiles in the pending message group.
        // (Header bit 52.)
        // Read-only.  Valid only for receiver endpoint streams.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_GATHER_CLEAR",
        :description  => "\
        // Msg_LOCAL_STREAM_CLEAR_NUM specifies the number of messages that should
        // be cleared from a gather stream before moving onto the next stream.
        // When MSG_ARB_GROUP_SIZE > 1, the order of clearing the streams can be selected
        // with MSG_GROUP_STREAM_CLEAR_TYPE. 0 = clear the whole group MSG_LOCAL_STREAM_CLEAR_NUM times,
        // 1 = clear each stream of the group MSG_LOCAL_STREAM_CLEAR_NUM times before
        // moving onto the next stream in the group.
        ",
        :fields =>  [
            { :name => "MSG_LOCAL_STREAM_CLEAR_NUM", :offset => "0", :width => "16" },
            { :name => "MSG_GROUP_STREAM_CLEAR_TYPE", :offset => "(MSG_LOCAL_STREAM_CLEAR_NUM+MSG_LOCAL_STREAM_CLEAR_NUM_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_TRAFFIC_PRIORITY",
        :description  => "\
        // Priority for traffic sent to remote destination.
        // Valid only for streams capable of remote sending.
        // 4-bit value.
        // Set to 0 to send traffic under round-robin arbitration.
        // Set to 1-15 for priority arbitration (higher values are higher priority).
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_DEBUG_STATUS_SEL",
        :description  => "\
        // Debug bus stream selection. Write the stream id for the stream that you want exposed on the debug bus
        // This register only exists in stream 0.
        ",
        :fields =>  [
            { :name => "DEBUG_STATUS_STREAM_ID_SEL", :offset => "0", :width => "STREAM_ID_WIDTH" },
            { :name => "DISABLE_DEST_READY_TABLE", :offset => "(DEBUG_STATUS_STREAM_ID_SEL+DEBUG_STATUS_STREAM_ID_SEL_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_DEBUG_ASSERTIONS",
        :description  => "\
        // Debugging: Non-zero value indicates an invalid stream operation occured.
        // Sticky, write 1 to clear.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NUM_MSGS_RECEIVED_IN_BUF_AND_MEM",
        :description  => "\
        // Only in receiver endpoint streams (stream 4 and 5)
        // Read-only. Tells you the number of tiles that have arrived in L1
        ",
        :fields =>  [
        ],
    },
    {
        :index => 48,
        :name => "STREAM_LOCAL_SRC_MASK",
        :description  => "\
        // Bit mask of connnected local source. Dont care if LOCAL_SOURCES_CONNECTED == 0.
        // Mask segments [23:0], [47:24], and [63:48] are at indexes STREAM_LOCAL_SRC_MASK_REG_INDEX,
        // STREAM_LOCAL_SRC_MASK_REG_INDEX+1, STREAM_LOCAL_SRC_MASK_REG_INDEX+2.
        ",
        :fields =>  [
        ],
    },
    {
        :index => 60,
        :name => "STREAM_RECEIVER_ENDPOINT_SET_MSG_HEADER",
        :description  => "\
        // For receiver endpoint streams that expose the full message header bus to unpacker,
        // write this register to specify the full header in case the stream is not snooping
        // a remote source but instead also works as a source endpoint.
        // Write (STREAM_RECEIVER_ENDPOINT_SET_MSG_HEADER_REG_INDEX+i) to set bits [i*32 +: 32]
        // of the message header for the next message, prior to writing STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO_REG_INDEX.
        ",
        :fields =>  [
        ],
    },
    {
        :index => 64,
        :name => "STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE",
        :description  => "\
        // Available buffer space at remote destination stream(s).
        // Dont care unless REMOTE_RECEIVER == 1.
        // Source cant send data unless WORDS_FREE > 0.
        // Read-only; updated automatically to maximum value when
        // STREAM_REMOTE_DEST_BUF_SIZE_REG is updated.
        // For multicast streams, values for successive destinations are at
        // subsequent indexes (STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_REG_INDEX+1,
        // STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_REG_INDEX+2, etc.).
        ",
        :fields =>  [
            { :name => "REMOTE_DEST_WORDS_FREE", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
        ],
    },
    {
        :index => 128,
        :name => "STREAM_RECEIVER_MSG_INFO",
        :description  => "\
        // Read-only register view of the bits on the o_full_msg_info bus.
        // Exposed as 32-bit read-only registers starting at this index.
        ",
        :fields =>  [
        ],
    },
    {
        :index => 224,
        :name => "STREAM_DEBUG_STATUS",
        :description  => "\
        // Read-only register that exposes internal states of the stream.
        // Useful for debugging. Valid 32-bit data from STREAM_DEBUG_STATUS_REG_INDEX + 0 to STREAM_DEBUG_STATUS_REG_INDEX + 9
        ",
        :fields =>  [
        ],
    },
    {
        :index => 234,
        :name => "STREAM_BLOB_AUTO_CFG_DONE",
        :description  => "\
        // 32 bit register. Each bit denotes whether the corresponding stream has completed its blob run and is in idle state.
        // Resets to 0 upon starting a new stream run. Initially all are 0 to exclude streams that might not be used.
        // Can be manually reset to 0 by writing 1 to the corresponding bit.
        // Exists only in stream 0
        ",
        :fields =>  [
        ],
    },
    {
        :index => 242,
        :name => "STREAM_REMOTE_DEST_BUF_START_HI",
        :description  => "\
        // High bits for STREAM_REMOTE_DEST_BUF_START
        ",
        :fields =>  [
        ],
    },
    {
        :index => 243,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_WR_PTR_HI",
        :description  => "\
        // High bits for STREAM_REMOTE_DEST_MSG_INFO_WR_PTR
        ",
        :fields =>  [
        ],
    },
    {
        :index => 244,
        :name => "STREAM_CURR_PHASE_BASE",
        :description  => "\
        // Actual phase number executed is STREAM_CURR_PHASE_BASE_REG_INDEX + STREAM_CURR_PHASE_REG_INDEX
        // When reprogramming this register you must also reprogram STREAM_CURR_PHASE_REG_INDEX and STREAM_REMOTE_SRC_PHASE_REG_INDEX
        ",
        :fields =>  [
        ],
    },
    {
        :index => 245,
        :name => "STREAM_PHASE_AUTO_CFG_PTR_BASE",
        :description  => "\
        // Actual address accessed will be STREAM_PHASE_AUTO_CFG_PTR_BASE_REG_INDEX + STREAM_PHASE_AUTO_CFG_PTR_REG_INDEX
        // When reprogramming this register you must also reprogram STREAM_PHASE_AUTO_CFG_PTR_REG_INDEX
        ",
        :fields =>  [
        ],
    },
    {
        :index => 246,
        :name => "STREAM_BLOB_NEXT_AUTO_CFG_DONE",
        :description  => "\
        // Reading this register will give you a stream id of a stream that finished its blob (according to STREAM_BLOB_AUTO_CFG_DONE_REG_INDEX)
        // Subsequent reads will give you the next stream, untill all streams are read, after which it will loop
        // This register is only valid if BLOB_NEXT_AUTO_CFG_DONE_VALID is set (i.e. if STREAM_BLOB_AUTO_CFG_DONE_REG_INDEX non-zero)
        // Exists only in stream 0
        ",
        :fields =>  [
            { :name => "BLOB_NEXT_AUTO_CFG_DONE_STREAM_ID", :offset => "0", :width => "STREAM_ID_WIDTH" },
            { :name => "BLOB_NEXT_AUTO_CFG_DONE_VALID", :offset => "16", :width => "1" },
        ],
    },
    {
        :index => 247,
        :name => "FIRMWARE_SCRATCH",
        :description  => "\
        // Scratch location for firmware usage
        // Guarantees that no side-effects occur in Overlay hardware
        ",
        :fields =>  [
        ],
    },
    {
        :index => 248,
        :name => "STREAM_SCRATCH",
        :description  => "\
        // Scratch registers
        // Exists only in streams 0-3 and 8-11
        // Data can be stored at [23:0] from STREAM_SCRATCH_REG_INDEX + 0 to STREAM_SCRATCH_REG_INDEX + 5
        // Can be loaded through overlay blobs.
        ",
        :fields =>  [
        ],
    },
    {
        :index => 248,
        :name => "STREAM_SCRATCH_0",
        :description  => "",
        :fields =>  [
            { :name => "NCRISC_TRANS_EN", :offset => "0", :width => "1" },
            { :name => "NCRISC_TRANS_EN_IRQ_ON_BLOB_END", :offset => "(NCRISC_TRANS_EN + NCRISC_TRANS_EN_WIDTH)", :width => "1" },
            { :name => "NCRISC_CMD_ID", :offset => "(NCRISC_TRANS_EN_IRQ_ON_BLOB_END + NCRISC_TRANS_EN_IRQ_ON_BLOB_END_WIDTH)", :width => "3" },
            {
                :name => "NEXT_NRISC_PIC_INT_ON_PHASE", :offset => "(NCRISC_CMD_ID + NCRISC_CMD_ID_WIDTH)", :width => "19",
                :description  => "\
                // Kept for compatibility with grayskull, but doesnt not exist anymore in wormhole
                ",
            },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_1",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_RD_PTR_WORDS_LO", :offset => "0", :width => "24" },
            { :name => "NCRISC_LOOP_COUNT", :offset => "0", :width => "24" },
            { :name => "NCRISC_INIT_ENABLE_BLOB_DONE_IRQ", :offset => "0", :width => "1" },
            { :name => "NCRISC_INIT_DISABLE_BLOB_DONE_IRQ", :offset => "(NCRISC_INIT_ENABLE_BLOB_DONE_IRQ + NCRISC_INIT_ENABLE_BLOB_DONE_IRQ_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_2",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_RD_PTR_WORDS_HI", :offset => "0", :width => "4" },
            { :name => "DRAM_FIFO_WR_PTR_WORDS_LO", :offset => "(DRAM_FIFO_RD_PTR_WORDS_HI + DRAM_FIFO_RD_PTR_WORDS_HI_WIDTH)", :width => "20" },
            { :name => "NCRISC_TOTAL_LOOP_ITER", :offset => "0", :width => "24" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_3",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_WR_PTR_WORDS_HI", :offset => "0", :width => "8" },
            { :name => "DRAM_FIFO_CAPACITY_PTR_WORDS_LO", :offset => "(DRAM_FIFO_WR_PTR_WORDS_HI + DRAM_FIFO_WR_PTR_WORDS_HI_WIDTH)", :width => "16" },
            { :name => "NCRISC_LOOP_INCR", :offset => "0", :width => "16" },
            { :name => "NCRISC_LOOP_BACK_NUM_CFG_REG_WRITES", :offset => "(NCRISC_LOOP_INCR+NCRISC_LOOP_INCR_WIDTH)", :width => "8" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_4",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_CAPACITY_PTR_WORDS_HI", :offset => "0", :width => "12" },
            { :name => "DRAM_FIFO_BASE_ADDR_WORDS_LO", :offset => "(DRAM_FIFO_CAPACITY_PTR_WORDS_HI + DRAM_FIFO_CAPACITY_PTR_WORDS_HI_WIDTH)", :width => "12" },
            { :name => "NCRISC_LOOP_BACK_AUTO_CFG_PTR", :offset => "0", :width => "24" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_5",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_BASE_ADDR_WORDS_HI", :offset => "0", :width => "16" },
            {
                :name => "DRAM_EN_BLOCKING", :offset => "(DRAM_FIFO_BASE_ADDR_WORDS_HI + DRAM_FIFO_BASE_ADDR_WORDS_HI_WIDTH)", :width => "1",
                :description  => "\
                // Processes the read or write operation to completeion without processing other dram streams in the meantime
                ",
            },
            {
                :name => "DRAM_DATA_STRUCTURE_IS_LUT", :offset => "(DRAM_EN_BLOCKING + DRAM_EN_BLOCKING_WIDTH)", :width => "1",
                :description  => "\
                // Fifo structure in dram holds a dram pointer and size that is used as indirection to a tile in dram
                ",
            },
            {
                :name => "DRAM_RESET_RD_PTR_TO_BASE_ON_EMPTY", :offset => "(DRAM_DATA_STRUCTURE_IS_LUT + DRAM_DATA_STRUCTURE_IS_LUT_WIDTH)", :width => "1",
                :description  => "\
                // During a dram read, if its detected that the fifo is empty the ncrisc will reset the read pointer back to base
                // Its expected that there is no host interaction
                ",
            },
            {
                :name => "DRAM_RESET_WR_PTR_TO_BASE_ON_FULL", :offset => "(DRAM_RESET_RD_PTR_TO_BASE_ON_EMPTY + DRAM_RESET_RD_PTR_TO_BASE_ON_EMPTY_WIDTH)", :width => "1",
                :description  => "\
                // During a dram write, if its detected that the fifo is full the ncrisc will reset the write pointer back to base. Old data will be overwritten.
                // Its expected that there is no host interaction
                ",
            },
            {
                :name => "DRAM_NO_PTR_UPDATE_ON_PHASE_END", :offset => "(DRAM_RESET_WR_PTR_TO_BASE_ON_FULL + DRAM_RESET_WR_PTR_TO_BASE_ON_FULL_WIDTH)", :width => "1",
                :description  => "\
                // The internal ncrisc rd/wr pointers will not be updated at phase end
                // Its expected that there is no host interaction
                ",
            },
            {
                :name => "DRAM_WR_BUFFER_FLUSH_AND_RST_PTRS", :offset => "(DRAM_NO_PTR_UPDATE_ON_PHASE_END + DRAM_NO_PTR_UPDATE_ON_PHASE_END_WIDTH)", :width => "1",
                :description  => "\
                // Before ending the phase the ncrisc will wait until the host has emptied the write buffer and then reset the read and write pointers to base
                // This can be used for hosts that do not want to track wrapping
                // The host must be aware of this behaviour for this functionality to work
                ",
            },
            { :name => "NCRISC_LOOP_NEXT_PIC_INT_ON_PHASE", :offset => "0", :width => "20" },
        ],
    },
]

prev_register = nil
registers.each do |register|
    # Process :prev_plus_1 and :same_as_prev
    if register[:index] == :prev_plus_1
        register[:index] = prev_register[:index] + 1
    end
    if register[:index] == :same_as_prev
        register[:index] = prev_register[:index]
    end

    # Add :width_name to fields
    register[:fields].each do |field|
        field[:width_name] = field[:name] + "_WIDTH"
    end

    # Make fields printing pretty (align columns)
    max_len = nil
    register[:fields].each do |field|
        # :width_name will always be larger than :fields, so we dont need to check :fields
        if max_len == nil || max_len < field[:width_name].length
            max_len = field[:width_name].length
        end
    end

    register[:fields].each do |field|
        field[:name] = field[:name].ljust(max_len)
        field[:width_name] = field[:width_name].ljust(max_len)
    end

    # Remove whitespace after newline and last newline in :description
    register[:description] = register[:description].strip
    register[:description] = register[:description].gsub(/\n\s+/, "\n")
    if register[:description] != ""
        register[:description] = register[:description] + "\n"
    end

    register[:fields].each do |field|
        if field[:description]
            field[:description] = field[:description].strip
            field[:description] = field[:description].gsub(/\n\s+/, "\n")
        else
            field[:description] = ""
        end

        if field[:description] != ""
            field[:description] = field[:description] + "\n"
        end
    end

    prev_register = register
end

-%>
<%- if type == :c_header -%>
<%= header -%>

#ifndef NOC_OVERLAY_PARAMETERS_H
#define NOC_OVERLAY_PARAMETERS_H

<%= c_header_basic -%>

<%- registers.each do |register| -%>
<%= register[:description] -%>
#define   <%= register[:name].upcase %>_REG_INDEX   <%= register[:index] %>
<%- register[:fields].each do |field| -%>
<%= field[:description] -%>
#define       <%= field[:name].upcase %> <%= field[:offset] %>
#define       <%= field[:width_name].upcase %>   <%= field[:width] %>
<%- end -%>

<%- end -%>
#endif // def NOC_OVERLAY_PARAMETERS_H

<%- elsif type == :cpp_header -%>
<%= header -%>

#pragma once

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>
#include <stdexcept>

<%= c_header_basic -%>

namespace Noc {

typedef struct OverlayField_ {
    std::string name;
    std::uint32_t offset;
    std::uint32_t width;
    std::string description;
} OverlayField;

typedef struct OverlayReg_ {
    std::string name;
    std::uint32_t index;
    std::unordered_map<std::string, std::uint32_t> fields_by_name;
    std::unordered_map<std::uint32_t, std::uint32_t> fields_by_offset;
    std::vector<OverlayField> fields;
    std::string description;
} OverlayReg;

// OverLayParams
class OLP {
    private:
        static const std::unordered_map<std::string, std::uint32_t> registers_by_name;
        static const std::unordered_map<std::uint32_t, std::uint32_t> registers_by_index;
        static const std::vector<OverlayReg> registers;
        static const std::unordered_map<std::string, std::uint32_t> fields_by_name;
        static const std::vector<OverlayField> fields;

    private:
        // Disallow creating an instance of this object
        OLP() {}

    public:
        static bool HasReg(std::string label)
        {
            return registers_by_name.count(label) >= 1;
        }

        // There might be multiple registers with the same index
        // If so a register you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static bool HasReg(std::uint32_t index)
        {
            return registers_by_index.count(index) >= 1;
        }

        static const std::vector<OverlayReg>& GetAllRegs()
        {
            return registers;
        }

        // There might be multiple registers with the same index
        // If so a register you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static std::string RegName(std::uint32_t index)
        {
            if (HasReg(index))
                return registers[registers_by_index.at(index)].name;
            else
                throw std::runtime_error("Non-existant overlay register index: " + std::to_string(index));
        }

        static std::uint32_t RegIdx(std::string label)
        {
            if (HasReg(label))
                return registers[registers_by_name.at(label)].index;
            else
                throw std::runtime_error("Non-existant overlay register: " + std::string(label));
        }

        static std::string RegInfo(std::string label)
        {
            if (HasReg(label))
                return registers[registers_by_name.at(label)].description;
            else
                throw std::runtime_error("Non-existant overlay register: " + std::string(label));
        }

        ////////////////////////////////////

        static bool HasFld(std::string label)
        {
            return fields_by_name.count(label) >= 1;
        }

        static const std::vector<OverlayField>& GetAllFlds()
        {
            return fields;
        }

        static std::uint32_t FldOff(std::string label)
        {
            if (HasFld(label))
                return fields[fields_by_name.at(label)].offset;
            else
                throw std::runtime_error("Non-existant overlay field: " + std::string(label));
        }

        static std::uint32_t FldW(std::string label)
        {
            if (HasFld(label))
                return fields[fields_by_name.at(label)].width;
            else
                throw std::runtime_error("Non-existant overlay field: " + std::string(label));
        }

        static std::string FldInfo(std::string label)
        {
            if (HasFld(label))
                return fields[fields_by_name.at(label)].description;
            else
                throw std::runtime_error("Non-existant overlay field: " + std::string(label));
        }

        ////////////////////////////////////

        static bool HasFld(std::string reg_label, std::string field_label)
        {
            return HasReg(reg_label) &&
                   (registers[registers_by_name.at(reg_label)].fields_by_name.count(field_label) >= 1);
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static bool HasFld(std::uint32_t reg_index, std::uint32_t field_offset)
        {
            return HasReg(reg_index) &&
                   (registers[registers_by_index.at(reg_index)].fields_by_offset.count(field_offset) >= 1);
        }

        static const std::vector<OverlayField>& GetAllFlds(std::string reg_label)
        {
            if (HasReg(reg_label)) {
                return registers[registers_by_name.at(reg_label)].fields;
            } else {
                throw std::runtime_error("Non-existant overlay register: " + std::string(reg_label));
            }
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static const std::vector<OverlayField>& GetAllFlds(std::uint32_t reg_index)
        {
            if (HasReg(reg_index)) {
                return registers[registers_by_index.at(reg_index)].fields;
            } else {
                throw std::runtime_error("Non-existant overlay register index: " + std::to_string(reg_index));
            }
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static std::string FldName(std::uint32_t reg_index, std::uint32_t field_offset)
        {
            if (HasFld(reg_index, field_offset)) {
                auto field_tmp = registers[registers_by_index.at(reg_index)].fields;
                auto index_field_temp = registers[registers_by_index.at(reg_index)].fields_by_offset.at(field_offset);
                return field_tmp[index_field_temp].name;
            } else {
                throw std::runtime_error("Non-existant overlay register field (index, offset): " + std::to_string(reg_index) + ", " + std::to_string(field_offset));
            }
        }

        static std::uint32_t FldOff(std::string reg_label, std::string field_label)
        {
            if (HasFld(reg_label, field_label)) {
                auto field_tmp = registers[registers_by_name.at(reg_label)].fields;
                auto index_field_temp = registers[registers_by_name.at(reg_label)].fields_by_name.at(field_label);
                return field_tmp[index_field_temp].offset;
            } else {
                throw std::runtime_error("Non-existant overlay register field: " + std::string(reg_label) + ", " + std::string(field_label));
            }
        }

        static std::uint32_t FldW(std::string reg_label, std::string field_label)
        {
            if (HasFld(reg_label, field_label)) {
                auto field_tmp = registers[registers_by_name.at(reg_label)].fields;
                auto index_field_temp = registers[registers_by_name.at(reg_label)].fields_by_name.at(field_label);
                return field_tmp[index_field_temp].width;
            } else {
                throw std::runtime_error("Non-existant overlay register field: " + std::string(reg_label) + ", " + std::string(field_label));
            }
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static std::uint32_t FldW(std::uint32_t reg_index, std::uint32_t field_offset)
        {
            if (HasFld(reg_index, field_offset)) {
                auto field_tmp = registers[registers_by_index.at(reg_index)].fields;
                auto index_field_temp = registers[registers_by_index.at(reg_index)].fields_by_offset.at(field_offset);
                return field_tmp[index_field_temp].width;
            } else {
                throw std::runtime_error("Non-existant overlay register field (index, offset): " + std::to_string(reg_index) + ", " + std::to_string(field_offset));
            }
        }

        static std::string FldInfo(std::string reg_label, std::string field_label)
        {
            if (HasFld(reg_label, field_label)) {
                auto field_tmp = registers[registers_by_name.at(reg_label)].fields;
                auto index_field_temp = registers[registers_by_name.at(reg_label)].fields_by_name.at(field_label);
                return field_tmp[index_field_temp].description;
            } else {
                throw std::runtime_error("Non-existant overlay register field: " + std::string(reg_label) + ", " + std::string(field_label));
            }
        }

};

const std::vector<OverlayReg> OLP::registers = {
<%- first_line_placed_outer = false -%>
<%- registers.each_with_index do |register, index| -%>
    <% if first_line_placed_outer -%>,<%- end -%>{
        "<%= register[:name].upcase.strip %>",
        <%= register[:index] %>,
        {
<%- first_line_placed = false -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
            <% if first_line_placed -%>,<%- end -%>{"<%= field[:name].upcase.strip %>", <%= field_index %>}
<%- first_line_placed = true -%>
<%- end -%>
        },
        {
<%- index_exists = {} -%>
<%- first_line_placed = false -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
<%- if !index_exists[field[:offset]] -%>
            <% if first_line_placed -%>,<%- end -%>{<%= field[:offset] %>, <%= field_index %>}
<%- first_line_placed = true -%>
<%- index_exists[field[:offset]] = true -%>
<%- end -%>
<%- end -%>
        },
        {
<%- first_line_placed = false -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
            <% if first_line_placed -%>,<%- end -%>{
                "<%= field[:name].upcase.strip %>",
                <%= field[:offset] %>,
                <%= field[:width] %>,
                "<%= field[:description].gsub(/\n/, '\\n') %>"
            }
<%- first_line_placed = true -%>
<%- end -%>
        },
        "<%= register[:description].gsub(/\n/, '\\n') %>"
    }
<%- first_line_placed_outer = true -%>
<%- end -%>
};

const std::unordered_map<std::string, std::uint32_t> OLP::registers_by_name = {
<%- first_line_placed = false -%>
<%- registers.each_with_index do |register, index| -%>
    <% if first_line_placed -%>,<%- end -%>{"<%= register[:name].upcase.strip %>", <%= index %>}
<%- first_line_placed = true -%>
<%- end -%>
};

const std::unordered_map<std::uint32_t, std::uint32_t> OLP::registers_by_index = {
<%- index_exists = {} -%>
<%- first_line_placed = false -%>
<%- registers.each_with_index do |register, index| -%>
<%- if !index_exists[register[:index]] -%>
    <% if first_line_placed -%>,<%- end -%>{<%= register[:index] %>, <%= index %>}
<%- first_line_placed = true -%>
<%- index_exists[register[:index]] = true -%>
<%- end -%>
<%- end -%>
};

const std::vector<OverlayField> OLP::fields = {
<%- first_line_placed = false -%>
<%- registers.each_with_index do |register, index| -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
    <% if first_line_placed -%>,<%- end -%>{
        "<%= field[:name].upcase.strip %>",
        <%= field[:offset] %>,
        <%= field[:width] %>,
        "<%= field[:description].gsub(/\n/, '\\n') %>"
    }
<%- first_line_placed = true -%>
<%- end -%>
<%- end -%>
};

const std::unordered_map<std::string, std::uint32_t> OLP::fields_by_name = {
<%- first_line_placed = false -%>
<%- unrolled_index = 0 -%>
<%- registers.each_with_index do |register, index| -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
    <% if first_line_placed -%>,<%- end -%>{"<%= field[:name].upcase.strip %>", <%= unrolled_index %>}
<%- unrolled_index = unrolled_index + 1 -%>
<%- first_line_placed = true -%>
<%- end -%>
<%- end -%>
};

}

<%- elsif type == :sed -%>

<%- registers.each_with_index do |register, index| -%>
find . -type f | xargs grep -sl <%= register[:name].upcase.strip %>_REG_INDEX | xargs sed -i 's/\(^\|[^a-zA-Z_]\)<%= register[:name].upcase.strip %>_REG_INDEX\($\|[^a-zA-Z0-9_]\)/\1OLP::RegIdx("<%= register[:name].upcase.strip %>")\2/g'
<%- register[:fields].each_with_index do |field, field_index| -%>
find . -type f | xargs grep -sl <%= field[:name].upcase.strip %> | xargs sed -i 's/\(^\|[^a-zA-Z_]\)<%= field[:name].upcase.strip %>\($\|[^a-zA-Z0-9_]\)/\1OLP::FldOff("<%= field[:name].upcase.strip %>")\2/g'
find . -type f | xargs grep -sl <%= field[:width_name].upcase.strip %> | xargs sed -i 's/\(^\|[^a-zA-Z_]\)<%= field[:width_name].upcase.strip %>\($\|[^a-zA-Z0-9_]\)/\1OLP::FldW("<%= field[:name].upcase.strip %>")\2/g'
<%- end -%>
<%- end -%>

find . -type f | xargs grep -sl WRITE_FIELD | xargs sed -i 's/WRITE_FIELD\(\s*\)(\(\s*\)OLP::RegIdx("\([a-zA-Z0-9_]*\)")\(\s*\),\(\s*\)OLP::FldOff("\([a-zA-Z0-9_]*\)")/WRITE_FIELD\1(\2"\3"\4,\5"\6"/g'
find . -type f | xargs grep -sl READ_FIELD | xargs sed -i 's/READ_FIELD\(\s*\)(\(\s*\)OLP::RegIdx("\([a-zA-Z0-9_]*\)")\(\s*\),\(\s*\)OLP::FldOff("\([a-zA-Z0-9_]*\)")/READ_FIELD\1(\2"\3"\4,\5"\6"/g'
find . -type f | xargs grep -sl COPY_FIELD | xargs sed -i 's/COPY_FIELD\(\s*\)(\(\s*\)OLP::RegIdx("\([a-zA-Z0-9_]*\)")\(\s*\),\(\s*\)OLP::FldOff("\([a-zA-Z0-9_]*\)")/COPY_FIELD\1(\2"\3"\4,\5"\6"/g'

<%- end -%>

// Define schema for tracing host API calls, called Commands in this context.
include "flatbuffer/buffer_types.fbs";
include "flatbuffer/program_types.fbs";
include "flatbuffer/base_types.fbs";

namespace tt.tt_metal.flatbuffer;

//TODO: (jjiang) - in tt-metal/tt_metal/impl/lightmetal/lightmetal_replay_impl.cpp,
//TODO: add this to the global_id list and make it return a traceId object in lightmetal_capture.cpp
//TODO: add the capture in lightmetal_capture.cpp
table BeginTraceCaptureCommand {
  mesh_device_id: int;  // Reference to IDevice of type MeshDevice
  mesh_cq_global_id: uint32; // Reference to MeshCommandQueue of IDevice
}

//TODO: (jjiang) - in tt-metal/tt_metal/impl/lightmetal/lightmetal_replay_impl.cpp,
//TODO: remove the traceid from the global_id list and make it take a traceId object in lightmetal_cpature.cpp and act accordingly
//TODO: add the capture in lightmetal_capture.cpp
table EndTraceCaptureCommand {
  mesh_device_id: int;  // Reference to IDevice of type MeshDevice
  mesh_cq_global_id: uint32; // Reference to MeshCommandQueue of IDevice
  trace_id: uint32;
}

table ReplayTraceCommand {
  device_id: int;  // Reference to IDevice
  cq_id: int; // Can be regular cq or mesh cq
  tid: int;
  blocking: bool;
}

table EnqueueTraceCommand {
  // TODO (kmabee) - add device.
  cq_id: int;
  tid: int;
  blocking: bool;
}

table LoadTraceCommand {
  tid: int; // Pointer to trace data.
  cq_id: int;
}

table ReleaseTraceCommand {
  mesh_device_id: int;  // Reference to IDevice
  tid: int; // Pointer to trace data.
}

table BufferCreateCommand {
  global_id: uint32;
  device_id: int; // Reference to IDevice *device;
  address: Uint32Optional; // Optional for pre-allocated buffers.
  size: int;
  page_size: int;
  buffer_type: BufferType;
  buffer_layout: TensorMemoryLayout;
  shard_parameters: ShardSpecBuffer;
  bottom_up: BoolOptional;
  sub_device_id: Uint8Optional;
}

table BufferDeallocateCommand {
  global_id: uint32;   // Reference to Buffer to be deallocated
}

table BufferDeleteCommand {
  global_id: uint32;   // Reference to Buffer to be deleted
}

table EnqueueWriteBufferCommand {
  cq_global_id: uint32;       // reference to CommandQueue
  buffer_global_id: uint32;   // Reference to Buffer used as destination
  src: [uint32];              // Data to be written. Support only some types for now.
  blocking: bool;
}

table EnqueueReadBufferCommand {
  cq_global_id: uint32;       // reference to CommandQueue
  buffer_global_id: uint32;   // Reference to Buffer used as source
  blocking: bool;
}

//TODO START NEW (jjiang): Interim constructs, potentially will be changed as they're implemented
//basically none of these have been added to capture.cpp or replay_impl.cpp yet, but the
//translation tables necessary for tracking have been added to
table MeshBufferCreateCommand {
  mesh_buffer_config: MeshBufferConfig;
  device_local_config: DeviceLocalBufferConfig;
  mesh_device_id: int; // Reference to IDevice of type MeshDevice *mesh_device;
  address: uint64; //std::optional<DeviceAddr>
}

table MeshWorkloadCreateCommand {
}

table AddProgramToMeshWorkloadCommand {
  mesh_workload_global_id: uint32; // Reference to MeshWorkload
  program_global_id: uint32; // Reference to Program TODO: requires std::move(program) in orig, reference to a reference
  device_range : MeshCoordinateRange;
}

table EnqueueMeshWorkloadCommand {
  mesh_cq_id: uint32; // reference to MeshCommandQueue
  mesh_workload_global_id: uint32; // Reference to MeshWorkload
  blocking: bool;
}

//TODO: (jjiang) - this is just a data structure, offsets need to be calculated and it probably needs to be
//hand serialized like the existing data structures; should be similar though
table MeshEvent {
  id: uint32 = 0;
  mesh_device_id: int; // Reference to IDevice of type MeshDevice *mesh_device;
  mesh_cq_id: uint32 = 0;
  device_range: MeshCoordinateRange;
}

table EnqueueRecordEventCommand {
  mesh_cq_id: uint32;       // reference to MeshCommandQueue
  sub_device_ids: [ubyte];    // array of uint8 values representing SubDeviceId::Id
  device_range: MeshCoordinateRange;
}

table EnqueueRecordEventToHostCommand {
  mesh_cq_id: uint32;       // reference to MeshCommandQueue
  sub_device_ids: [ubyte];    // array of uint8 values representing SubDeviceId::Id
  device_range: MeshCoordinateRange;
}

table EnqueueWaitForEventCommand {
  cq_global_id: uint32;       // reference to MeshCommandQueue
  event: MeshEvent;
}

table EventSynchronizeCommand {
  event: MeshEvent;
}

table SynchronizeCommand {
  mesh_device_id: int;  // Reference to IDevice
  cq_global_id: uint32; // reference to CommandQueue
  sub_device_ids: [ubyte];
}

table EnqueueReadMeshBufferCommand {
  cq_global_id: uint32; // reference to CommandQueue of type MeshCommandQueue
  dst: [uint32];  // Data to be written. Support only some types for now.
  mesh_buffer_global_id: uint32; // Reference to MeshBuffer used as src
  blocking: bool = true;
}

table EnqueueWriteMeshBufferCommand {
  cq_global_id: uint32; // reference to CommandQueue of type MeshCommandQueue
  mesh_buffer_global_id: uint32; // Reference to MeshBuffer used as dest
  src: [uint32];  // Data to be written. Support only some types for now.
  blocking: bool = false;
}

table ReadShardCommand {
  cq_global_id: uint32; // reference to CommandQueue of type MeshCommandQueue
  dst: [uint32];  // Data to be written. Support only some types for now.
  mesh_buffer_global_id: uint32; // Reference to MeshBuffer used as src
  coord: MeshCoordinate;
  blocking: bool = true;
}

table WriteShardCommand {
  cq_global_id: uint32; // reference to CommandQueue of type MeshCommandQueue
  mesh_buffer_global_id: uint32; // Reference to MeshBuffer used as dest
  src: [uint32];  // Data to be written. Support only some types for now.
  coord: MeshCoordinate;
  blocking: bool = false;
}
//TODO END (jjiang)

table FinishCommand {
  cq_global_id: uint32;       // reference to CommandQueue or MeshCommandQueue
  sub_device_ids: [ubyte];    // array of uint8 values representing SubDeviceId::Id
}

table ProgramConstructorCommand {
  global_id: uint32;
}

table EnqueueProgramCommand {
  cq_global_id: uint32;       // reference to CommandQueue
  program_global_id: uint32;  // Reference to Program
  blocking: bool;
}

table CreateKernelCommand {
  global_id: uint32;          // Reference to Kernel
  program_global_id: uint32;  // Reference to Program
  file_name: string;          // Later replace with src, then binary
  core_spec: CoreSpec;
  kernel_config: KernelConfig;
}

table SetRuntimeArgsUint32Command {
  program_global_id: uint32;  // Reference to Program
  kernel_global_id: uint32;   // Reference to Kernel
  core_spec: CoreSpec;
  args: [uint32];             // Arguments to be passed to kernel
}

table SetRuntimeArgsUint32VecPerCoreCommand {
  program_global_id: uint32;  // Reference to Program
  kernel_global_id: uint32;   // Reference to Kernel
  core_spec: [CoreCoord];
  args: [UInt32Vector];       // vector of vector of uint32_t
}

table SetRuntimeArgsCommand {
  kernel_global_id: uint32;   // Reference to Kernel
  core_spec: CoreSpec;
  args: [RuntimeArg];         // Arguments to be passed to kernel
}

table CreateCircularBufferCommand {
  global_id: uint32;          // Reference to CBHandle
  program_global_id: uint32;  // Reference to Program
  core_spec: CoreSpec;
  config: CircularBufferConfig;
}

table LightMetalCompareCommand {
  cq_global_id: uint32;       // reference to CommandQueue
  buffer_global_id: uint32;   // Reference to Buffer used as destination
  golden_data: [uint32];      // Golden data to compare against at replay
  is_user_data: bool;         // Informational, denote if golden data is from user or capture
}

union CommandType {
  BeginTraceCaptureCommand,
  EndTraceCaptureCommand,
  ReplayTraceCommand,
  EnqueueTraceCommand,
  LoadTraceCommand,
  ReleaseTraceCommand,
  EnqueueRecordEventCommand,
  EnqueueRecordEventToHostCommand,
  EnqueueWaitForEventCommand,
  EventSynchronizeCommand,
  SynchronizeCommand,
  BufferCreateCommand,
  BufferDeallocateCommand,
  BufferDeleteCommand,
  EnqueueWriteBufferCommand,
  EnqueueReadBufferCommand,
  MeshBufferCreateCommand,
  MeshWorkloadCreateCommand,
  AddProgramToMeshWorkloadCommand,
  EnqueueMeshWorkloadCommand,
  EnqueueReadMeshBufferCommand,
  EnqueueWriteMeshBufferCommand,
  ReadShardCommand,
  WriteShardCommand,
  FinishCommand,
  ProgramConstructorCommand,
  EnqueueProgramCommand,
  CreateKernelCommand,
  SetRuntimeArgsUint32Command,
  SetRuntimeArgsUint32VecPerCoreCommand,
  SetRuntimeArgsCommand,
  CreateCircularBufferCommand,
  LightMetalCompareCommand,
}

table Command {
    cmd: CommandType;
}

include "flatbuffer/base_types.fbs";
include "flatbuffer/program_types.fbs"; // For CoreRangeSet

namespace tt.tt_metal.flatbuffer;

enum BufferType: ushort {
  DRAM = 0,
  L1 = 1,
  SystemMemory = 2,
  L1Small = 3,
  Trace = 4,
}

enum TensorMemoryLayout: ushort {
  Interleaved = 0,
  SingleBank = 1,
  HeightSharded = 2,
  WidthSharded = 3,
  BlockSharded = 4,
}

enum ShardOrientation : ubyte {
    RowMajor = 0,
    ColMajor = 1,
}

enum ShardMode : ubyte {
    Physical,
    Logical,
}

table ShardShape {
    height: uint32;
    width: uint32;
}

table ShardSpec {
    grid: CoreRangeSet;
    shape_h: uint32;
    shape_w: uint32;
    orientation: ShardOrientation;
    shard_mode: ShardMode;
    physical_shard_shape: ShardShape;
}

table ShardSpecBuffer {
  tensor_shard_spec: ShardSpec;
  page_shape_h: uint32;
  page_shape_w: uint32;
  tensor2d_shape_in_pages_h: uint32;
  tensor2d_shape_in_pages_w: uint32;
}

table ShardedBufferConfig {
    // Note: Only 2D sharding and replication is supported by the APIs exposed through this struct.
    // This interface will likely change over time depending on the status of native ND sharding.
    // Global buffer size. Each device will get a fraction of this size.
    global_size: uint64 = 0;

    global_shape_h: uint32;
    global_shape_w: uint32;

    shard_shape_h: uint32;
    shard_shape_w: uint32;

    // Orientation of the shards in a mesh.
    shard_orientation: ShardOrientation = RowMajor;

//TODO: (jjiang) - these probably need to be implemented in lightmetal_capture as helpers along with all the other buffer stuff
//uint32_t ShardedBufferConfig::compute_datum_size_bytes() const {
//    return global_size / (global_buffer_shape.height() * global_buffer_shape.width());
//}

//std::pair<bool, bool> ShardedBufferConfig::replicated_dims() const {
//    return {shard_shape.height() == 0, shard_shape.width() == 0};
//}

//Shape2D ShardedBufferConfig::physical_shard_shape() const {
//    const auto [shard_height, shard_width] = shard_shape;
//    const auto [global_height, global_width] = global_buffer_shape;
//    return Shape2D(shard_height == 0 ? global_height : shard_height, shard_width == 0 ? global_width : shard_width);
//}
}

//jjiang:
//TODO: createmeshbuffer in lightmetal_capture.cpp
//TODO: delete  DeviceAddr page_size = 0 field?
table DeviceLocalBufferConfig {
    page_size: uint64 = 0;

    buffer_type: BufferType = DRAM;

    buffer_layout: TensorMemoryLayout = Interleaved;

    // Must be set for sharded buffer layouts.
    shard_parameters: ShardSpecBuffer;

    // The direction in which memory for this buffer is allocated.
    bottom_up: BoolOptional;
}
//TODO: (jjiang) - createmeshbuffer in lightmetal_capture.cpp
struct ReplicatedBufferConfig {
    size: uint64 = 0;
}
//TODO: (jjiang) - createmeshbuffer in lightmetal_capture.cpp
union MeshBufferConfig {
  ShardedBufferConfig,
  ReplicatedBufferConfig
}

struct CBConfigPageSize {
  index: uint32;  // The index in the array
  size: uint32;   // The page-size value for this index
}

struct CBConfigDataFormat {
  index: uint32;  // The index in the array
  format: DataFormat; // The data format for this index
}


struct CBConfigTile {
  index: uint32;  // The index in the array
  tile: Tile;     // The tile for this index
}

table CircularBufferConfig {
  total_size: uint32;
  globally_allocated_address: Uint32Optional;
  data_formats: [CBConfigDataFormat]; // Mimic optional array in C++ by using KV map.
  page_sizes: [CBConfigPageSize];     // Mimic optional array in C++ by using KV map.
  tiles: [CBConfigTile];              // Mimic optional array in C++ by using KV map.
  shadow_buf_global_id: Uint32Optional;
  buffer_indices: [uint8];
  local_buffer_indices: [uint8];
  remote_buffer_indices: [uint8];
  dynamic_cb: bool;
  max_size: uint32;
  buffer_size: uint32;
}

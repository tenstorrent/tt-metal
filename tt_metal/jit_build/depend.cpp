// SPDX-FileCopyrightText: Â© 2025 Tenstorrent AI ULC
//
// SPDX-License-Identifier: Apache-2.0

#include "depend.hpp"
#include "jit_build_utils.hpp"

#include <cstddef>
#include <filesystem>
#include <fstream>
#include <istream>
#include <iterator>
#include <tt-logger/tt-logger.hpp>

namespace tt::jit_build {

// Parses a Makefile-style dependency file (generated by gcc -MMD)
// dep_file = { target ':' { dep } { '\' '\n' { dep } } '\n' }
ParsedDependencies parse_dependency_file(std::istream& file) {
    ParsedDependencies dependencies;
    enum class ParseState { Target, Dependencies };
    ParseState state = ParseState::Target;
    std::string line;
    std::vector<std::string>* current_deps = nullptr;
    while (std::getline(file, line)) {
        size_t pos = 0;
        while ((pos = line.find_first_not_of(" \t", pos)) != std::string::npos) {
            switch (state) {
                case ParseState::Target: {
                    size_t next_pos = line.find(':');
                    if (next_pos == std::string::npos) {
                        log_error(tt::LogBuildKernels, "Failed to parse dependency file.");
                        return {};
                    }
                    current_deps = &dependencies[line.substr(pos, next_pos - pos)];
                    pos = next_pos + 1;  // Skip ':'
                    state = ParseState::Dependencies;
                    break;
                }
                case ParseState::Dependencies: {
                    size_t next_pos = line.find_first_of(" \t", pos);
                    if (next_pos == std::string::npos) {
                        auto dep_name = line.substr(pos);
                        if (dep_name != "\\") {
                            // Line ends without continuation
                            current_deps->push_back(std::move(dep_name));
                            state = ParseState::Target;
                        }
                    } else {
                        current_deps->push_back(line.substr(pos, next_pos - pos));
                    }
                    pos = next_pos;
                    break;
                }
            }
        }
    }

    return dependencies;
}

namespace {

uint64_t hash_file_content(std::istream& file) {
    utils::FNV1a hasher;
    hasher.update(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
    return hasher.digest();
}

// Get the base directory for making paths relocatable (CCACHE_BASEDIR if set)
std::filesystem::path get_base_dir() {
    if (const char* basedir = std::getenv("CCACHE_BASEDIR")) {
        std::filesystem::path base(basedir);
        if (!base.empty() && std::filesystem::exists(base)) {
            return base;
        }
    }
    return std::filesystem::path{};
}

// Make path relative to base_dir if it's under base_dir, otherwise return absolute path
std::filesystem::path make_relocatable_path(const std::filesystem::path& path, const std::filesystem::path& base_dir) {
    if (base_dir.empty()) {
        return path;
    }
    std::error_code ec;
    auto rel_path = std::filesystem::relative(path, base_dir, ec);
    if (!ec && !rel_path.empty() && rel_path.string().find("..") != 0) {
        // Successfully made relative and it's under base_dir (doesn't start with ..)
        return rel_path;
    }
    return path;  // Fall back to absolute if it's outside base_dir
}

// Resolve a potentially relative path against base_dir, falling back to absolute
std::filesystem::path resolve_relocatable_path(
    const std::filesystem::path& path, const std::filesystem::path& base_dir) {
    if (path.is_absolute()) {
        return path;
    }
    if (!base_dir.empty()) {
        std::filesystem::path resolved = base_dir / path;
        if (std::filesystem::exists(resolved)) {
            return resolved;
        }
    }
    return path;
}

}  // namespace

void write_dependency_hashes(
    const ParsedDependencies& dependencies,
    const std::string& out_dir,
    const std::string& obj,
    std::ostream& hash_file) {
    auto iter = dependencies.find(obj);
    if (iter == dependencies.end()) {
        log_warning(tt::LogBuildKernels, "Cannot cache JIT build, no dependencies found for {}.", obj);
        hash_file.setstate(std::ios::badbit);
        return;
    }

    auto base_dir = get_base_dir();

    for (const auto& dep : iter->second) {
        // Need to handle two cases:
        // 1. file is an absolute path
        // 2. file is a path relative to out_dir
        std::filesystem::path dep_path(dep);
        if (dep_path.is_relative()) {
            dep_path = out_dir / dep_path;
        }

        // Normalize to absolute path
        std::error_code ec;
        dep_path = std::filesystem::canonical(dep_path, ec);
        if (ec) {
            // If canonical fails, try weakly_canonical or just use the path as-is
            dep_path = std::filesystem::weakly_canonical(dep_path);
        }

        std::ifstream dep_file(dep_path, std::ios::binary);
        auto hash = hash_file_content(dep_file);
        if (dep_file.fail() && !dep_file.eof()) {
            log_warning(tt::LogBuildKernels, "Cannot cache JIT build because {} cannot be read.", dep);
            hash_file.setstate(std::ios::badbit);
            return;
        }

        // Store path relative to CCACHE_BASEDIR to make cache relocatable across workspaces
        auto relocatable_path = make_relocatable_path(dep_path, base_dir);
        hash_file << relocatable_path.string() << '\t' << hash << '\n';
    }
}

void write_dependency_hashes(const std::string& out_dir, const std::string& obj, const std::string& hash_path) {
    std::filesystem::path obj_path = obj;
    if (obj_path.is_relative()) {
        obj_path = out_dir / obj_path;
    }
    std::filesystem::path dep_path = obj_path;
    dep_path.replace_extension(".d");
    std::ofstream hash_file(hash_path);
    if (!hash_file.is_open()) {
        log_warning(tt::LogBuildKernels, "Cannot cache JIT build, failed to open {} for writing.", hash_path);
        return;
    }
    std::ifstream dep_file(dep_path);
    if (!dep_file.is_open()) {
        log_warning(tt::LogBuildKernels, "Cannot cache JIT build, failed to open {} for reading.", dep_path.string());
        hash_file.setstate(std::ios::badbit);
    } else {
        auto dependencies = parse_dependency_file(dep_file);
        write_dependency_hashes(dependencies, out_dir, obj, hash_file);
    }
    hash_file.close();
    if (hash_file.fail()) {
        // Don't leave incomplete hash file
        std::filesystem::remove(hash_path);
    }
}

bool dependencies_up_to_date(std::istream& hash_file) {
    size_t count = 0;
    auto base_dir = get_base_dir();

    std::string dep_str;
    while (hash_file >> dep_str) {
        uint64_t recorded_hash{};
        hash_file >> recorded_hash;
        if (hash_file.fail()) {
            log_warning(tt::LogBuildKernels, "Cannot use JIT build cache because dependency hash file is malformed.");
            return false;
        }

        // Resolve path: if relative, try against CCACHE_BASEDIR; otherwise use as-is
        std::filesystem::path dep(dep_str);
        std::filesystem::path resolved_dep = resolve_relocatable_path(dep, base_dir);

        std::ifstream dep_file(resolved_dep, std::ios::binary);
        if (!dep_file.is_open()) {
            // It is a valid case that a dependency file no longer exists, for example a header file is no longer used.
            log_debug(
                tt::LogBuildKernels,
                "Need to JIT build because file {} no longer exists (resolved from {}).",
                resolved_dep.string(),
                dep_str);
            return false;
        }
        auto dep_hash = hash_file_content(dep_file);
        if (dep_hash != recorded_hash) {
            log_debug(
                tt::LogBuildKernels,
                "Need to JIT build because file {} has changed.  Old hash: {} new hash: {}",
                resolved_dep.string(),
                recorded_hash,
                dep_hash);
            return false;
        }
        ++count;
    }
    if (!hash_file.eof()) {
        log_warning(tt::LogBuildKernels, "Cannot use JIT build cache because dependency hash file is malformed.");
        return false;
    }
    // "No dependencies" means "always rebuild".  This shouldn't happen with a properly generated dependency file.
    return count > 0;
}

bool dependencies_up_to_date(const std::string& out_dir, const std::string& obj) {
    std::filesystem::path hash_path = std::filesystem::path(out_dir) / (obj + ".dephash");
    std::ifstream hash_file(hash_path);
    if (!hash_file.is_open()) {
        log_debug(tt::LogBuildKernels, "Dependency hash file {} does not exist.", hash_path.string());
        return false;
    }
    return dependencies_up_to_date(hash_file);
}

}  // namespace tt::jit_build

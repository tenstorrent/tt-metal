// SPDX-FileCopyrightText: Â© 2025 Tenstorrent AI ULC
//
// SPDX-License-Identifier: Apache-2.0

#include "depend.hpp"
#include "jit_build_utils.hpp"

#include <cstddef>
#include <filesystem>
#include <fstream>
#include <istream>
#include <iterator>
#include <tt-logger/tt-logger.hpp>

namespace tt::jit_build {

// Parses a Makefile-style dependency file (generated by gcc -MMD)
// dep_file = { target ':' { dep } { '\' '\n' { dep } } '\n' }
ParsedDependencies parse_dependency_file(std::istream& file) {
    ParsedDependencies dependencies;
    enum class ParseState { Target, Dependencies };
    ParseState state = ParseState::Target;
    std::string line;
    std::vector<std::string>* current_deps = nullptr;
    while (std::getline(file, line)) {
        size_t pos = 0;
        while ((pos = line.find_first_not_of(" \t", pos)) != std::string::npos) {
            switch (state) {
                case ParseState::Target: {
                    size_t next_pos = line.find(':');
                    if (next_pos == std::string::npos) {
                        log_error(tt::LogBuildKernels, "Failed to parse dependency file.");
                        return {};
                    }
                    current_deps = &dependencies[line.substr(pos, next_pos)];
                    pos = next_pos + 1;  // Skip ':'
                    state = ParseState::Dependencies;
                    break;
                }
                case ParseState::Dependencies: {
                    size_t next_pos = line.find_first_of(" \t", pos);
                    if (next_pos == std::string::npos) {
                        auto dep_name = line.substr(pos);
                        if (dep_name != "\\") {
                            // Line ends without continuation
                            current_deps->push_back(std::move(dep_name));
                            state = ParseState::Target;
                        }
                    } else {
                        current_deps->push_back(line.substr(pos, next_pos - pos));
                    }
                    pos = next_pos;
                    break;
                }
            }
        }
    }

    return dependencies;
}

namespace {

uint64_t hash_file_content(std::istream& file) {
    utils::FNV1a hasher;
    hasher.update(std::istream_iterator<char>(file), std::istream_iterator<char>());
    return hasher.digest();
}

}  // namespace

void write_dependency_hashes(
    const ParsedDependencies& dependencies,
    const std::string& out_dir,
    const std::string& obj,
    std::ostream& hash_file) {
    auto iter = dependencies.find(obj);
    if (iter == dependencies.end()) {
        log_warning(tt::LogBuildKernels, "Cannot cache JIT build, no dependencies found for {}.", obj);
        hash_file.setstate(std::ios::badbit);
        return;
    }
    for (const auto& dep : iter->second) {
        // Need to handle two cases:
        // 1. file is an absolute path
        // 2. file is a path relative to out_dir
        std::filesystem::path dep_path(dep);
        if (dep_path.is_relative()) {
            dep_path = out_dir / dep_path;
        }
        std::ifstream dep_file(dep_path, std::ios::binary);
        auto hash = hash_file_content(dep_file);
        if (dep_file.fail() && !dep_file.eof()) {
            log_warning(tt::LogBuildKernels, "Cannot cache JIT build because {} cannot be read.", dep);
            hash_file.setstate(std::ios::badbit);
            return;
        }
        // Always write absolute path to the hash file, so when reading back we don't need to
        // worry about relative paths
        hash_file << dep_path << '\t' << hash << '\n';
    }
}

void write_dependency_hashes(const std::string& out_dir, const std::string& obj) {
    std::filesystem::path obj_path = std::filesystem::path(out_dir) / obj;
    std::filesystem::path dep_path = obj_path.replace_extension(".d");
    std::filesystem::path hash_path = obj_path.replace_extension(".hash");
    std::ofstream hash_file(hash_path);
    if (!hash_file.is_open()) {
        log_warning(tt::LogBuildKernels, "Cannot cache JIT build, failed to open {} for writing.", hash_path.string());
        return;
    }
    std::ifstream dep_file(dep_path);
    if (!dep_file.is_open()) {
        log_warning(tt::LogBuildKernels, "Cannot cache JIT build, failed to open {} for reading.", dep_path.string());
        hash_file.setstate(std::ios::badbit);
    } else {
        auto dependencies = parse_dependency_file(dep_file);
        write_dependency_hashes(dependencies, out_dir, obj, hash_file);
    }
    hash_file.close();
    if (hash_file.fail()) {
        // Don't leave incomplete hash file
        std::filesystem::remove(hash_path);
    }
}

bool dependencies_up_to_date(std::istream& hash_file) {
    size_t count = 0;
    std::filesystem::path dep;
    while (hash_file >> dep) {
        uint64_t recorded_hash{};
        hash_file >> recorded_hash;
        if (hash_file.fail()) {
            log_warning(tt::LogBuildKernels, "Cannot use JIT build cache because dependency hash file is malformed.");
            return false;
        }
        std::ifstream dep_file(dep, std::ios::binary);
        if (!dep_file.is_open()) {
            // It is a valid case that a dependency file no longer exists, for example a header file is no longer used.
            log_debug(tt::LogBuildKernels, "Need to JIT build because file {} no longer exists.", dep.string());
            return false;
        }
        auto dep_hash = hash_file_content(dep_file);
        if (dep_hash != recorded_hash) {
            log_debug(
                tt::LogBuildKernels,
                "Need to JIT build because file {} has changed.  Old hash: {} new hash: {}",
                dep.string(),
                recorded_hash,
                dep_hash);
            return false;
        }
        ++count;
    }
    if (!hash_file.eof()) {
        log_warning(tt::LogBuildKernels, "Cannot use JIT build cache because dependency hash file is malformed.");
        return false;
    }
    // "No dependencies" means "always rebuild".  This shouldn't happen with a properly generated dependency file.
    return count > 0;
}

bool dependencies_up_to_date(const std::string& out_dir, const std::string& obj) {
    std::filesystem::path obj_path = std::filesystem::path(out_dir) / obj;
    std::filesystem::path hash_path = obj_path.replace_extension(".hash");
    std::ifstream hash_file(hash_path);
    if (!hash_file.is_open()) {
        log_debug(tt::LogBuildKernels, "Dependency hash file {} does not exist.", hash_path.string());
        return false;
    }
    return dependencies_up_to_date(hash_file);
}

}  // namespace tt::jit_build

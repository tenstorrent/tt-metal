// SPDX-FileCopyrightText: Â© 2025 Tenstorrent AI ULC
//
// SPDX-License-Identifier: Apache-2.0

#include <cstdint>
#include <array>
#include "compute_kernel_api/reduce.h"
#include "compute_kernel_api/tile_move_copy.h"

namespace NAMESPACE {

void MAIN {
    // Compile-time args:
    // 0: total_gcores (number of gcores to accumulate from)
    // 1-5: CB IDs
    uint32_t total_gcores = get_compile_time_arg_val(0);
    constexpr uint32_t cb_id_in = get_compile_time_arg_val(1);
    constexpr uint32_t cb_id_scaler = get_compile_time_arg_val(2);
    constexpr uint32_t cb_id_reduced = get_compile_time_arg_val(3);
    constexpr uint32_t cb_id_received = get_compile_time_arg_val(4);
    constexpr uint32_t cb_id_add_result = get_compile_time_arg_val(5);

    // Runtime args:
    // 0: is_first_gcore (1 if first gcore, 0 otherwise)
    // 1: rank
    // 2+: (pages, offset, stride) for each dimension
    uint32_t is_first_gcore = get_arg_val<uint32_t>(0);
    uint32_t rank = get_arg_val<uint32_t>(1);

    constexpr uint32_t MAX_RANK = 8;
    std::array<uint32_t, MAX_RANK> dim_pages = {0};
    std::array<uint32_t, MAX_RANK> dim_offsets = {0};
    std::array<uint32_t, MAX_RANK> dim_strides = {0};

    uint32_t arg_idx = 2;
    for (uint32_t d = 0; d < rank; ++d) {
        dim_pages[d] = get_arg_val<uint32_t>(arg_idx++);
        dim_offsets[d] = get_arg_val<uint32_t>(arg_idx++);
        dim_strides[d] = get_arg_val<uint32_t>(arg_idx++);
    }

    // Calculate num_output_rows (product of all dims except last)
    uint32_t num_output_rows = 1;
    for (uint32_t d = 0; d < rank - 1; ++d) {
        num_output_rows *= dim_pages[d];
    }

    // Pages per row (width to reduce over)
    uint32_t pages_per_row = dim_pages[rank - 1];

    compute_kernel_hw_startup(cb_id_in, cb_id_scaler, cb_id_reduced);
    reduce_init(cb_id_in, cb_id_scaler, cb_id_reduced);

    // Wait for scaler tile (generated by dataflow)
    cb_wait_front(cb_id_scaler, 1);

    // Step 1: All gcores - reduce across width dimension for each row
    for (uint32_t row = 0; row < num_output_rows; ++row) {
        acquire_dst();

        for (uint32_t w = 0; w < pages_per_row; ++w) {
            cb_wait_front(cb_id_in, 1);
            reduce_tile(cb_id_in, cb_id_scaler, 0, 0, 0);
            cb_pop_front(cb_id_in, 1);
        }

        // Pack reduced result to CB2
        cb_reserve_back(cb_id_reduced, 1);
        pack_tile(0, cb_id_reduced);
        cb_push_back(cb_id_reduced, 1);

        release_dst();
    }

    // Step 2: First gcore only - accumulate all tiles from CB3
    // CB3 contains all tiles from ALL gcores (including first gcore's local tiles)
    // Layout: [gcore0_row0, gcore0_row1, ..., gcore1_row0, gcore1_row1, ..., gcore2_row0, gcore2_row1, ...]
    // Use reduce to accumulate all tiles from CB3
    // Only needed if there's more than one gcore
    if (is_first_gcore == 1 && total_gcores > 1) {
        // CB3 has all tiles from all gcores
        uint32_t total_all_tiles = total_gcores * num_output_rows;
        cb_wait_front(cb_id_received, total_all_tiles);

        for (uint32_t row = 0; row < num_output_rows; ++row) {
            acquire_dst();

            // Reduce tiles from all gcores for this row
            // For row R, tiles are at indices: R, R+num_output_rows, R+2*num_output_rows, ...
            for (uint32_t gcore_idx = 0; gcore_idx < total_gcores; ++gcore_idx) {
                uint32_t tile_idx = row + gcore_idx * num_output_rows;
                reduce_tile(cb_id_received, cb_id_scaler, tile_idx, 0, 0);
            }

            // Pack final accumulated result to CB4
            cb_reserve_back(cb_id_add_result, 1);
            pack_tile(0, cb_id_add_result);
            cb_push_back(cb_id_add_result, 1);

            release_dst();
        }

        // Pop all tiles from CB3 after processing all rows
        cb_pop_front(cb_id_received, total_all_tiles);
    }
}

}  // namespace NAMESPACE

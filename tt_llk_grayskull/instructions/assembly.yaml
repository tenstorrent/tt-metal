# SPDX-FileCopyrightText: Â© 2024 Tenstorrent AI ULC
#
# SPDX-License-Identifier: Apache-2.0

# Instruction types:
#   This field only matters for verilog generation, it signifies which hierarchical decoder "owns" instruction
#   LOCAL_CREGS  -
#   PC_MODIFYING -
#   COMPUTE      -
#   COMMON_CREGS - ???? Jel se ovo koristi? Nema ga us assembler.cpp
#

ATGETM:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    op_binary: 0xa0
    fcov:
    arguments:
        - name: mutex_index
          start_bit: 0
          field_type: HEX
          description: &mutex_index >
              Mutex index
                0 - math
                2 - unpack0
                3 - unpack1
                4 - pack0
                5 - pack1
                6 - pack2
                7 - pack3
          fcov_point_bins:
            bins: [ {name: "math",    value: "0x0"},
                    {name: "unpack0",  value: "0x2"},
                    {name: "unpack1",  value: "0x3"},
                    {name: "pack0",    value: "0x4"},
                    {name: "pack1",    value: "0x5"},
                    {name: "pack2",  value: "0x6"},
                    {name: "pack3",  value: "0x7"}]
    description: >
        Acquires mutex with index `mutex_index' for the issuing
        thread. At most one thread can hold the mutex at any time.
        Returns immediately if, when the instruction starts, mutex is
        not held by any thread, or is held by the issuing thread.
        Otherwise, stalls issuing thread until mutex is acquired. When
        instruction completes, issuing thread holds the mutex, and it
        must be released using instruction ATRELM.  

ATRELM:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    op_binary: 0xa1
    arguments:
        - name: mutex_index
          start_bit: 0
          field_type: HEX
          description: *mutex_index
    description: >
        Releases mutex with index `mutex_index' if it is held by
        issuing thread. Otherwise, has no effect.

STALLWAIT:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    op_binary: 0xa2
    src_mask: 0x0
    arguments:
        - name: wait_res
          start_bit: 0
          field_type: DEC
          description: "resource to be waited for - bit mask: {trisc cfg(bit13), mover(bit12), srcB valid, srcA valid, srcB cleared, srcA cleared, math, packer3, packer2, packer1, packer0, unpack1, unpack0, thcon(bit0)"
        - name: stall_res
          start_bit: 14
          field_type: HEX
          description: "resource to be stalled -- bit mask for resources (compute/tdma(bit0), sync(bit1), pack(bit2), unpack(bit3), xsearch(bit4), xmov(bit5), thcon(bit6), math(bit7), cfg(bit8)  )"
    description: "Barrier instruction, stall resource until condition is met"

SEMINIT:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    op_binary: 0xa3
    src_mask: 0x0
    arguments:
        - name: sem_sel
          start_bit: 2
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 select"
        - name: init_value
          start_bit: 16
          field_type: DEC
          description: "Semaphore initial value [0..15]"
        - name: max_value
          start_bit: 20
          field_type: DEC
          description: "Semaphore max value [0..15]"

    description: "Initialize a semaphore"

SEMPOST:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    op_binary: 0xa4
    src_mask: 0x0
    arguments:
        - name: sem_sel
          start_bit: 2
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 select"
    description: "Semaphore increment"

SEMGET:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    op_binary: 0xa5
    src_mask: 0x0
    arguments:
        - name: sem_sel
          start_bit: 2
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 select"
    description: "Semaphore decrement"

SEMWAIT:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    op_binary: 0xa6
    src_mask: 0x0
    arguments:
        - name: wait_sem_cond
          start_bit: 0
          field_type: DEC
          description: "Wait on semaphore. 1 - wait while semaphore is 0, 2 - wait while semaphore is max"
        - name: sem_sel
          start_bit: 2
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 select"  
        - name: stall_res
          start_bit: 14
          field_type: HEX
          description: resource to be stalled -- bit mask for resources (compute/tdma, sync, pack, unpack, xsearch, xmov, thcon, math, cfg  )
    description: "Semaphore barrier instruction, stall resource until semaphore condition is met"

NOP:
    op_binary: 0x2
    ex_resource: NONE
    instrn_type: PREDECODE
    src_mask: 0x0
    arguments: 0
    description: "Do nothing and consume an instruction slot and cycle"

ZEROACC:
    op_binary: 0x10
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
        - name: dst
          field_type: DEC
          start_bit: 0
          description: dest register index
        - name: AddrMode
          field_type: BIN
          start_bit: 15
          description: Addressing mode
        - name: clear_mode
          field_type: BIN
          start_bit: 19
          description: "00 - clear only specified dest register. 01 - dest_index specifies block of 16 registers to clear. 10 - dest_index specified upper or lower half to clear. 11 - clear all registers"
          fcov_point_bins:
            bins: [ {name: "clear_only_specified_dest_register",                   value: "0x0"},
                    {name: "dest_index_specifies_block_of_16_registers_to_clear",  value: "0x1"},
                    {name: "dest_index_specified_upper_or_lower_half_to_clear",    value: "0x2"},
                    {name: "clear_all_registers",                                  value: "0x3"} ]
    description: "Zero out accumulator. Single (00) mode clears one register and updates counters using the addressing mode. For other modes, zero-flags are set to emulate clearing of the dest memory, and dest_index is used to determine which portion is to be cleared."

ZEROSRC:
    op_binary: 0x11
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
        - name: src_mask
          field_type: DEC
          start_bit: 0
          description: 1 = zero out source A, 2 = zero out source B, 3 = zero out source A & B
          fcov_point_bins:
            bins: [ {name: "zero_out_source_A",      value: "0x1"},
                    {name: "zero_out_source_B",      value: "0x2"},
                    {name: "zero_out_source_A_and_B", value: "0x3"} ]
        - name: bank_mask
          field_type: DEC
          start_bit: 2
          description: 0 - zero out only current bank, 1 - zero out all banks
          fcov_point_bool:
        - name: write_mode
          field_type: DEC
          start_bit: 3
          description: 1 - current bank is the current read bank (i.e. math kernel), 0 - current bank is the current write bank (i.e. unpacker kernel)
          fcov_poit_bool:
        - name: zero_val
          field_type: BIN
          start_bit: 4
          description: 0 - initialize registers with zero, 1 - initialize registers with -inf (all ones)
          fcov_point_bool:
    description: "Zero out source A or B registers"

MOVA2D:
    op_binary: 0x12
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x1
    arguments: &MOVA_REG
      - name: dst
        field_type: DEC
        start_bit: 0
        description: Dest tart row address offset.  dest_row = addr_mod + offset
      - name: src
        field_type: DEC
        start_bit: 10
        description: Src start row address offset.  src_row = addr_mod + offset
      - name: addr_mode
        field_type: BIN
        start_bit: 15
        description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
      - name: instr_mod
        field_type: DEC
        start_bit: 19
        description: instruction modifier, 0 - move single row, 2 - move 8 rows
    description: "move srca register to dest"

MOVDBGA2D:
    op_binary: 0x9
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    arguments: *MOVA_REG
    description: "move srca register to dest in debug mode - do not wait for ready signals"

MOVD2A:
    op_binary: 0x8
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments: &MOVD_REG
      - name: dst
        field_type: DEC
        start_bit: 0
        description: Dest start row address offset.  dest_row = addr_mod + offset
      - name: src
        field_type: DEC
        start_bit: 10
        description: Src start row address offset.  src_row = addr_mod + offset
      - name: addr_mode
        field_type: BIN
        start_bit: 15
        description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
      - name: instr_mod
        field_type: DEC
        start_bit: 19
        description: instruction modifier, 0 - move single row, 2 - move 4 rows
        fcov_point_bins:
          bins: [ {name: "move_single_row", value: "0x0"},
                  {name: "move_4_rows",     value: "0x2"}]
    description: "Move dest register to srca. "


MOVB2D:
    op_binary: 0x13
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x2
    fcov:
    arguments: &MOVB_REG
      - name: dst
        field_type: DEC
        start_bit: 0
        description: Dest start row address offset.  dest_row = addr_mod + offset
      - name: src
        field_type: DEC
        start_bit: 10
        description:  Src start row address offset.  src_row = addr_mod + offset
        fcov_point_bins:
            bins: [ {name: "move_1_row",                                 value: "0x0"},
                    {name: "move_single_element",                        value: "0x1"},
                    {name: "move_1_row_broadcasted_to_2_words",          value: "0x2"},
                    {name: "move_single_element_broadcasted_to_2_words", value: "0x3"} ]
      - name: addr_mode
        field_type: BIN
        start_bit: 15
        description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
      - name: instr_mod
        field_type: DEC
        start_bit: 19
        description: instruction modifier, bit[0] - single row/single row with broadcasted datum0; bit[1] - broadcast single word; bit[2] - multiple rows
    description: "move srcb register to dest"

TRNSPSRCA:
    op_binary: 0x14
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x1
    arguments: 0
    description: "transpose SRCA main registers"

RAREB:
    op_binary: 0x15
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x2
    arguments: 0
    description: "Rarefy SrcB registers"

SHIFTXA:
    op_binary: 0x17
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x1
    fcov:
    arguments: &SRCA_SHIFTX
        - name: shift_mode
          field_type: DEC
          start_bit: 0
          description: 00 = combined row shift, 01 = rotate, 10 = shift rows independently, 11 = haloize mode combined main registers shift by 1
          fcov_point_bins:
            bins: [ {name: "combined_row_shift",                              value: "0x0"},
                    {name: "rotate",                                          value: "0x1"},
                    {name: "shift_rows_independently",                        value: "0x2"},
                    {name: "haloize_mode_combined_main_registers_shift_by_1", value: "0x3"} ]
        - name: log2_amount2
          field_type: DEC
          start_bit: 2
          description: Log2 of the shift amount (possible amounts 1, 2, 4, 8); don't-care if shift_mode=11
          fcov_point_bins:
            bins: [ {name: "shift_1", value: "0x0"},
                    {name: "shift_2", value: "0x1"},
                    {name: "shift_4", value: "0x2"},
                    {name: "shift_8", value: "0x3"} ]
    description: "horizontal SRCA shift"

SETASHRMH0:
    op_binary: 0x1A
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x1
    arguments: &SRCSHRH0_MASK
        - name: halo_mask
          field_type: HEX
          start_bit: 0
          description: halo mask
        - name: reg_mask
          field_type: HEX
          start_bit: 1
          description: 16bit wide register mask
    description: "SRCA right shift horizontal mask, covering left halo and thread0 reg_array"

SETASHRMH1:
    op_binary: 0x1B
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x1
    arguments: *SRCSHRH0_MASK
    description: "SRCA right shift horizontal mask 1, covering thread1 reg_array. halo_mask argument is not used as there's no additional left halo storage with respect to thread1, right halo_mask is implied through the main_reg_mask"

SETASHRMV:
    op_binary: 0x1C
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x1
    arguments: &SRCSHRV_MASK
        - name: reg_mask2
          field_type: HEX
          start_bit: 0
          description: 20bit wide register mask
    description: "SRCA right shift vertical mask, covering main reg_array and central_sr"

SETASHRMH:
    op_binary: 0x1E
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x1
    arguments: *SRCSHRH0_MASK
    description: "SRCA right shift horizontal mask, only targeting own thread regs"

SETPKEDGOF: # fixme: maybe go away as instruction?
    op_binary: 0x1D
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    arguments: &PKEDGE_OFFSET
        - name: x_start
          field_type: DEC
          start_bit: 0
          description: starting datum index for X
        - name: x_end
          field_type: DEC
          start_bit: 4
          description: ending datum index for X
        - name: y_start
          field_type: DEC
          start_bit: 8
          description: starting datum index for Y
        - name: y_end
          field_type: DEC
          start_bit: 12
          description: ending datum index for Y
    description: "Packer row/column offsets to zero out edges of X-Y plane"

CLREXPHIST:
    op_binary: 0x21
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    arguments: 0
    description: "Clear exponent histogram"

CONV3S1:
    op_binary: 0x22
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    arguments: &CONV_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          description: Dest address spec
        - name: addr_mode
          field_type: BIN
          start_bit: 15
          description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        - name: rotate_weights
          field_type: BIN
          start_bit: 17
          description: Rotate weights for backprop (1-bit field for CONV3S1 and CONV3S2 only)
        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          description: "Clear data valid bits (B,A) after math is done."
    description: "3x3 primitive for convolution, with stride 1. Outputs 8x 16-wide rows of data"

CONV3S2:
    op_binary: 0x23
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    arguments: *CONV_ARGS
    description: "Convolution with 3x3 primitive, with stride 2. Outputs 8x 16-wide rows of data"

MPOOL3S1:
    op_binary: 0x24
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    arguments: &MATH_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          description: Dest address spec
        - name: addr_mode
          field_type: BIN
          start_bit: 15
          description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          description: "Clear data valid bits (B,A) after math is done."
    description: "3x3 primitive for pooling, with stride 1 "

APOOL3S1:
    op_binary: 0x25
    ex_resource: MATH
    instrn_type: COMPUTE
    arguments: *MATH_ARGS
    src_mask: 0x3
    description: "3x3 primitive for pooling, with stride 1 "

MVMUL:
    op_binary: 0x26
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: &MVMUL_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          description: Dest address spec
        - name: addr_mode
          field_type: BIN
          start_bit: 15
          description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        - name: instr_mod
          field_type: DEC
          start_bit: 19
          description: instruction modifier, 0 - compute 4 rows (full BW); 1 - compute 1 row (1/4 of BW)
          fcov_point_bool:
        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          description: "Clear data valid bits (B,A) after math is done."
    description: "Vector-matrix multiply. Outputs 4x 16-wide row"

ELWMUL:
    op_binary: 0x27
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: &ELW_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          description: Dest address spec
        - name: addr_mode
          field_type: BIN
          start_bit: 15
          description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        - name: instr_mod
          field_type: DEC
          start_bit: 19
          description: instruction modifier, 0 - srcb operand in vector mode; 1 - srcb operand [0] broadcasted
          fcov_point_bool:
        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          description: "Clear data valid bits (B,A) after math is done."
    description: "Elementwise multiply operation"

ELWADD:
    op_binary: 0x28
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    arguments: *ELW_ARGS
    description: "Elementwise add operation"

DOTPV:
    op_binary: 0x29
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    arguments: *ELW_ARGS
    description: "dot product of two vectors"

ELWSUB:
    op_binary: 0x30
    ex_resource: MATH
    src_mask: 0x3
    instrn_type: COMPUTE
    arguments: *ELW_ARGS
    description: "Elementwise subtract operation (A-B)"

MPOOL3S2:
    op_binary: 0x31
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    arguments: *MATH_ARGS
    description: "3x3 primitive for pooling, with stride 2 "

APOOL3S2:
    op_binary: 0x32
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    arguments: *MATH_ARGS
    description: "3x3 primitive for pooling, with stride 2 "

GMPOOL:
    op_binary: 0x33
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: &GPOOL_ARGS
      - name: dst
        field_type: DEC
        start_bit: 0
        description: Dest address spec
      - name: addr_mode
        field_type: BIN
        start_bit: 15
        description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
      - name: instr_mod
        field_type: DEC
        start_bit: 19
        description: instruction modifier, 0 - single row wide; 1 - 16x16 wide
        fcov_point_bool:
      - name: clear_dvalid
        field_type: BIN
        start_bit: 22
        description: "Clear data valid bits (B,A) after math is done."
    description: "Global max pool with primitive size 16x16 "

GAPOOL:
    op_binary: 0x34
    ex_resource: MATH
    src_mask: 0x3
    instrn_type: COMPUTE
    arguments: *GPOOL_ARGS
    description: "Global average pool with primitive size 16x16 "

SETDVALID:
    op_binary: 0x57
    ex_resource: TDMA
    instrn_type: TDMA
    src_mask: 0x0
    arguments:
        - name: setvalid
          field_type: BIN
          start_bit: 0
          description: "Set {B,A} data valid (2 bits)"
    description: "Sets A/B data valid for current write ID. TDMA instruction."

GATESRCRST:
    op_binary: 0x35
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
        - name: reset srca gate control
          field_type: BIN
          start_bit: 0
          description: "When set, the state of srca pipeline gating mechanism will reset to dont gate "
          fcov_point_bool:
        - name: reset srcb gate control
          field_type: BIN
          start_bit: 1
          description: "When set, the state of srcb pipeline gating mechanism will reset to dont gate "
          fcov_point_bool:
    description: "Clear data valid bits, or reset data valid mechanism completely."

CLEARDVALID:
    op_binary: 0x36
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
        - name: reset
          field_type: BIN
          start_bit: 0
          description: "When set, clears all data valid bits, and reset write and read IDs to 0."
          fcov_point_bool:
        - name: cleardvalid
          field_type: BIN
          start_bit: 22
          description: "Clear {B,A} data valid (2 bits)"
    description: "Clear data valid bits, or reset data valid mechanism completely."

SETRWC:
    op_binary: 0x37
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    arguments: &SETRWC_ARGS
        - name: BitMask
          field_type: BIN
          start_bit: 0
          description: "bit mask (fidelity_phase_clear,rwc_d,rwc_b,rwc_a)"
        - name: rwc_a
          field_type: DEC
          start_bit: 6
          description: rwc A value
        - name: rwc_b
          field_type: DEC
          start_bit: 10
          description: rwc B value
        - name: rwc_d
          field_type: DEC
          start_bit: 14
          description: rwc DST value
        - name: rwc_cr
          field_type: BIN
          start_bit: 18
          description: "bit mask (apply values specified to RWC CR counters (Dest CToCRMode,Dest,SrcB,srcA) (Dest CToCrMode: 1: CR <= Counter + inc, 0: CR <= CR + inc)"
        - name: clear_ab_vld
          field_type: BIN
          start_bit: 22
          description: clear srcA and srcB valids indicating to unpacker that new data can be written in
    description: "Set register word counters or CR counters"

INCRWC:
    op_binary: 0x38
    ex_resource: MATH
    instrn_type: COMPUTE
    src_mask: 0x0
    arguments: &INCRWC_ARGS
        - name: rwc_a
          field_type: DEC
          start_bit: 6
          description: rwc A value
        - name: rwc_b
          field_type: DEC
          start_bit: 10
          description: rwc B value
        - name: rwc_d
          field_type: DEC
          start_bit: 14
          description: rwc DST value
        - name: rwc_cr
          field_type: BIN
          start_bit: 18
          description: apply values specified to RWC CR counters
    description: "Increment RWC counters or CR counters"

XMOV:
    op_binary: 0x40
    ex_resource: XMOV
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Last
          field_type: BIN
          start_bit: 0
          description: "To be set to 0 for all invocations of XMOV except for the last in a task of assembling input data for     a thread (in which it should be set to 1). Causes data accumulation buffers in mover to flush  to memory"
          fcov_point_bool:
        - name: Mov block selection
          field_type: BIN
          start_bit: 23
          description: Select between two move blocks
          fcov_point_bool:
    description: "Move data between L0 and L1"


PACR:
    op_binary: 0x41
    ex_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Last
          field_type: BIN
          start_bit: 0
          description: "To be set to 0 for all invocations of PACR except for the last in a tile, when it should be set to 1"
          fcov_point_bool:
        - name: Flush
          field_type: BIN
          start_bit: 1
          description: "When this bit is set the PACR instruction will just cause a flush of non-empty WAs in the packer"
          fcov_point_bool:
        - name: Concat
          field_type: BIN
          start_bit: 4
          description: "To be set to 1 when packed data needs to be concataned to the output of the previous PACR instruction. Must be set to 1 for the first pack instruction and 0 for the last PACR in a row "
          fcov_point_bool:
        - name: OvrdThreadId
          field_type: BIN
          start_bit: 7
          description: "Use context ID instead of thread ID to select packer configuration. context id is set in the packer configuration register"
        - name: PackSel
          field_type: BIN
          start_bit: 8
          description: "Bit mask to select up to 4 packers. When PackSel is 0 then packer 0 will be selected by default"
          fcov_point_bins:
            bins: [ {name: "pack1",    value: "0x0"},
                    {name: "pack2lo",  value: "0x3"},
                    {name: "pack2hi",  value: "0xc"},
                    {name: "pack4",    value: "0xf"} ]
        - name: ZeroWrite
          field_type: BIN
          start_bit: 12
          description: "Will cause zeros to be written regardless of source data"
          fcov_point_bool:
        - name: AddrMode   # TODO: What's the encoding here?  FCOV
          field_type: BIN
          start_bit: 15
          description: 2-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
    description: "Pack row from DST registers to L0"

UNPACR:
    op_binary: 0x42
    ex_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Last
          field_type: BIN
          start_bit: 0
          description: "To be set to 0 for all invocations of UNPACR except for the last in a task of assembling input data for a thread (in which it should be set to 1). Causes data accumulation buffers in unpacker to flush  to memory"
        - name: SearchCacheFlush
          field_type: BIN
          start_bit: 1
          description: Flush row pointer cache in the search block
          fcov_point_bool:
        - name: RowSearch
          field_type: BIN
          start_bit: 2
          description: "Search for start and end of selected row(s) within tile. If not set search is done per datum(s)"
          fcov_point_bool:
        - name: AutoIncContextID
          field_type: BIN
          start_bit: 3
          description: "Auto increment config context ID after evey unpack instruction"
          fcov_point_bool:
        - name: ZeroWrite2
          field_type: BIN
          start_bit: 4
          description: "Will cause zeros to be written regardless of source data"
          fcov_point_bool:
        - name: rareb_en
          field_type: BIN
          start_bit: 5
          description: "Will cause srcb rarefy to trigger on uncompress_done"
          fcov_point_bool:         
        - name: SetDatValid
          field_type: BIN
          start_bit: 6
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: OvrdThreadId
          field_type: BIN
          start_bit: 7
          description: "Use context ID instead of thread ID to select unpacker configuration"
          fcov_point_bool:
        - name: AddrCntContextId 
          field_type: DEC
          start_bit: 8
          description: "Address counter context ID 0..2"
        - name: CfgContextId  
          field_type: DEC
          start_bit: 10
          description: "Config context ID 0..7"
        - name: CfgContextCntInc  
          field_type: BIN
          start_bit: 13
          description: "Increment config context counter without performing search and unpack"
        - name: AddrMode
          field_type: BIN
          start_bit: 15
          description: "Addressing mode: CH1_Y_INC, CH1_Z_INC, CH0_Y_INC, CH0_Z_INC. INCs are 2 bits each (8 total)"
        - name: Unpack_block_selection
          field_type: BIN
          start_bit: 23
          description: Select between two unpackers
          fcov_point_bins:
            bins: [ {name: "unpack0",   value: "0"},
                    {name: "unpack1",   value: "1"} ]
    description: "Search and unpack row from tile in L0 to SRCA/SRCB registers (by UNPACK0/UNPACK1)"

UNPACR_NOP: # Misc unpack instruction with side effect (skips actual search and unpack)
    op_binary: 0x43
    ex_resource: UNPACK
    instrn_type: TDMA
    fcov:
    arguments:
        - name: NoOp
          field_type: DEC
          start_bit: 0
          description: "0 - UNP_POP (freeing up data allocation buffer in noc overlay through side band signal. 
                                 Amount of data to be freed is set through NOC_OVERLAY_MSG_CLEAR register)
                        1 - UNP_ZERO_SRC (clear srcA or srcB when unpack is done)
                        2 - UNP_NOP (inject cycle delay between back to back unpack)"
          fcov_point_bins:
            bins: [  {name: "UNP_POP",      value: "0x0"},
                     {name: "UNP_ZERO_SRC", value: "0x1"},
                     {name: "UNP_NOP",      value: "0x2"}]
        - name: Unpack_block_selection
          field_type: BIN
          start_bit: 23
          description: Select between two unpackers
          fcov_point_bins:
            bins: [ {name: "unpack0",   value: "0"},
                    {name: "unpack1",   value: "1"} ]
    description: "Trigger side-effect once unpack is done. Skips actual search and unpack"

RSTDMA: # fixme; remove instr?
    op_binary: 0x44
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    arguments:
    description: "Soft reset of TDMA engine"

SETDMAREG:
    op_binary: 0x45
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: RegIndex16b
          field_type: DEC
          start_bit: 0
          description: "TDMA register index in 16b quants"
        - name: SetSignalsMode
          field_type: BIN
          start_bit: 7
          description: "Sets registers from signals routed into TDMA block rather than from payload immediate bellow. In this mode payload immediate represents a mux control for which 16b signal chunk to feed into selected register"
          fcov_point_bool:
        - name: Payload_SigSel
          field_type: DEC
          start_bit: 8
          description: "In normal mode - immediate payload to set into selected register. In SetSignals mode selector for which 16b chunk of signals to set into selected register.
          Payload_SigSel[6:3] mode values:
            0  - Accumulated tile size (16-bit) and last written tile size (16-bit) for 4 packers (128-bit)
            1  - All zero flag per XY plane [31:0] for 4 packers (128-bit)
            2  - Tile header for packer 0 (SigSelSize set to 3 - TileHeader)
            3  - Tile header for packer 1 (SigSelSize set to 3 - TileHeader)
            4  - Tile header for packer 2 (SigSelSize set to 3 - TileHeader)
            5  - Tile header for packer 3 (SigSelSize set to 3 - TileHeader)
            6  - FPU stats 0 (payload bits 8:7 are used to select packer)
            7  - FPU stats 1 (payload bits 8:7 are used to select packer)
            8  - Clear accumulated tile size as a side-effect (payload bits 10:7 is the mask used to select packer)
            9  - FPU stats max exp"
        - name: Payload_SigSelSize
          field_type: DEC
          start_bit: 22
          description: "Payload size in SetSignals mode. 0 - 16-bit, 1 - 32-bit, 2 - 128-bit, 3 - TileHeader"
          fcov_point_bins:
            bins: [ {name: "16bit",   value: "0x0"},
                    {name: "32bit",   value: "0x1"},
                    {name: "128bit",  value: "0x2"},
                    {name: "TileHeader", value: "0x3"}]
    description: "Set TDMA register file register with 16b immediate value provided with instruction or with routed signals from TDMA via indirect side-effects"

FLUSHDMA:
    op_binary: 0x46
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: FlushSpec
          field_type: DEC
          start_bit: 0
          description: "Flushes (blocks until completely drained and idle) the entire TDMA engine or a selected component of it. 0 - flush entire DMA, 1 - flush TC(thread controller), 2 flush unpacker0, 4 flush unpacker1, 8 flush packer"
          fcov_point_bins:
            bins: [ {name: "flush_entire_DMA", value: "0x0"},
                    {name: "flush_TC",         value: "0x1"},
                    {name: "flush_unpacker0",  value: "0x2"},
                    {name: "flush_unpacker1",  value: "0x4"},
                    {name: "flush_packer",     value: "0x8"}]
    description: "Flush TDMA engine or some subset of it as specified by instruction argument"

REG2FLOP:
    op_binary: 0x48
    ex_resource: THCON  # FIXME: should this be CFG?  ckernels STALLWAIT against CFG to block this
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: RegIndex
          field_type: DEC
          start_bit: 0
          description: "TDMA 32b register index"
        - name: FlopIndex
          field_type: DEC
          start_bit: 6
          description: "TDMA 32b flop storage location"
        - name: ContextId_2
          field_type: DEC
          start_bit: 16
          description: "Context ID 0..3"
          fcov_point_bins:
            bins: [ {name: "Context_ID_0", value: "0x0"},
                    {name: "Context_ID_1", value: "0x1"},
                    {name: "Context_ID_2", value: "0x2"},
                    {name: "Context_ID_3", value: "0x3"}]
        - name: ByteOffset
          field_type: DEC
          start_bit: 18
          description: "Offset (in bytes) into the 32 bit register location. Used for field extraction during 8 or 16 bit moves."
        - name: TargetSel
          field_type: DEC
          start_bit: 20
          description: "Target Select. 0: TDMA Registers, 1: Local Registers, 2: Context Registers, 3: Override thread id with context id"
          fcov_point_bins:
            bins: [ {name: "TDMA_Registers",                     value: "0x0"},
                    {name: "Local_Registers",                    value: "0x1"},
                    {name: "Context_Registers",                  value: "0x2"},
                    {name: "Override_thread_id_with_context_id", value: "0x3"}]
        - name: SizeSel
          field_type: DEC
          start_bit: 22
          description: "Select size of the data transfer. 0: 16 Bytes, 1: 32 bits, 2: bits, 3: 8 bits." #2: 16 bits?
          fcov_point_bins:
            bins: [ {name: "16Bytes", value: "0x0"},
                    {name: "32bits",  value: "0x1"},
                    {name: "16bits",  value: "0x2"},
                    {name: "8bits",   value: "0x3"}]
    description: "Move data from TDMA register file into flip flops driving actual config signals. Used for certain TDMA configuration signal setting."

LOADIND:
    op_binary: 0x49
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: AddrRegIndex
          field_type: DEC
          start_bit: 0
          description: "Address register index. Address is a L1 16B address"
        - name: DataRegIndex
          field_type: DEC
          start_bit: 6
          description: "Destination data register index"
        - name: AutoIncSpec
          field_type: DEC
          start_bit: 12
          description: "Autoincrement spec: 0 - no autoinc, 1 - autoinc by 2(B)ytes, 2 - autoinc by 4B, 3 - autoinc by 16B"
          fcov_point_bins:
            bins: [ {name: "no_autoinc",     value: "0x0"},
                    {name: "autoinc_by_2B",  value: "0x1"},
                    {name: "autoinc_by_4B",  value: "0x2"},
                    {name: "autoinc_by_16B", value: "0x3"}]
        - name: OffsetIndex
          field_type: DEC
          start_bit: 14
          description: "Offset address register index, in 16b quants (i.e. double the normal R value). Offset is in Bytes"
        - name: SizeSel
          field_type: DEC
          start_bit: 22
          description: "Select whether the data move is 0 - 16B, 1 - 32b, 2 - 16b, 3 - 8b size"
          fcov_point_bins:
            bins: [ {name: "16B", value: "0x0"},
                    {name: "32b", value: "0x1"},
                    {name: "16b", value: "0x2"},
                    {name: "8b",  value: "0x3"}]
    description: "Load indirect from address specified in a TDMA register, with offset specified in TDMA register to a TDMA register. Supports autoincrementing offset"

SETADC:
    op_binary: 0x50
    instrn_type: ADDRMOD
    ex_resource: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Value
          field_type: DEC
          start_bit: 0
          description: Address counter value
        - name: DimensionIndex
          field_type: DEC
          start_bit: 18
          description: 0 for X, 1 for Y, 2 for Z, 3 for W
          fcov_point_bins:
            bins: [ {name: "X", value: "0x0"},
                    {name: "Y", value: "0x1"},
                    {name: "Z", value: "0x2"},
                    {name: "W", value: "0x3"}]
        - name: ChannelIndex
          field_type: BIN
          start_bit: 20
          description: 0 - channel 0, 1 - channel 1
          fcov_point_bool:
        - name: CntSetMask
          field_type: BIN
          start_bit: 21
          description: 001 - unpacker0, 010 - unpacker1, 100 - packer0
          fcov_point_bins:
            bins: [ {name: "unpacker0", value: "0x1"},
                    {name: "unpacker1", value: "0x2"},
                    {name: "packer0",   value: "0x4"}]
    description: "Set address counter for one channel and one dimension, but supports full address counter precision"

SETADCXY:
    op_binary: 0x51
    ex_resource: TDMA
    instrn_type: ADDRMOD
    src_mask: 0x0
    fcov:
    arguments: &SETADCXY_ARGS
        - name: BitMask
          field_type: BIN
          start_bit: 0
          description: "bit mask (Ch1_Y,Ch1_X,Ch0_Y,Ch0_X)"
        - name: Ch0_X
          field_type: DEC
          start_bit: 6
          description: Ch0_X value
        - name: Ch0_Y
          field_type: DEC
          start_bit: 9
          description: Ch0_Y value
        - name: Ch1_X
          field_type: DEC
          start_bit: 12
          description: Ch1_X value
        - name: Ch1_Y
          field_type: DEC
          start_bit: 15
          description: Ch1_Y value
        - name: CntSetMask
          field_type: BIN
          start_bit: 21
          description: 001 - unpacker0, 010 - unpacker1, 100 - packer0
          fcov_point_bins:
            bins: [ {name: "unpacker0", value: "0x1"},
                    {name: "unpacker1", value: "0x2"},
                    {name: "packer0",   value: "0x4"}]
    description: "Set address counters for X and Y dimensions. Choose counter set based on the CntSetMask"

INCADCXY:
    op_binary: 0x52
    ex_resource: TDMA
    instrn_type: ADDRMOD
    src_mask: 0x0
    fcov:
    arguments: &INCADCXY_ARGS
        - name: Ch0_X
          field_type: DEC
          start_bit: 6
          description: Channel 0 X value
        - name: Ch0_Y
          field_type: DEC
          start_bit: 9
          description: Channel 0 Y value
        - name: Ch1_X
          field_type: DEC
          start_bit: 12
          description: Channel 1 X value
        - name: Ch1_Y
          field_type: DEC
          start_bit: 15
          description: Channel 1 Y value
        - name: CntSetMask
          field_type: BIN
          start_bit: 21
          description: 001 - unpacker0, 010 - unpacker1, 100 - packer0
          fcov_point_bins:
            bins: [ {name: "unpacker0", value: "0x1"},
                    {name: "unpacker1", value: "0x2"},
                    {name: "packer0",   value: "0x4"}]
    description: "Increment address counters for X and Y dimensions, for both channels (0/1). Channel 0 = src, Channel 1 = dest"

ADDRCRXY:
    op_binary: 0x53
    ex_resource: TDMA
    instrn_type: ADDRMOD
    src_mask: 0x0
    arguments: *SETADCXY_ARGS
    description: "Address carriage return"

SETADCZW:
    op_binary: 0x54
    ex_resource: TDMA
    src_mask: 0x0
    instrn_type: ADDRMOD
    arguments: *SETADCXY_ARGS
    description: "Set address counters for Z and W dimensions"

INCADCZW:
    op_binary: 0x55
    ex_resource: TDMA
    instrn_type: ADDRMOD
    src_mask: 0x0
    arguments: *INCADCXY_ARGS
    description: "Increments address counter, for Z and W dimensions, for both channels (0/1)"

ADDRCRZW:
    op_binary: 0x56
    ex_resource: TDMA
    instrn_type: ADDRMOD
    src_mask: 0x0
    arguments: *SETADCXY_ARGS
    description: "Address carriage return"

ADDDMAREG:
    op_binary: 0x58
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    arguments: &ADDDMAREG_ARGS
        - name: OpARegIndex
          field_type: DEC
          start_bit: 0
          description: "TDMA 32b register index for operand A"
        - name: OpBRegIndex
          field_type: DEC
          start_bit: 6
          description: "TDMA 32b register index for operand B"
        - name: ResultRegIndex
          field_type: DEC
          start_bit: 12
          description: "TDMA 32b register index for result"
        - name: OpBisConst
          field_type: BIN
          start_bit: 23
          description: "Use OpBRegIndex as const value for math operation"
    description: "If OpBisConst is 0 adds 32-bit values from DMA registers pointed by OpARegIndex and OpBRegIndex or
                  if OpBisConst is 1 adds 32-bit value from DMA registers pointed by OpARegIndex and 6-bit const value set in OpBRegIndex field
                  and writes result to register ResultRegIndex"

SUBDMAREG:
    op_binary: 0x59
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    arguments: *ADDDMAREG_ARGS
    description: "If OpBisConst is 0 subtracts 32-bit values from DMA registers pointed by OpARegIndex and OpBRegIndex
                  or if OpBisConst is 1 subtracts 32-bit value from DMA register pointed by OpARegIndex with 6-bit const value set in OpBRegIndex field
                  and writes result to register ResultRegIndex"

MULDMAREG:
    op_binary: 0x5a
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    arguments: *ADDDMAREG_ARGS
    description: "If OpBisConst is 0 multiplies 16-bit values from DMA registers pointed by OpARegIndex and OpBRegIndex or
                  if OpBisConst is 1 multiplies 16-bit value from DMA register pointed by OpARegIndex with 6-bit const value set in OpBRegIndex field
                  and writes result to register ResultRegIndex"

BITWOPDMAREG:
    op_binary: 0x5b
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: OpARegIndex
          field_type: DEC
          start_bit: 0
          description: "TDMA 32b register index for operand A"
        - name: OpBRegIndex
          field_type: DEC
          start_bit: 6
          description: "TDMA 32b register index for operand B"
        - name: ResultRegIndex
          field_type: DEC
          start_bit: 12
          description: "TDMA 32b register index for result"
        - name: OpSel
          field_type: DEC
          start_bit: 18
          description: "0 - AND, 1 - OR, 2 - XOR"
          fcov_point_bins:
            bins: [ {name: "AND", value: "0x0"},
                    {name: "OR",  value: "0x1"},
                    {name: "XOR", value: "0x2"}]
        - name: OpBisConst
          field_type: BIN
          start_bit: 23
          description: "Use OpBRegIndex as const value for math operation"
    description: "If OpBisConst is 0 performs bit-wise operation on 32-bit values from DMA registers pointed by OpARegIndex and OpBRegIndex or
                  if OpBisConst is 0 performs bit-wise operation on 32-bit value from DMA register pointed by OpARegIndex with 6-bit const value set in OpBRegIndex field
                  and writes result to register ResultRegIndex"

SHIFTDMAREG:
    op_binary: 0x5c
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: OpARegIndex
          field_type: DEC
          start_bit: 0
          description: "TDMA 32b register index for operand A"
        - name: OpBRegIndex
          field_type: DEC
          start_bit: 6
          description: "TDMA 32b register index for operand B"
        - name: ResultRegIndex
          field_type: DEC
          start_bit: 12
          description: "TDMA 32b register index for result"
        - name: OpSel
          field_type: DEC
          start_bit: 18
          description: "0 - LEFT, 1 - RIGHT"
          fcov_point_bool:
        - name: OpBisConst
          field_type: BIN
          start_bit: 23
          description: "Use OpBRegIndex as const value for math operation"
          fcov_point_bool:
    description: "Shifts OpARegIndex <<|>> OpBRegIndex and writes result to register ResultRegIndex. If OpBisConst is 1 6-bit const value set in OpBRegIndex field is used as operand B"

CMPDMAREG:
    op_binary: 0x5d
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: OpARegIndex
          field_type: DEC
          start_bit: 0
          description: "TDMA 32b register index for operand A"
        - name: OpBRegIndex
          field_type: DEC
          start_bit: 6
          description: "TDMA 32b register index for operand B"
        - name: ResultRegIndex
          field_type: DEC
          start_bit: 12
          description: "TDMA 32b register index for result"
        - name: OpSel
          field_type: DEC
          start_bit: 18
          description: "0 - A>B, 1 - A<B, 2 - A==B"
          fcov_point_bins:
            bins: [ {name: "A_greater_than_B",  value: "0x0"},
                    {name: "A_less_than_B",  value: "0x1"},
                    {name: "A_equals_B", value: "0x2"}]
        - name: OpBisConst
          field_type: BIN
          start_bit: 23
          description: "Use OpBRegIndex as const value for math operation"
          fcov_point_bool:
    description: "Compares values in OpARegIndex and OpBRegIndex registers and writes result 0 or 1 to register ResultRegIndex. If OpBisConst is 1 6-bit const value set in OpBRegIndex field is used as operand B"

SETADCXX:
    op_binary: 0x5E
    ex_resource: TDMA
    src_mask: 0x0
    instrn_type: ADDRMOD
    fcov:
    arguments:
        - name: x_start
          field_type: DEC
          start_bit: 0
          description: x_start set value
        - name: x_end2
          field_type: DEC
          start_bit: 10
          description: x_end set value
        - name: CntSetMask
          field_type: BIN
          start_bit: 21
          description: 001 - unpacker0, 010 - unpacker1, 100 - packer0
          fcov_point_bins:
            bins: [ {name: "unpacker0", value: "0x1"},
                    {name: "unpacker1", value: "0x2"},
                    {name: "packer0",   value: "0x4"}]
    description: "Set address counters for Z and W dimensions"

DMANOP:
    op_binary: 0x60
    ex_resource: TDMA
    src_mask: 0x0
    instrn_type: TDMA
    arguments: 0
    description: "Do nothing and consume an tdma instruction slot and cycle"

ATINCGET:
    op_binary: 0x61
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: AddrRegIndex
          field_type: DEC
          start_bit: 0
          description: "Address register index (16B word address)"
        - name: DataRegIndex
          field_type: DEC
          start_bit: 6
          description: "Source(inc value) and destination data register index"
        - name: Sel32b
          field_type: DEC
          start_bit: 12
          description: "Selects the 32b word within a 16B word to operate on"
          fcov_point_bins:
            bins: [ {name: "word0", value: "0x0"},
                    {name: "word1", value: "0x1"},
                    {name: "word2", value: "0x2"},
                    {name: "word3", value: "0x3"}]
        - name: WrapVal
          field_type: DEC
          start_bit: 14
          description: "Wrap the targeted address value at 1 << WrapVal[4:0]"
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          description: "Selects whether transaction is targetting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: "Atomic increment and get - will read value in targetted memory location and return it to TDMA register and post-increment it atomically with the value pointed by DataRegIndex field"

ATINCGETPTR:
    op_binary: 0x62
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: AddrRegIndex
          field_type: DEC
          start_bit: 0
          description: "Address register index (16B word address)"
        - name: DataRegIndex
          field_type: DEC
          start_bit: 6
          description: "Destination data register index"
        - name: Sel32b
          field_type: DEC
          start_bit: 12
          description: "Selects the 32b word within a 16B word to operate on (i.e. Read/Write select)"
          fcov_point_bins:
            bins: [ {name: "word0", value: "0x0"},
                    {name: "word1", value: "0x1"},
                    {name: "word2", value: "0x2"},
                    {name: "word3", value: "0x3"}]
        - name: WrapVal
          field_type: DEC
          start_bit: 14
          description: "Wrap the targeted address value at 1 << WrapVal (e.g. Set WrapVal==3 for a 4-byte byte-addressed fifo)"
        - name: IncrVal
          field_type: DEC
          start_bit: 18
          description: "Post-increment by 1<<IncrVal if NoIncr is 0"
        - name: NoIncr
          field_type: BIN
          start_bit: 22
          description: "Disable pointer increment"
          fcov_point_bool:
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          description: "Selects whether transaction is targetting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: >
        Atomic increment and get pointer - will access a memory location designated as a FIFO pointer location (contains a 32b read pointer and a 32b write pointer), return the
        pointer value to TDMA register and post-increment it unless the FIFO condition precludes that. For example, write pointer will not be incremented if FIFO is full. Read pointer
        will not be incremented if FIFO is empty. FIFO full or empty conditions are returned as an unsuccessful return condition code, so that the thread controller can retry until
        success (retry reads if FIFO empty, retry writes if FIFO full.) If NoIncr is set to 1 then hardware will not increment the pointers but retry will still occur if FIFO is empty or full

ATSWAP:
    op_binary: 0x63
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: AddrRegIndex
          field_type: DEC
          start_bit: 0
          description: "Address register index (16B word address)"
        - name: DataRegIndex
          field_type: DEC
          start_bit: 6
          description: "First of four data register indexes. Must be aligned to 4."
        - name: SwapMask
          field_type: DEC
          start_bit: 14
          description: "Swap mask at 16b granulatiry (8b of mask for 16B words)"
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          description: "Selects whether transaction is targetting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: "Atomic unconditional SWAP. Swaps selected 16b chunks of memory location with new ones provided on write data bus."

ATCAS:
    op_binary: 0x64
    ex_resource: THCON
    src_mask: 0x0
    instrn_type: TDMA
    fcov:
    arguments:
        - name: AddrRegIndex
          field_type: DEC
          start_bit: 0
          description: "Address register index (16B word address)"
        - name: DataRegIndex  # FIXME: unused and to be removed. Issue #434
          field_type: DEC
          start_bit: 6
          description: "Destination data register index"
        - name: Sel32b
          field_type: DEC
          start_bit: 12
          description: "Selects the 32b word within a 16B word to operate on"
          fcov_point_bins:
            bins: [ {name: "word0", value: "0x0"},
                    {name: "word1", value: "0x1"},
                    {name: "word2", value: "0x2"},
                    {name: "word3", value: "0x3"}]
        - name: CmpVal
          field_type: DEC
          start_bit: 14
          description: "Compare value provided as an immediate (4 bits)"
        - name: SwapVal
          field_type: DEC
          start_bit: 18
          description: "Swap value provided as an immediate (4 bits)"
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          description: "Selects whether transaction is targeting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: >
        Atomic compare-and-swap. If value at selected memory location matches that provided by programmer it is swapped to a new one, also provided by
        programmer. Otherwise, instruction will be retried until it does match at which time it will swap.  This instruction is implemented for
        implementations of mutual exclusion between Tensix cores and threads

STOREIND:
    op_binary: 0x66
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: AddrRegIndex
          field_type: DEC
          start_bit: 0
          description: "Address register index"
        - name: DataRegIndex
          field_type: DEC
          start_bit: 6
          description: "Source data register index"
        - name: AutoIncSpec
          field_type: DEC
          start_bit: 12
          description: "Autoincrement spec: 0 - no autoinc, 1 - autoinc by 2(B)ytes, 2 - autoinc by 4B, 3 - autoinc by 16B"
          fcov_point_bins:
            bins: [ {name: "no_autoinc",     value: "0x0"},
                    {name: "autoinc_by_2B",  value: "0x1"},
                    {name: "autoinc_by_4B",  value: "0x2"},
                    {name: "autoinc_by_16B", value: "0x3"}]
        - name: OffsetIndex
          field_type: DEC
          start_bit: 14
          description: "Offset address register index"
        - name: RegSizeSel
          field_type: BIN
          start_bit: 21
          description: "If MemHierSel bit is set to 0 (source regfile) then this bit elects between src A and B register file: 0 - SRC A, 1 - SRCB. Supported data move size is 16B and 32b.
                        If MemHierSel bit is set to 1 (L1) then bits 22:21 are used for setting data move size: 0 - 16B, 1 - 16b, 2 - 32b, 3 - 8b size"
          fcov_point_bool:
        - name: SizeSel
          field_type: BIN
          start_bit: 22
          description: "Select whether the data move is 16B (0) or 32b (1) size"
          fcov_point_bool:
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          description: "Selects whether transaction is targetting source regfile (0) or L1 (1)"
          fcov_point_bool:
    description: "Store indirect. Stores data from TDMA register to memory location specified by a combination of base+offset provided in other TDMA registers. Supports auto-increment on offset value."

STOREREG:
    op_binary: 0x67
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    arguments:
        - name: RegAddr
          field_type: DEC
          start_bit: 0
          description: "18-bit register index aligned to 32-bit"
        - name: TdmaDataRegIndex
          field_type: DEC
          start_bit: 18
          description: "Source data register index"
    description: "Stores data from TDMA register to local RISC register space. Final register address is computed as 0xFFB0_0000 | (RegAddr<<2)"

LOADREG:
    op_binary: 0x68
    ex_resource: THCON
    instrn_type: TDMA
    src_mask: 0x0
    arguments:
        - name: RegAddr
          field_type: DEC
          start_bit: 0
          description: "32-bit register address"
        - name: TdmaDataRegIndex
          field_type: DEC
          start_bit: 18
          description: "Dest data register index"
    description: "Reserved for future use (Converted to NOP on Grayskull). Loads data local RISC register space to TDMA register"

SFPLOAD:
    op_binary: 0x70
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: &SFPU_MEM
      - name: dest_reg_addr
        field_type: DEC
        start_bit: 0
        description: dest regs addr
      - name: instr_mod0
        field_type: DEC
        start_bit: 16
        description: instruction modifier
      - name: lreg_ind
        field_type: DEC
        start_bit: 20
        description: lreg index
    description: "sFPU load from dest regs"

SFPLOADI:
    op_binary: 0x71
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: &SFPU_MEMI
      - name: imm16
        field_type: DEC
        start_bit: 0
        description: immedate op
      - name: instr_mod0
        field_type: DEC
        start_bit: 16
        description: instruction modifier
      - name: lreg_ind
        field_type: DEC
        start_bit: 20
        description: lreg index
    description: "sFPU load immediate operand in half-float format"

SFPSTORE:
    op_binary: 0x72
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MEM
    description: "sFPU store to dest"

SFPLUT:
    op_binary: 0x73
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MEM
    description: "sFPU table look-up instruction"

SFPMULI:
    op_binary: 0x74
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: &SFPU_MATHI16
      - name: instr_mod1
        field_type: DEC
        start_bit: 0
        description: instruction modifier
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        description: lreg dest index
      - name: imm16_math
        field_type: DEC
        start_bit: 8
        description: immediate 16bit operand
    description: "sFPU math instruction multiply-add with immediate operand in 12bit (exp/man) format"

SFPADDI:
    op_binary: 0x75
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI16
    description: "sFPU math instruction add with immediate 16bit operand"

SFPDIVP2:
    op_binary: 0x76
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: &SFPU_MATHI12
      - name: instr_mod1
        field_type: DEC
        start_bit: 0
        description: instruction modifier
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        description: lreg dest index
      - name: lreg_c
        field_type: DEC
        start_bit: 8
        description: lreg src_c index
      - name: imm12_math
        field_type: DEC
        start_bit: 12
        description: immediate 12bit operand
    description: "sFPU math instruction ??"

SFPEXEXP:
    op_binary: 0x77
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction extend exponent"

SFPEXMAN:
    op_binary: 0x78
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction extend mantissa"

SFPIADD:
    op_binary: 0x79
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction ???"

SFPSHFT:
    op_binary: 0x7A
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction shift"

SFPSETCC:
    op_binary: 0x7B
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction to manipulate conditional code"

SFPMOV:
    op_binary: 0x7C
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction move (imod[0]=1: invert sign)"

SFPABS:
    op_binary: 0x7D
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction absolute value"

SFPAND:
    op_binary: 0x7E
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction AND"

SFPOR:
    op_binary: 0x7F
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction OR"

SFPNOT:
    op_binary: 0x80
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction NOT"

SFPLZ:
    op_binary: 0x81
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction find leading zeros"

SFPSETEXP:
    op_binary: 0x82
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction find leading zeros"

SFPSETMAN:
    op_binary: 0x83
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction find leading zeros"

SFPMAD:
    op_binary: 0x84
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: &SFPU_MATH
      - name: instr_mod1
        field_type: DEC
        start_bit: 0
        description: instruction modifier
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        description: lreg dest index
      - name: lreg_src_c
        field_type: DEC
        start_bit: 8
        description: lreg src_c index
      - name: lreg_src_b
        field_type: DEC
        start_bit: 12
        description: lreg src_b index
      - name: lreg_src_a
        field_type: DEC
        start_bit: 16
        description: lreg src_a index
    description: "sFPU math instruction multiply-add "

SFPADD:
    op_binary: 0x85
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATH
    description: "sFPU math instruction add "

SFPMUL:
    op_binary: 0x86
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATH
    description: "sFPU math instruction multiply "

SFPPUSHC:
    op_binary: 0x87
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU instruction to push CC flag to stack"

SFPPOPC:
    op_binary: 0x88
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU instruction to pop CC flag from stack and make it active"

SFPSETSGN:
    op_binary: 0x89
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction set sign"

SFPENCC:
    op_binary: 0x8A
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction to manipulate enable/disable"

SFPCOMPC:
    op_binary: 0x8B
    ex_resource: MATH
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12
    description: "sFPU math instruction to manipulate enable/disable"

WRCFG:
    instrn_type: LOCAL_CREGS
    ex_resource: CFG
    op_binary: 0xb0
    src_mask: 0x0
    fcov:
    arguments:
        - name: CfgReg
          start_bit: 0
          field_type: DEC
          description: "configuration register address to write data to (32-bit aligned)"
        - name: wr128b
          start_bit: 15
          field_type: DEC
          description: "Do 128-bit Reg to Cfg write if set to 1"
          fcov_point_bool:
        - name: GprAddress
          start_bit: 16
          field_type: DEC
          description: "gpr address to read data from (32-bit aligned)"
    description: "Write configuration register of current thread's state with 32b data read from Gpr file"

RDCFG:
    instrn_type: LOCAL_CREGS
    ex_resource: CFG
    op_binary: 0xb1
    src_mask: 0x0
    arguments:
        - name: CfgReg
          start_bit: 0
          field_type: DEC
          description: "configuration register address to read data from (32-bit aligned)"
        - name: GprAddress
          start_bit: 16
          field_type: DEC
          description: "gpr address to write config data to (32-bit aligned)"
    description: "Read configuration register of current thread's state and write to its from Gpr file"

SETC16:
    instrn_type: LOCAL_CREGS
    ex_resource: CFG
    op_binary: 0xb2
    src_mask: 0x0
    arguments:
        - name: setc16_value
          start_bit: 0
          field_type: HEX
          description: The value to store
        - name: setc16_reg
          start_bit: 16
          field_type: HEX
          description: <register> - Register index
    description: "Sets thread specific control register <register> to the 16-bit value stored in the slot argument"

MOP:
    op_binary: 0x1
    instrn_type: COMPUTE
    src_mask: 0x0
    ex_resource: SYNC
    mop_only : 0x1
    description: "Macro-Op. Run template programmed into the MOP decoder. This instruction should never reach Tensix itself, but can only be pushed in through C kernels into MOP decoder."
    arguments:
      - name: zmask_lo16
        start_bit: 0
        field_type: HEX
        description: Low 16-bit zmask for unpacker loop
      - name: loop_count
        start_bit: 16
        field_type: HEX
        description: (loop count - 1) for unpacker loop MOP operation
      - name: mop_type
        start_bit: 23
        field_type: BIN
        description: 0 - unpack z-mask loop, 1 - double math/unpack loop

MOP_CFG:
    op_binary: 0x3
    instrn_type: COMPUTE
    src_mask: 0x0
    ex_resource: SYNC
    mop_only : 0x1
    description: "Macro-op config op. Currently used to program the top 16 bits of Z-mask for unpacker loop."
    arguments:
      - name: zmask_hi16
        start_bit: 0
        field_type: HEX
        description: High 16-bit zmask for unpacker loop


# SPDX-FileCopyrightText: Â© 2025 Tenstorrent AI ULC
#
# SPDX-License-Identifier: Apache-2.0

"""
Stage 2 Test: Input Validation

Verifies that the {{ operation_name }} operation correctly validates inputs
and raises appropriate errors for invalid inputs.
"""

import pytest
import torch
import ttnn

# NOTE: Uses the built-in `device` fixture from conftest.py - do NOT define your own.


def _get_valid_shape(tensor_info):
    """Get a valid shape for a tensor based on its requirements."""
    rank = tensor_info.get("required_rank")
    if rank == 4:
        return (1, 1, 32, 32)
    elif rank == 3:
        return (1, 32, 32)
    elif rank == 2:
        return (32, 32)
    elif rank == 1:
        return (32,)
    elif rank:
        return tuple([32] * rank)
    else:
        return (1, 1, 32, 32)  # Default 4D


def _get_layout(tensor_info):
    """Get the appropriate layout for a tensor."""
    layout = tensor_info.get("required_layout")
    if layout == "Layout::ROW_MAJOR":
        return ttnn.ROW_MAJOR_LAYOUT
    else:
        return ttnn.TILE_LAYOUT


def _create_tensor(device, tensor_info, override_shape=None, override_layout=None):
    """Create a tensor based on tensor requirements."""
    shape = override_shape or _get_valid_shape(tensor_info)
    torch_tensor = torch.randn(shape, dtype=torch.bfloat16)
    layout = override_layout or _get_layout(tensor_info)
    return ttnn.from_torch(torch_tensor, device=device, layout=layout)


# Store tensor info for helper functions
_tensor_infos = [
{% for tensor in input_tensors %}
    {
        "name": "{{ tensor.name }}",
        "cpp_name": "{{ tensor.cpp_name }}",
        {# Handle rank: extract numeric minimum from strings like ">=2", or use value directly #}
        {% if tensor.required_rank is string %}
        "required_rank": {{ tensor.required_rank | replace('>=', '') | replace('<=', '') | replace('>', '') | replace('<', '') | replace('==', '') | int }},
        {% elif tensor.required_rank is defined and tensor.required_rank is not none %}
        "required_rank": {{ tensor.required_rank }},
        {% else %}
        "required_rank": None,
        {% endif %}
        "required_layout": {{ '"{}"'.format(tensor.required_layout) if tensor.required_layout else 'None' }},
{% if tensor.shape_relative_to %}
        "shape_relative_to": "{{ tensor.shape_relative_to }}",
{% endif %}
    },
{% endfor %}
]

# Store parameter info for helper functions
_param_defaults = {
{% for param in parameters %}
{% if param.default is defined %}
    "{{ param.name }}": {{ param.default }},
{% elif param.cpp_type == "float" %}
    "{{ param.name }}": 1e-6,
{% elif param.cpp_type == "bool" %}
    "{{ param.name }}": True,
{% elif param.cpp_type == "int" or param.cpp_type == "uint32_t" %}
    "{{ param.name }}": 1,
{% else %}
    "{{ param.name }}": None,
{% endif %}
{% endfor %}
}


def _call_operation(tensors, **kwargs):
    """Call the operation with all required tensors and parameters."""
    params = {**_param_defaults, **kwargs}
    # Filter out None values
    params = {k: v for k, v in params.items() if v is not None}
    return ttnn.{{ operation_name }}({% for tensor in input_tensors %}tensors[{{ loop.index0 }}], {% endfor %}**params)


{% if input_tensors[0].required_rank %}

def test_wrong_rank_raises(device):
    """Verify wrong tensor rank raises RuntimeError."""
    # Create tensor with wrong rank (expected: {{ input_tensors[0].required_rank }}D)
{% if input_tensors[0].required_rank == 4 %}
    wrong_shape = (32, 32)  # 2D instead of 4D
{% elif input_tensors[0].required_rank == 3 %}
    wrong_shape = (32, 32)  # 2D instead of 3D
{% elif input_tensors[0].required_rank == 2 %}
    wrong_shape = (32,)  # 1D instead of 2D
{% else %}
    wrong_shape = (32,)  # Wrong rank
{% endif %}

    # Create all tensors - first one with wrong rank
    tensors = []
    for i, info in enumerate(_tensor_infos):
        if i == 0:
            tensors.append(_create_tensor(device, info, override_shape=wrong_shape))
        else:
            # For secondary tensors, use valid shape based on first tensor's valid shape
            tensors.append(_create_tensor(device, info))

    with pytest.raises(RuntimeError) as exc_info:
        _call_operation(tensors)

    # Error should mention rank
    error_msg = str(exc_info.value).lower()
    assert "rank" in error_msg or "dimension" in error_msg or "shape" in error_msg, \
        f"Error should mention rank issue, got: {exc_info.value}"
{% endif %}

{% if input_tensors[0].required_layout %}

def test_wrong_layout_raises(device):
    """Verify wrong layout raises RuntimeError."""
{% if input_tensors[0].required_layout == "Layout::ROW_MAJOR" %}
    # Operation expects ROW_MAJOR, give it TILE
    wrong_layout = ttnn.TILE_LAYOUT
{% else %}
    # Operation expects TILE, give it ROW_MAJOR
    wrong_layout = ttnn.ROW_MAJOR_LAYOUT
{% endif %}

    # Create all tensors - first one with wrong layout
    tensors = []
    for i, info in enumerate(_tensor_infos):
        if i == 0:
            tensors.append(_create_tensor(device, info, override_layout=wrong_layout))
        else:
            tensors.append(_create_tensor(device, info))

    with pytest.raises(RuntimeError) as exc_info:
        _call_operation(tensors)

    # Error should mention layout
    error_msg = str(exc_info.value).lower()
    assert "layout" in error_msg or "row_major" in error_msg or "tile" in error_msg, \
        f"Error should mention layout issue, got: {exc_info.value}"
{% endif %}


def test_valid_input_does_not_raise_validation_error(device):
    """Verify valid input passes validation (may fail later in program factory)."""
    # Create all tensors with valid configurations
    tensors = [_create_tensor(device, info) for info in _tensor_infos]

    try:
        _call_operation(tensors)
    except RuntimeError as e:
        error_msg = str(e).lower()
        # Should NOT fail on validation - if it fails, it should be in program factory
        validation_keywords = ["rank", "layout", "dtype", "dimension", "must be", "expected"]
        is_validation_error = any(kw in error_msg for kw in validation_keywords)

        # If it's a validation error, that's a test failure
        # If it's a kernel/program error, that's expected (Stage 2 doesn't require working kernels)
        if is_validation_error and "kernel" not in error_msg and "program" not in error_msg:
            pytest.fail(f"Valid input raised validation error: {e}")
        # Otherwise, non-validation errors are OK at this stage

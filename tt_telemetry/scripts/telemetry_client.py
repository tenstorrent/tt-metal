import argparse
import sys
import time
import grpc
from statistics import mean, stdev
from typing import Any, Dict

# Import generated gRPC code
# Note: These will be generated by running protoc (see docstring above)
try:
    import telemetry_service_pb2
    import telemetry_service_pb2_grpc
except ImportError:
    print("Error: Could not import generated gRPC code.")
    print("Please generate the Python code first:")
    print(
        "  python3 -m grpc_tools.protoc -I../include/server --python_out=. --grpc_python_out=. ../include/server/telemetry_service.proto"
    )
    sys.exit(1)

from utils import CommandConsole, Command, Param


class TelemetryClient:
    """Client for the TT Telemetry gRPC service."""

    def __init__(self, socket_path: str):
        """
        Initialize the client and connect to the UNIX socket.

        Args:
            socket_path: Path to the UNIX domain socket (e.g., /tmp/tt_telemetry.sock)
        """
        # For UNIX sockets, use 'unix:' prefix (not 'unix://' like in C++)
        self.target = f"unix:{socket_path}"
        self.channel = grpc.insecure_channel(self.target)
        self.stub = telemetry_service_pb2_grpc.TelemetryServiceStub(self.channel)

    def ping(self, timeout: float = 5.0) -> tuple[bool, int, int]:
        """
        Send a Ping request and measure RTT.

        Args:
            timeout: RPC timeout in seconds

        Returns:
            Tuple of (success, sent_timestamp_ms, rtt_ms)
        """
        # Get current timestamp in milliseconds
        timestamp_ms = int(time.time() * 1000)

        request = telemetry_service_pb2.PingRequest(timestamp=timestamp_ms)

        try:
            # Send the RPC with timeout
            start_time = time.time()
            response = self.stub.Ping(request, timeout=timeout)
            end_time = time.time()

            # Calculate RTT in milliseconds
            rtt_ms = int((end_time - start_time) * 1000)

            # Verify the server echoed our timestamp
            if response.timestamp == timestamp_ms:
                return True, timestamp_ms, rtt_ms
            else:
                print(f"Warning: Server did not echo timestamp correctly!")
                print(f"  Sent: {timestamp_ms}")
                print(f"  Received: {response.timestamp}")
                return False, timestamp_ms, rtt_ms

        except grpc.RpcError as e:
            print(f"RPC failed: {e.code()}: {e.details()}")
            return False, timestamp_ms, 0

    def query_metric(self, metric_name: str, timeout: float = 5.0) -> tuple[bool, str, Any]:
        """
        Query a metric by name.

        Args:
            metric_name: Name of the metric to query
            timeout: RPC timeout in seconds

        Returns:
            Tuple of (success, metric_name, value)
        """
        request = telemetry_service_pb2.QueryMetricRequest(metric_name=metric_name)

        try:
            response = self.stub.QueryMetric(request, timeout=timeout)

            # Determine which field is set in the oneof
            which = response.WhichOneof("value")
            if which == "bool_value":
                value = response.bool_value
            elif which == "uint_value":
                value = response.uint_value
            elif which == "string_value":
                value = response.string_value
            elif which == "double_value":
                value = response.double_value
            else:
                print(f"Warning: No value set in response")
                return False, metric_name, None

            return True, response.metric_name, value

        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.NOT_FOUND:
                print(f"Metric not found: {e.details()}")
            else:
                print(f"RPC failed: {e.code()}: {e.details()}")
            return False, metric_name, None

    def close(self):
        """Close the gRPC channel."""
        self.channel.close()


def ping(client: TelemetryClient, params: Dict[str, Any] | None):
    success, timestamp, rtt_ms = client.ping()
    if success:
        print(f"Ping: {rtt_ms} ms")
    else:
        print("Ping failed")


def query_metric(client: TelemetryClient, params: Dict[str, Any] | None):
    metric_name = params["metric_name"]
    success, name, value = client.query_metric(metric_name)
    if success:
        print(f"Metric: {name}")
        print(f"  Value: {value} (type: {type(value).__name__})")
    else:
        print(f"Query failed for metric: {metric_name}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="TT Telemetry gRPC Client - Ping/Pong RTT measurement")
    parser.add_argument(
        "--socket-path",
        nargs="?",
        default="/tmp/tt_telemetry.sock",
        help="Path to the UNIX domain socket (default: /tmp/tt_telemetry.sock)",
    )
    args = parser.parse_args()

    # Create telemetry RPC client
    print(f"Creating a client for telemetry server at: {args.socket_path}")
    try:
        client = TelemetryClient(args.socket_path)
    except Exception as e:
        print(f"Failed to create client: {e}")
        exit(1)

    # Run interactive console
    commands = [
        Command(
            handler=lambda params: ping(client, params),
            command="ping",
            description="Measure round-trip time to telemetry service",
        ),
        Command(
            handler=lambda params: query_metric(client, params),
            command="query",
            params=[Param(name="metric_name", type=str)],
            description="Query a metric by name",
        ),
    ]
    CommandConsole(commands=commands).run()

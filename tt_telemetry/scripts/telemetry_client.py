import argparse
import sys
import time
import grpc
from statistics import mean, stdev
from typing import Any, Dict

# Import generated gRPC code
# Note: These will be generated by running protoc (see docstring above)
try:
    import telemetry_service_pb2
    import telemetry_service_pb2_grpc
except ImportError:
    print("Error: Could not import generated gRPC code.")
    print("Please generate the Python code first:")
    print(
        "  python3 -m grpc_tools.protoc -I../include/server --python_out=. --grpc_python_out=. ../include/server/telemetry_service.proto"
    )
    sys.exit(1)

from utils import CommandConsole, Command, Param


class TelemetryClient:
    """Client for the TT Telemetry gRPC service."""

    def __init__(self, socket_path: str):
        """
        Initialize the client and connect to the UNIX socket.

        Args:
            socket_path: Path to the UNIX domain socket (e.g., /tmp/tt_telemetry.sock)
        """
        # For UNIX sockets, use 'unix:' prefix (not 'unix://' like in C++)
        self.target = f"unix:{socket_path}"
        self.channel = grpc.insecure_channel(self.target)
        self.stub = telemetry_service_pb2_grpc.TelemetryServiceStub(self.channel)

    def ping(self, timeout: float = 5.0) -> tuple[bool, int, int]:
        """
        Send a Ping request and measure RTT.

        Args:
            timeout: RPC timeout in seconds

        Returns:
            Tuple of (success, sent_timestamp_ms, rtt_ms)
        """
        # Get current timestamp in milliseconds
        timestamp_ms = int(time.time() * 1000)

        request = telemetry_service_pb2.PingRequest(timestamp=timestamp_ms)

        try:
            # Send the RPC with timeout
            start_time = time.time()
            response = self.stub.Ping(request, timeout=timeout)
            end_time = time.time()

            # Calculate RTT in milliseconds
            rtt_ms = int((end_time - start_time) * 1000)

            # Verify the server echoed our timestamp
            if response.timestamp == timestamp_ms:
                return True, timestamp_ms, rtt_ms
            else:
                print(f"Warning: Server did not echo timestamp correctly!")
                print(f"  Sent: {timestamp_ms}")
                print(f"  Received: {response.timestamp}")
                return False, timestamp_ms, rtt_ms

        except grpc.RpcError as e:
            print(f"RPC failed: {e.code()}: {e.details()}")
            return False, timestamp_ms, 0

    def close(self):
        """Close the gRPC channel."""
        self.channel.close()


def ping(client: TelemetryClient, params: Dict[str, Any] | None):
    success, timestamp, rtt_ms = client.ping()
    if success:
        print(f"Ping: {rtt_ms} ms")
    else:
        print("Ping failed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="TT Telemetry gRPC Client - Ping/Pong RTT measurement")
    parser.add_argument(
        "--socket-path",
        nargs="?",
        default="/tmp/tt_telemetry.sock",
        help="Path to the UNIX domain socket (default: /tmp/tt_telemetry.sock)",
    )
    args = parser.parse_args()

    # Create telemetry RPC client
    print(f"Creating a client for telemetry server at: {args.socket_path}")
    try:
        client = TelemetryClient(args.socket_path)
    except Exception as e:
        print(f"Failed to create client: {e}")
        exit(1)

    # Run interactive console
    commands = [
        Command(
            handler=lambda params: ping(client, params),
            command="ping",
            description="Measure round-trip time to telemetry service",
        ),
    ]
    CommandConsole(commands=commands).run()

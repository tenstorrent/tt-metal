#!/usr/bin/env python3

# SPDX-FileCopyrightText: Â© 2025 Tenstorrent AI ULC
#
# SPDX-License-Identifier: Apache-2.0

"""
telemetry_client.py

Example Python client for the TT Telemetry gRPC service.
Demonstrates how to connect to the UNIX domain socket and use the Ping/Pong service
to measure round-trip time (RTT).

Usage:
    python3 telemetry_client.py [socket_path]

Before running:
    1. Generate Python gRPC code from the proto file:
       python3 -m grpc_tools.protoc -I../include/server --python_out=. --grpc_python_out=. ../include/server/telemetry_service.proto

    2. Ensure the telemetry server is running in collector mode
"""

import argparse
import sys
import time
import grpc
from statistics import mean, stdev

# Import generated gRPC code
# Note: These will be generated by running protoc (see docstring above)
try:
    import telemetry_service_pb2
    import telemetry_service_pb2_grpc
except ImportError:
    print("Error: Could not import generated gRPC code.")
    print("Please generate the Python code first:")
    print(
        "  python3 -m grpc_tools.protoc -I../include/server --python_out=. --grpc_python_out=. ../include/server/telemetry_service.proto"
    )
    sys.exit(1)


class TelemetryClient:
    """Client for the TT Telemetry gRPC service."""

    def __init__(self, socket_path: str):
        """
        Initialize the client and connect to the UNIX socket.

        Args:
            socket_path: Path to the UNIX domain socket (e.g., /tmp/tt_telemetry.sock)
        """
        # For UNIX sockets, use 'unix:' prefix (not 'unix://' like in C++)
        self.target = f"unix:{socket_path}"
        self.channel = grpc.insecure_channel(self.target)
        self.stub = telemetry_service_pb2_grpc.TelemetryServiceStub(self.channel)

    def ping(self, timeout: float = 5.0) -> tuple[bool, int, int]:
        """
        Send a Ping request and measure RTT.

        Args:
            timeout: RPC timeout in seconds

        Returns:
            Tuple of (success, sent_timestamp_ms, rtt_ms)
        """
        # Get current timestamp in milliseconds
        timestamp_ms = int(time.time() * 1000)

        request = telemetry_service_pb2.PingRequest(timestamp=timestamp_ms)

        try:
            # Send the RPC with timeout
            start_time = time.time()
            response = self.stub.Ping(request, timeout=timeout)
            end_time = time.time()

            # Calculate RTT in milliseconds
            rtt_ms = int((end_time - start_time) * 1000)

            # Verify the server echoed our timestamp
            if response.timestamp == timestamp_ms:
                return True, timestamp_ms, rtt_ms
            else:
                print(f"Warning: Server did not echo timestamp correctly!")
                print(f"  Sent: {timestamp_ms}")
                print(f"  Received: {response.timestamp}")
                return False, timestamp_ms, rtt_ms

        except grpc.RpcError as e:
            print(f"RPC failed: {e.code()}: {e.details()}")
            return False, timestamp_ms, 0

    def close(self):
        """Close the gRPC channel."""
        self.channel.close()


def main():
    parser = argparse.ArgumentParser(description="TT Telemetry gRPC Client - Ping/Pong RTT measurement")
    parser.add_argument(
        "socket_path",
        nargs="?",
        default="/tmp/tt_telemetry.sock",
        help="Path to the UNIX domain socket (default: /tmp/tt_telemetry.sock)",
    )
    parser.add_argument("-n", "--num-pings", type=int, default=10, help="Number of pings to send (default: 10)")
    parser.add_argument("-d", "--delay", type=float, default=0.1, help="Delay between pings in seconds (default: 0.1)")

    args = parser.parse_args()

    print(f"Connecting to telemetry server at: {args.socket_path}")

    try:
        client = TelemetryClient(args.socket_path)
    except Exception as e:
        print(f"Failed to create client: {e}")
        return 1

    print(f"\nSending {args.num_pings} pings...")

    results = []
    successful = 0

    for i in range(args.num_pings):
        success, timestamp, rtt_ms = client.ping()

        if success:
            successful += 1
            results.append(rtt_ms)
            print(f"  Ping {i+1}: {rtt_ms} ms")
        else:
            print(f"  Ping {i+1}: FAILED")

        # Delay between pings (except after the last one)
        if i < args.num_pings - 1:
            time.sleep(args.delay)

    # Print statistics
    print(f"\nResults:")
    print(f"  Successful: {successful}/{args.num_pings}")

    if results:
        avg_rtt = mean(results)
        min_rtt = min(results)
        max_rtt = max(results)

        print(f"  Average RTT: {avg_rtt:.2f} ms")
        print(f"  Min RTT: {min_rtt} ms")
        print(f"  Max RTT: {max_rtt} ms")

        if len(results) > 1:
            std_rtt = stdev(results)
            print(f"  Std Dev: {std_rtt:.2f} ms")

    client.close()

    return 0 if successful == args.num_pings else 1


if __name__ == "__main__":
    sys.exit(main())

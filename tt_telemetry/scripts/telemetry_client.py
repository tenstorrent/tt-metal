import argparse
import sys
import time
import grpc
from statistics import mean, stdev
from typing import Any, Dict

# Import generated gRPC code
# Note: These will be generated by running protoc (see docstring above)
try:
    import telemetry_service_pb2
    import telemetry_service_pb2_grpc
except ImportError:
    print("Error: Could not import generated gRPC code.")
    print("Please generate the Python code first:")
    print(
        "  python3 -m grpc_tools.protoc -I../include/server --python_out=. --grpc_python_out=. ../include/server/telemetry_service.proto"
    )
    sys.exit(1)

from utils import CommandConsole, Command, Param


class TelemetryClient:
    """Client for the TT Telemetry gRPC service."""

    def __init__(self, socket_path: str):
        """
        Initialize the client and connect to the UNIX socket.

        Args:
            socket_path: Path to the UNIX domain socket (e.g., /tmp/tt_telemetry.sock)
        """
        # For UNIX sockets, use 'unix:' prefix (not 'unix://' like in C++)
        self.target = f"unix:{socket_path}"
        self.channel = grpc.insecure_channel(self.target)
        self.stub = telemetry_service_pb2_grpc.TelemetryServiceStub(self.channel)

    def ping(self, timeout: float = 5.0) -> tuple[bool, int, int]:
        """
        Send a Ping request and measure RTT.

        Args:
            timeout: RPC timeout in seconds

        Returns:
            Tuple of (success, sent_timestamp_ms, rtt_ms)
        """
        # Get current timestamp in milliseconds
        timestamp_ms = int(time.time() * 1000)

        request = telemetry_service_pb2.PingRequest(timestamp=timestamp_ms)

        try:
            # Send the RPC with timeout
            start_time = time.time()
            response = self.stub.Ping(request, timeout=timeout)
            end_time = time.time()

            # Calculate RTT in milliseconds
            rtt_ms = int((end_time - start_time) * 1000)

            # Verify the server echoed our timestamp
            if response.timestamp == timestamp_ms:
                return True, timestamp_ms, rtt_ms
            else:
                print(f"Warning: Server did not echo timestamp correctly!")
                print(f"  Sent: {timestamp_ms}")
                print(f"  Received: {response.timestamp}")
                return False, timestamp_ms, rtt_ms

        except grpc.RpcError as e:
            print(f"RPC failed: {e.code()}: {e.details()}")
            return False, timestamp_ms, 0

    def query_metric(self, metric_query: str, timeout: float = 5.0) -> tuple[bool, list[dict]]:
        """
        Query a metric by name.

        Args:
            metric_query: Name of the metric to query
            timeout: RPC timeout in seconds

        Returns:
            Tuple of (success, results) where results is a list of dicts with keys:
            'path', 'timestamp', 'value', 'type'
        """
        request = telemetry_service_pb2.QueryMetricRequest(metric_query=metric_query)

        try:
            response = self.stub.QueryMetric(request, timeout=timeout)

            results = []

            # Process bool results
            for result in response.bool_results:
                results.append(
                    {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "bool"}
                )

            # Process uint results
            for result in response.uint_results:
                results.append(
                    {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "uint64"}
                )

            # Process double results
            for result in response.double_results:
                results.append(
                    {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "double"}
                )

            # Process string results
            for result in response.string_results:
                results.append(
                    {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "string"}
                )

            if not results:
                print(f"Warning: No results in response")
                return False, []

            return True, results

        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.NOT_FOUND:
                print(f"Error: {e.details()}")
            else:
                print(f"RPC failed: {e.code()}: {e.details()}")
            return False, []

    def list_metrics(self, metric_query: str = "", timeout: float = 5.0) -> tuple[bool, dict]:
        """
        List all known metric paths grouped by type.

        Args:
            metric_query: Optional query string to filter metrics (empty = all metrics)
            timeout: RPC timeout in seconds

        Returns:
            Tuple of (success, metrics_dict) where metrics_dict has keys:
            'bool_metrics', 'uint_metrics', 'double_metrics', 'string_metrics'
        """
        request = telemetry_service_pb2.ListMetricsRequest(metric_query=metric_query)

        try:
            response = self.stub.ListMetrics(request, timeout=timeout)

            metrics = {
                "bool_metrics": list(response.bool_metrics),
                "uint_metrics": list(response.uint_metrics),
                "double_metrics": list(response.double_metrics),
                "string_metrics": list(response.string_metrics),
            }

            return True, metrics

        except grpc.RpcError as e:
            print(f"RPC failed: {e.code()}: {e.details()}")
            return False, {}

    def stream_metrics(self, metric_query: str = "", timeout: float = None):
        """
        Stream telemetry updates matching a query.

        Args:
            metric_query: Query string for metrics to stream (empty = all metrics)
            timeout: RPC timeout in seconds (None = no timeout)

        Yields:
            List of dicts with keys: 'path', 'timestamp', 'value', 'type'
        """
        request = telemetry_service_pb2.QueryMetricRequest(metric_query=metric_query)

        try:
            for update in self.stub.StreamMetrics(request, timeout=timeout):
                results = []

                # Process bool results
                for result in update.bool_results:
                    results.append(
                        {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "bool"}
                    )

                # Process uint results
                for result in update.uint_results:
                    results.append(
                        {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "uint64"}
                    )

                # Process double results
                for result in update.double_results:
                    results.append(
                        {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "double"}
                    )

                # Process string results
                for result in update.string_results:
                    results.append(
                        {"path": result.path, "timestamp": result.timestamp, "value": result.value, "type": "string"}
                    )

                yield results

        except grpc.RpcError as e:
            print(f"Stream failed: {e.code()}: {e.details()}")
            return

    def close(self):
        """Close the gRPC channel."""
        self.channel.close()


def ping(client: TelemetryClient, params: Dict[str, Any] | None):
    success, timestamp, rtt_ms = client.ping()
    if success:
        print(f"Ping: {rtt_ms} ms")
    else:
        print("Ping failed")


def get_metric(client: TelemetryClient, params: Dict[str, Any] | None):
    metric_query = params["metric_query"]
    success, results = client.query_metric(metric_query)
    if success:
        print(f"Query results for '{metric_query}':")
        for i, result in enumerate(results, 1):
            print(f"  Result {i}:")
            print(f"    Path:      {result['path']}")
            print(f"    Type:      {result['type']}")
            print(f"    Value:     {result['value']}")
            print(f"    Timestamp: {result['timestamp']}")
    else:
        print(f"Query failed for metric: {metric_query}")


def list_metrics(client: TelemetryClient, params: Dict[str, Any] | None):
    metric_query = params.get("metric_query", "") if params else ""
    success, metrics = client.list_metrics(metric_query)
    if success:
        total = sum(len(v) for v in metrics.values())
        if metric_query:
            print(f"Found {total} total metrics matching '{metric_query}':")
        else:
            print(f"Found {total} total metrics:")

        if metrics["bool_metrics"]:
            print(f"\nBool metrics ({len(metrics['bool_metrics'])}):")
            for path in sorted(metrics["bool_metrics"]):
                print(f"  {path}")

        if metrics["uint_metrics"]:
            print(f"\nUint metrics ({len(metrics['uint_metrics'])}):")
            for path in sorted(metrics["uint_metrics"]):
                print(f"  {path}")

        if metrics["double_metrics"]:
            print(f"\nDouble metrics ({len(metrics['double_metrics'])}):")
            for path in sorted(metrics["double_metrics"]):
                print(f"  {path}")

        if metrics["string_metrics"]:
            print(f"\nString metrics ({len(metrics['string_metrics'])}):")
            for path in sorted(metrics["string_metrics"]):
                print(f"  {path}")
    else:
        print("Failed to list metrics")


def stream_metrics(client: TelemetryClient, params: Dict[str, Any] | None):
    metric_query = params.get("metric_query", "") if params else ""
    print(f"Streaming metrics matching '{metric_query if metric_query else 'all'}'...")
    print("Press Ctrl+C to stop streaming\n")

    try:
        update_count = 0
        for results in client.stream_metrics(metric_query):
            if results:
                update_count += 1
                print(f"--- Update {update_count} ---")
                for result in results:
                    print(f"  {result['path']}: {result['value']} ({result['type']})")
                print()
    except KeyboardInterrupt:
        print("\nStream stopped by user")
    except Exception as e:
        print(f"Stream error: {e}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="TT Telemetry gRPC Client - Ping/Pong RTT measurement")
    parser.add_argument(
        "--socket-path",
        nargs="?",
        default="/tmp/tt_telemetry.sock",
        help="Path to the UNIX domain socket (default: /tmp/tt_telemetry.sock)",
    )
    args = parser.parse_args()

    # Create telemetry RPC client
    print(f"Creating a client for telemetry server at: {args.socket_path}")
    try:
        client = TelemetryClient(args.socket_path)
    except Exception as e:
        print(f"Failed to create client: {e}")
        exit(1)

    # Run interactive console
    commands = [
        Command(
            handler=lambda params: ping(client, params),
            command="ping",
            description="Measure round-trip time to telemetry service",
        ),
        Command(
            handler=lambda params: list_metrics(client, params),
            command="list",
            params=[Param(name="metric_query", type=str, default="")],
            description="List all known metric paths grouped by type",
        ),
        Command(
            handler=lambda params: get_metric(client, params),
            command="get",
            params=[Param(name="metric_query", type=str, default="")],
            description="Get metric(s) by query string",
        ),
        Command(
            handler=lambda params: stream_metrics(client, params),
            command="stream",
            params=[Param(name="metric_query", type=str, default="")],
            description="Stream metric updates",
        ),
    ]
    CommandConsole(commands=commands).run()

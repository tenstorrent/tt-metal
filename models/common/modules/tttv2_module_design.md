Code design points:
- One key design point is that the codegen template should be real python function that are "converted" into source like @codegen_attention.py (203) . Use this idea to change @codegen_mlp.py
 - @codegen_mlp.py (138-139) the template function should be a proper runnable function in the spirit of functional programming! So, `self` seems out of place. I like the previous signature --- `(x, ops_config, activation_config)` better
- Another design point is to have minimal if-else in template function like @codegen_mlp.py (133-134) (only except for now is the input dependent if-else such as if x.shape[0] > 1024). All "static" conditional if-else (static as in the conditional could be evaluated before running the model) should be put inside the generator code.
    - each ttnn op (e.g., ttnn.linear) can have different configs and dtype should be part of that config as well
- @codegen_mlp.py (296) one design point is to have tttv2 code NOT dependent on torch. So, replace nn.Module with LightweightModule
- Fractal design. @codegen_mlp.py (159-160) Another design point -- fractal view into model in all aspects. For example, a LLM model is the top level view of a model architecture; it has multiple layers at the next level and each layer has lower-level components as well. Instead of exposing, say configs of all the lower-level components at the layer level or even the LLM model level, the code should have a object instead that "gloss" over the lower-level details. Of course, the LLM model developer could overwrite any lower-level details through this object (so all the detailed of this object should be very discoverable by design).  But by default, the developer could easily stay at any level detail with single object covering all the lower-level components.
  - it made sense to Gemini 3 Pro: Yes, that makes perfect sense. This design pattern (often referred to as "hierarchical configuration" or "configuration objects") allows for clean abstraction layers where high-level users see a simple interface ("gloss over"), while power users can drill down ("fractal view") into specific component configurations without cluttering the top-level API.
- Design point about weight loading besides what is laid out in tttv2_design_proposal.md: loading reference model weights should happen before opening the TT device. --> this is unfortunately not the case right now with TTTv1 demo codes.

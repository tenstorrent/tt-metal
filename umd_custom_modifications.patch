diff --git a/device/chip/local_chip.cpp b/device/chip/local_chip.cpp
index 7f97071a..d8112a62 100644
--- a/device/chip/local_chip.cpp
+++ b/device/chip/local_chip.cpp
@@ -189,19 +189,24 @@ bool LocalChip::is_mmio_capable() const { return true; }
 void LocalChip::start_device() {
     if (tt_device_->get_communication_device_type() == IODeviceType::JTAG) {
         return;
-    }
+        }

     // TODO: acquire mutex should live in Chip class. Currently we don't have unique id for all chips.
     // The lock here should suffice since we have to open Local chip to have Remote chips initialized.
-    chip_started_lock_.emplace(acquire_mutex(MutexType::CHIP_IN_USE, tt_device_->get_pci_device()->get_device_num()));
-
-    check_pcie_device_initialized();
-    sysmem_manager_->pin_or_map_sysmem_to_device();
-    if (!tt_device_->get_pci_device()->is_mapping_buffer_to_noc_supported()) {
-        // If this is supported by the newer KMD, UMD doesn't have to program the iatu.
-        init_pcie_iatus();
+    // Acquire CHIP_IN_USE lock to prevent concurrent initialization, but release it after initialization completes.
+    // This allows multiple processes to query device info and use the chip after initialization.
+    {
+        auto chip_init_lock = acquire_mutex(MutexType::CHIP_IN_USE, tt_device_->get_pci_device()->get_device_num());
+
+        check_pcie_device_initialized();
+        sysmem_manager_->pin_or_map_sysmem_to_device();
+        if (!tt_device_->get_pci_device()->is_mapping_buffer_to_noc_supported()) {
+            // If this is supported by the newer KMD, UMD doesn't have to program the iatu.
+            init_pcie_iatus();
+        }
+        initialize_membars();
+        // Lock is automatically released when chip_init_lock goes out of scope here
     }
-    initialize_membars();
 }

 void LocalChip::close_device() {
diff --git a/device/coordinates/blackhole_coordinate_manager.cpp b/device/coordinates/blackhole_coordinate_manager.cpp
index 82020f52..608da27a 100644
--- a/device/coordinates/blackhole_coordinate_manager.cpp
+++ b/device/coordinates/blackhole_coordinate_manager.cpp
@@ -53,12 +53,12 @@ void BlackholeCoordinateManager::assert_coordinate_manager_constructor() {

     const size_t num_harvested_eth_cores = get_num_harvested(harvesting_masks.eth_harvesting_mask);
     // If we're running on full grid, exactly 2 or all ETH cores should be harvested.
-    if (eth_cores.size() == blackhole::NUM_ETH_CHANNELS && num_harvested_eth_cores != 2 &&
-        num_harvested_eth_cores != blackhole::NUM_ETH_CHANNELS) {
-        throw std::runtime_error(
-            "Exactly 2 or " + std::to_string(blackhole::NUM_ETH_CHANNELS) +
-            " ETH cores should be harvested on full Blackhole");
-    }
+    // if (eth_cores.size() == blackhole::NUM_ETH_CHANNELS && num_harvested_eth_cores != 2 &&
+    //     num_harvested_eth_cores != blackhole::NUM_ETH_CHANNELS) {
+    //     throw std::runtime_error(
+    //         "Exactly 2 or " + std::to_string(blackhole::NUM_ETH_CHANNELS) +
+    //         " ETH cores should be harvested on full Blackhole");
+    // }
 }

 void BlackholeCoordinateManager::translate_tensix_coords() {

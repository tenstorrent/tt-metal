name: "Git bisect dispatch"

on:
  workflow_dispatch:
    inputs:
      arch:
        required: true
        type: choice
        options:
          - wormhole_b0
          - blackhole
      tracy:
        required: true
        type: boolean
        default: false
        description: "Build with tracy enabled"
      nd-mode:
        required: true
        type: boolean
        default: false
        description: "Enable non-deterministic detection mode"
      runner-label:
        required: true
        type: choice
        options:
          - N150
          - N300
          - P150
          - config-t3000
          - config-tg
          - topology-6u
          - config-t3000
        description: "Runner Type Label"
      good-commit:
        required: true
        type: string
      bad-commit:
        required: true
        type: string
      command:
        required: false
        type: string
        default: ""
        description: "Test command to run (not needed if gist-url is provided)"
      timeout:
        required: true
        type: string
        description: "Timeout for one iteration (eg: 5m, 1h)"
      retries:
        required: false
        type: string
        default: "3"
        description: "Number of retries (default 3)"
      gist-url:
        required: false
        type: string
        default: ""
        description: "Optional GitHub gist URL for a .sh script to run instead of command"
run-name: "Bisect on ${{ inputs.runner-label }}"
jobs:
  test-dispatch:
    timeout-minutes: 1440
    runs-on: >-
      ${{
        fromJSON(format('["{0}", "in-service", "cloud-virtual-machine"]', inputs.runner-label))
        || format('tt-ubuntu-2204-{0}-viommu-stable', inputs.runner-label)
      }}
    container:
      image: ghcr.io/tenstorrent/tt-metal/tt-metalium/ubuntu-22.04-dev-amd64:latest
      env:
        ARCH_NAME: ${{ inputs.arch }}
        LOGURU_LEVEL: DEBUG
        PYTHONPATH: /work
        LD_LIBRARY_PATH: /work/build/lib
        GTEST_OUTPUT: xml:/work/generated/test_reports/
        TT_METAL_HOME: /work
        PYTHONFAULTHANDLER: 1       # prints Python stack trace on segfault
        PYTHONMALLOC: debug         # adds checks, helps catch memory issues
        CCACHE_REMOTE_ONLY: "true"
        CCACHE_TEMPDIR: /tmp/ccache
        CARGO_HOME: /tmp/.cargo
        TT_FROM_PRECOMPILED_DIR: /work
        # TODO: Revisit the addition of these env vars https://github.com/tenstorrent/tt-metal/issues/20161
        TRACY_NO_INVARIANT_CHECK: 1
        TRACY_NO_ISA_EXTENSIONS: 1
      volumes:
        - ${{ github.workspace }}/docker-job:/work # Subdir to workaround https://github.com/actions/runner/issues/691
        - /dev/hugepages-1G:/dev/hugepages-1G
        - /home/ubuntu/.ccache-ci:/github/home/.ccache # HOME is hardcoded for no clear reason: https://github.com/actions/runner/issues/863
        - /mnt/MLPerf:/mnt/MLPerf:ro
      options: >
        --device /dev/tenstorrent
        --group-add 1457
        --tmpfs /tmp
    defaults:
      run:
        shell: bash
        working-directory: /work # https://github.com/actions/runner/issues/878
    steps:
      - name: Check Redis credentials
        # Failing internal jobs draws attention immediately so we can fix them and make them fast.
        # Forks will never have secrets; don't fail the job for them, they'll just run slower
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        run: |
          if [ -z "${{ secrets.REDIS_PASSWORD }}" ]; then
            echo "Redis password is missing. Did you forget 'secrets: inherit'?"
            exit 1
          fi
          # Conditionally set this here so that it remains unset on forks, otherwise it resolves an invalid URL and the job fails
          CCACHE_REMOTE_STORAGE="redis://${{ vars.REDIS_USER }}:${{ secrets.REDIS_PASSWORD }}@${{ vars.REDIS_HOST }}:${{ vars.REDIS_PORT }}|read-only=${{ vars.REDIS_IS_READONLY }}"
          echo "CCACHE_REMOTE_STORAGE=${CCACHE_REMOTE_STORAGE}" >> $GITHUB_ENV
          echo "CCACHE_REMOTE_STORAGE: ${CCACHE_REMOTE_STORAGE}"

      - name: ⬇️  Setup Job
        uses: tenstorrent/tt-metal/.github/actions/setup-job@5b5c6ff5b54025e165d189371cda93d2b9ef6115
        timeout-minutes: 10
        with:
          fetch-depth: 0

      - name: Download Gist Script
        if: ${{ inputs.gist-url != '' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Downloading gist from ${{ inputs.gist-url }}"
          GIST_URL="${{ inputs.gist-url }}"

          # Extract gist ID and filename from various URL formats
          if [[ "$GIST_URL" =~ gist\.github\.com/([^/]+)/([a-f0-9]+) ]]; then
            # Regular gist URL: https://gist.github.com/username/gist_id
            GIST_USER="${BASH_REMATCH[1]}"
            GIST_ID="${BASH_REMATCH[2]}"
            # Get the filename from the end of URL if present, otherwise use default
            if [[ "$GIST_URL" =~ /([^/]+\.sh)$ ]]; then
              FILENAME="${BASH_REMATCH[1]}"
            else
              FILENAME=""
            fi
          elif [[ "$GIST_URL" =~ gist\.githubusercontent\.com/([^/]+)/([a-f0-9]+)/raw/[^/]+/(.+\.sh)$ ]]; then
            # Raw gist URL with revision: https://gist.githubusercontent.com/username/gist_id/raw/revision/filename.sh
            GIST_USER="${BASH_REMATCH[1]}"
            GIST_ID="${BASH_REMATCH[2]}"
            FILENAME="${BASH_REMATCH[3]}"
          elif [[ "$GIST_URL" =~ gist\.githubusercontent\.com/([^/]+)/([a-f0-9]+)/raw/(.+\.sh)$ ]]; then
            # Raw gist URL without revision: https://gist.githubusercontent.com/username/gist_id/raw/filename.sh
            GIST_USER="${BASH_REMATCH[1]}"
            GIST_ID="${BASH_REMATCH[2]}"
            FILENAME="${BASH_REMATCH[3]}"
          else
            echo "ERROR: Could not parse gist URL format"
            exit 1
          fi

          # Construct the raw URL without revision hash to always get latest
          if [ -n "$FILENAME" ]; then
            RAW_URL="https://gist.githubusercontent.com/${GIST_USER}/${GIST_ID}/raw/${FILENAME}"
          else
            # If no filename, try to get the first .sh file
            RAW_URL="https://gist.githubusercontent.com/${GIST_USER}/${GIST_ID}/raw"
          fi

          echo "Fetching from: $RAW_URL"
          curl -fsSL "$RAW_URL" -o /work/bisect_gist_script.sh
          chmod +x /work/bisect_gist_script.sh
          echo "Gist script downloaded and made executable"

      - name: Run Git Bisect
        shell: bash
        env:
          GIT_COMMITTER_NAME: "GitHub Actions"
          GIT_COMMITTER_EMAIL: "actions@github.com"
        run: |
          set -euo pipefail
          trap 'rm -rf ./build_bisect' EXIT
          mkdir -p ./build_bisect
          cp ./tests/scripts/tt_bisect.sh ./build_bisect/
          chmod +x ./build_bisect/tt_bisect.sh

          # Determine which script to run
          SCRIPT_PATH=""
          if [[ -n "${{ inputs.gist-url }}" ]]; then
            SCRIPT_PATH="/work/bisect_gist_script.sh"
          elif [[ -n "${{ inputs.command }}" ]]; then
            # Write command to a temporary script to avoid quoting issues
            cat > /work/bisect_command_script.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail
          ${{ inputs.command }}
          EOF
            chmod +x /work/bisect_command_script.sh
            SCRIPT_PATH="/work/bisect_command_script.sh"
          fi

          # Build arguments in an array to avoid empty string issues
          declare -a bisect_args
          bisect_args+=(-t "${{ inputs.timeout }}")
          bisect_args+=(-b "${{ inputs.bad-commit }}")
          bisect_args+=(-g "${{ inputs.good-commit }}")
          bisect_args+=(-r "${{ inputs.retries }}")

          if [[ "${{ inputs.tracy }}" == 'true' ]]; then
            bisect_args+=(-p)
          fi
          if [[ "${{ inputs.nd-mode }}" == 'true' ]]; then
            bisect_args+=(-n)
          fi

          bisect_args+=(-s "$SCRIPT_PATH")

          # Run bisect with clean, properly quoted arguments
          ./build_bisect/tt_bisect.sh "${bisect_args[@]}"

      - name: Upload ND results CSV
        if: ${{ hashFiles('docker-job/bisect_nd_results.csv') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: bisect-nd-results
          path: docker-job/bisect_nd_results.csv
          if-no-files-found: ignore

name: "Git bisect dispatch"

on:
  workflow_dispatch:
    inputs:
      tracy:
        required: true
        type: boolean
        default: true
        description: "Build with tracy enabled"
      nd-mode:
        required: true
        type: boolean
        default: false
        description: "Enable non-deterministic detection mode"
      runner-label:
        required: true
        type: choice
        options:
          - N150
          - N300
          - P150
          - P100
          - config-t3000
          - BH-LoudBox
          - topology-6u
        description: "Runner Type Label"
      search-mode:
        required: true
        type: boolean
        default: false
        description: "Search for failure boundary automatically (goes back in time: 1 day, 2 days, 4 days, etc.)"
      commit-range:
        required: false
        type: string
        description: "Good and bad commits (format: good,bad, e.g., abc1234,def5678). Required if search-mode is false."
      start-commit:
        required: false
        type: string
        default: ""
        description: "Starting commit for search mode (default: HEAD). This is the known-bad commit to search backward from."
      test-script:
        required: true
        type: string
        description: "GitHub gist URL (e.g., https://gist.github.com/user/id) or inline command to run"
      timeout:
        required: true
        type: string
        default: "30"
        description: "Timeout for each test run in minutes (positive integer only)"
      attempts:
        required: true
        type: string
        default: "auto"
        description: "Number of retry attempts for each test run. Use 'auto' to determine by running until failure (3x attempts needed)"
      download-artifacts:
        required: false
        type: boolean
        default: true
        description: "Download artifacts from GitHub for each commit (requires gh cli to be authenticated)"
      skip-commits:
        required: false
        type: string
        default: ""
        description: "Comma-separated list of commits to automatically skip (e.g., abc123,def456)"

permissions:
  actions: write
  contents: write

run-name: "Bisect on ${{ inputs.runner-label }}"
jobs:
  determine-runner-config:
    runs-on: ubuntu-latest
    outputs:
      runs-on-labels: ${{ steps.config.outputs.runs-on-labels }}
      arch-name: ${{ steps.config.outputs.arch-name }}
    steps:
      - id: config
        shell: bash
        run: |
          RUNNER_LABEL="${{ inputs.runner-label }}"

          # Determine runs-on labels based on runner type

          if [[ "$RUNNER_LABEL" == "topology-6u" ]] || [[ "$RUNNER_LABEL" == "BH-LoudBox" ]]; then
            # Galaxy/topology-6u runners and BH-LoudBox require bare-metal (not cloud-virtual-machine)
            RUNS_ON='["'$RUNNER_LABEL'", "in-service", "bare-metal"]'
          elif [[ "$RUNNER_LABEL" =~ ^(N150|N300|P150|P100|config-t3000)$ ]]; then
            # Standard single-card runners use cloud-virtual-machine
            RUNS_ON='["'$RUNNER_LABEL'", "in-service", "cloud-virtual-machine"]'
          else
            # Fallback to viommu-stable format (output as JSON array)
            echo "Warning: unexpected runner label '$RUNNER_LABEL'; using fallback VIOMMU label." >&2
            VIOMMU_LABEL='tt-ubuntu-2204-'$RUNNER_LABEL'-viommu-stable'
            RUNS_ON='["'$VIOMMU_LABEL'"]'
          fi

          # Determine architecture name based on runner type
          if [[ "$RUNNER_LABEL" =~ ^(N150|N300|config-t3000|topology-6u)$ ]] || [[ "$RUNNER_LABEL" == *"wormhole_b0"* ]]; then
            ARCH_NAME="wormhole_b0"
          else
            ARCH_NAME="blackhole"
          fi

          echo "runs-on-labels=$RUNS_ON" >> $GITHUB_OUTPUT
          echo "arch-name=$ARCH_NAME" >> $GITHUB_OUTPUT
          echo "Determined runs-on: $RUNS_ON"
          echo "Determined arch: $ARCH_NAME"

  test-dispatch:
    needs: determine-runner-config
    timeout-minutes: 1440
    runs-on: ${{ fromJSON(needs.determine-runner-config.outputs.runs-on-labels) }}
    container:
      image: ghcr.io/tenstorrent/tt-metal/tt-metalium/ubuntu-22.04-dev-amd64:latest
      env:
        GH_TOKEN: ${{ github.token }}
        ARCH_NAME: ${{ needs.determine-runner-config.outputs.arch-name }}
        LOGURU_LEVEL: DEBUG
        PYTHONPATH: /work:/work/ttnn:/work/tools
        LD_LIBRARY_PATH: /work/build/lib
        GTEST_OUTPUT: xml:/work/generated/test_reports/
        TT_METAL_HOME: /work
        PYTHONFAULTHANDLER: 1       # prints Python stack trace on segfault
        PYTHONMALLOC: debug         # adds checks, helps catch memory issues
        CCACHE_REMOTE_ONLY: "true"
        CCACHE_TEMPDIR: /tmp/ccache
        # TODO: Revisit the addition of these env vars https://github.com/tenstorrent/tt-metal/issues/20161
        TRACY_NO_INVARIANT_CHECK: 1
        TRACY_NO_ISA_EXTENSIONS: 1
      volumes:
        - ${{ github.workspace }}/docker-job:/work # Subdir to workaround https://github.com/actions/runner/issues/691
        - /dev/hugepages-1G:/dev/hugepages-1G
        - /home/ubuntu/.ccache-ci:/github/home/.ccache # HOME is hardcoded for no clear reason: https://github.com/actions/runner/issues/863
        - /mnt/MLPerf:/mnt/MLPerf:ro
      options: >
        --device /dev/tenstorrent
        --group-add 1457
        --tmpfs /tmp
    defaults:
      run:
        shell: bash
        working-directory: /work # https://github.com/actions/runner/issues/878
    steps:
      - name: Check Redis credentials
        # Failing internal jobs draws attention immediately so we can fix them and make them fast.
        # Forks will never have secrets; don't fail the job for them, they'll just run slower
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        run: |
          if [ -z "${{ secrets.REDIS_PASSWORD }}" ]; then
            echo "Redis password is missing. Did you forget 'secrets: inherit'?"
            exit 1
          fi
          # Conditionally set this here so that it remains unset on forks, otherwise it resolves an invalid URL and the job fails
          CCACHE_REMOTE_STORAGE="redis://${{ vars.REDIS_USER }}:${{ secrets.REDIS_PASSWORD }}@${{ vars.REDIS_HOST }}:${{ vars.REDIS_PORT }}|read-only=${{ vars.REDIS_IS_READONLY }}"
          echo "CCACHE_REMOTE_STORAGE=${CCACHE_REMOTE_STORAGE}" >> $GITHUB_ENV
          echo "CCACHE_REMOTE_STORAGE: ${CCACHE_REMOTE_STORAGE}"

      - name: ðŸ§¬ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive
          path: docker-job
      - name: â¬‡ï¸  Setup Job
        uses: ./docker-job/.github/actions/setup-job
        timeout-minutes: 10

      - name: ðŸ”§ Setup GitHub CLI and jq
        if: ${{ inputs.download-artifacts == true }}
        run: |
          echo "Checking GitHub CLI, jq, and zstd installation..."

          # Check and install GitHub CLI
          if ! command -v gh >/dev/null 2>&1; then
            echo "Installing GitHub CLI 2.81.0..."
            apt-get update
            wget -O gh_2.81.0_linux_amd64.deb https://github.com/cli/cli/releases/download/v2.81.0/gh_2.81.0_linux_amd64.deb
            apt-get install -y --no-install-recommends ./gh_2.81.0_linux_amd64.deb
            rm -f gh_2.81.0_linux_amd64.deb
            echo "GitHub CLI 2.81.0 installed successfully"
          else
            echo "GitHub CLI is already installed"
          fi

          # Check and install jq and zstd
          if ! command -v jq >/dev/null 2>&1 || ! command -v zstd >/dev/null 2>&1; then
            echo "Installing jq and zstd..."
            apt-get update
            apt-get install -y --no-install-recommends jq zstd
            echo "jq and zstd installed successfully"
          else
            echo "jq and zstd are already installed"
          fi

          # Verify installations
          echo "Verifying installations:"
          gh --version
          jq --version
          zstd --version

          # Check GitHub CLI authentication (GH_TOKEN is provided via env)
          echo "Checking GitHub CLI authentication status:"
          gh auth status || echo "WARNING: Authentication check failed"

          echo "Testing gh CLI with current repository:"
          echo "Repository: $(gh repo view --repo tenstorrent/tt-metal --json nameWithOwner --jq .nameWithOwner 2>/dev/null || echo 'Failed to get repo info')"
        shell: bash
      - name: Download Gist Script
        if: ${{ contains(inputs.test-script, 'gist.github.com') || contains(inputs.test-script, 'gist.githubusercontent.com') }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Downloading gist from ${{ inputs.test-script }}"
          GIST_URL="${{ inputs.test-script }}"

          # Extract gist ID and filename from various URL formats
          if [[ "$GIST_URL" =~ gist\.github\.com/([^/]+)/([a-f0-9]+) ]]; then
            # Regular gist URL: https://gist.github.com/username/gist_id
            GIST_USER="${BASH_REMATCH[1]}"
            GIST_ID="${BASH_REMATCH[2]}"
            # Get the filename from the end of URL if present, otherwise use default
            if [[ "$GIST_URL" =~ /([^/]+\.sh)$ ]]; then
              FILENAME="${BASH_REMATCH[1]}"
            else
              FILENAME=""
            fi
          elif [[ "$GIST_URL" =~ gist\.githubusercontent\.com/([^/]+)/([a-f0-9]+)/raw/[^/]+/(.+\.sh)$ ]]; then
            # Raw gist URL with revision: https://gist.githubusercontent.com/username/gist_id/raw/revision/filename.sh
            GIST_USER="${BASH_REMATCH[1]}"
            GIST_ID="${BASH_REMATCH[2]}"
            FILENAME="${BASH_REMATCH[3]}"
          elif [[ "$GIST_URL" =~ gist\.githubusercontent\.com/([^/]+)/([a-f0-9]+)/raw/(.+\.sh)$ ]]; then
            # Raw gist URL without revision: https://gist.githubusercontent.com/username/gist_id/raw/filename.sh
            GIST_USER="${BASH_REMATCH[1]}"
            GIST_ID="${BASH_REMATCH[2]}"
            FILENAME="${BASH_REMATCH[3]}"
          else
            echo "ERROR: Could not parse gist URL format"
            exit 1
          fi

          # Construct the raw URL without revision hash to always get latest
          if [ -n "$FILENAME" ]; then
            RAW_URL="https://gist.githubusercontent.com/${GIST_USER}/${GIST_ID}/raw/${FILENAME}"
          else
            # If no filename, try to get the first .sh file
            RAW_URL="https://gist.githubusercontent.com/${GIST_USER}/${GIST_ID}/raw"
          fi

          echo "Fetching from: $RAW_URL"
          curl -fsSL "$RAW_URL" -o /work/bisect_gist_script.sh
          chmod +x /work/bisect_gist_script.sh
          echo "Gist script downloaded and made executable"

      - name: Validate Inputs
        id: validate
        shell: bash
        run: |
          set -euo pipefail

          SEARCH_MODE='${{ inputs.search-mode }}'
          COMMIT_RANGE='${{ inputs.commit-range }}'

          # Validate that either search-mode is enabled OR commit-range is provided
          if [ "$SEARCH_MODE" != "true" ] && [ -z "$COMMIT_RANGE" ]; then
            echo "ERROR: Either search-mode must be enabled or commit-range must be provided"
            exit 1
          fi

          # If search mode is disabled, validate commit range
          if [ "$SEARCH_MODE" != "true" ]; then
            # Parse commit range from combined input
            IFS=', ' read -r GOOD_COMMIT BAD_COMMIT <<< "$COMMIT_RANGE"

            # Validate parsed values
            if [ -z "$GOOD_COMMIT" ] || [ -z "$BAD_COMMIT" ]; then
              echo "ERROR: Invalid commit-range format. Expected 'good,bad' (e.g., 'abc1234,def5678')"
              exit 1
            fi

            echo "âœ“ Parsed good commit: $GOOD_COMMIT"
            echo "âœ“ Parsed bad commit: $BAD_COMMIT"

            # Validate that commits exist
            if ! git cat-file -e "$GOOD_COMMIT^{commit}" 2>/dev/null; then
              echo "ERROR: Good commit does not exist: $GOOD_COMMIT"
              exit 1
            fi

            if ! git cat-file -e "$BAD_COMMIT^{commit}" 2>/dev/null; then
              echo "ERROR: Bad commit does not exist: $BAD_COMMIT"
              exit 1
            fi

            echo "âœ“ Both commits exist in repository"

            # Validate that good commit is an ancestor of bad commit
            if ! git merge-base --is-ancestor "$GOOD_COMMIT" "$BAD_COMMIT" 2>/dev/null; then
              echo "ERROR: Good commit ($GOOD_COMMIT) is not an ancestor of bad commit ($BAD_COMMIT)"
              echo "This means the good commit does not come before the bad commit in git history."
              echo "Please verify your commit range."
              exit 1
            fi

            echo "âœ“ Good commit is an ancestor of bad commit"

            # Export parsed values as outputs for next step
            echo "good-commit=$GOOD_COMMIT" >> $GITHUB_OUTPUT
            echo "bad-commit=$BAD_COMMIT" >> $GITHUB_OUTPUT
          else
            echo "âœ“ Search mode enabled - will find commit range automatically"
            echo "good-commit=" >> $GITHUB_OUTPUT
            echo "bad-commit=" >> $GITHUB_OUTPUT
          fi

          # Validate timeout and attempts
          TIMEOUT='${{ inputs.timeout }}'
          ATTEMPTS='${{ inputs.attempts }}'

          if [ -z "$TIMEOUT" ]; then
            echo "ERROR: Timeout must be provided"
            exit 1
          fi

          # Validate timeout is a positive integer
          if ! [[ "$TIMEOUT" =~ ^[0-9]+$ ]]; then
            echo "ERROR: Timeout must be a positive integer (got: '$TIMEOUT')"
            exit 1
          fi

          if [ "$TIMEOUT" -le 0 ]; then
            echo "ERROR: Timeout must be greater than 0 (got: $TIMEOUT)"
            exit 1
          fi

          if [ -z "$ATTEMPTS" ]; then
            echo "ERROR: Attempts must be provided"
            exit 1
          fi

          # Validate attempts is either "auto" or a positive integer
          if [ "$ATTEMPTS" == "auto" ]; then
            echo "âœ“ Attempts: auto (will be determined by running until failure)"
          elif [[ "$ATTEMPTS" =~ ^[0-9]+$ ]] && [ "$ATTEMPTS" -gt 0 ]; then
            echo "âœ“ Attempts: $ATTEMPTS"
          else
            echo "ERROR: Attempts must be 'auto' or a positive integer (got: '$ATTEMPTS')"
            exit 1
          fi

          echo "âœ“ Timeout: $TIMEOUT minutes"

          # Validate test-script is provided
          TEST_SCRIPT='${{ inputs.test-script }}'
          if [ -z "$TEST_SCRIPT" ]; then
            echo "ERROR: test-script must be provided"
            exit 1
          fi

          # Determine if it's a gist or inline command
          if [[ "$TEST_SCRIPT" == *"gist.github.com"* ]] || [[ "$TEST_SCRIPT" == *"gist.githubusercontent.com"* ]]; then
            echo "âœ“ Detected gist URL: $TEST_SCRIPT"
          else
            echo "âœ“ Using inline command"
          fi

          echo ""
          echo "All inputs validated successfully"

      - name: Determine Retry Count
        if: ${{ inputs.attempts == 'auto' }}
        id: determine-retries
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GIT_COMMITTER_NAME: "GitHub Actions"
          GIT_COMMITTER_EMAIL: "actions@github.com"
        run: |
          set -euo pipefail

          # Save original branch and restore on exit
          ORIGINAL_REF=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || git rev-parse HEAD)
          trap 'git checkout "$ORIGINAL_REF" >/dev/null 2>&1 || true' EXIT

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Determining retry count by running test until failure"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          mkdir -p ./build_bisect
          cp ./tests/scripts/test_single_commit.sh ./build_bisect/
          cp ./tests/scripts/download_artifacts.sh ./build_bisect/
          chmod +x ./build_bisect/test_single_commit.sh
          chmod +x ./build_bisect/download_artifacts.sh

          TIMEOUT='${{ inputs.timeout }}'

          # Determine start commit
          START_COMMIT='${{ inputs.start-commit }}'
          if [ -n "$START_COMMIT" ]; then
            if ! git cat-file -e "$START_COMMIT^{commit}" 2>/dev/null; then
              echo "ERROR: Start commit does not exist: $START_COMMIT"
              exit 1
            fi
            TARGET_COMMIT=$(git rev-parse "$START_COMMIT")
          else
            TARGET_COMMIT=$(git rev-parse HEAD)
          fi

          echo "Testing commit: $TARGET_COMMIT"

          # Create test script in /tmp/
          TEST_SCRIPT='${{ inputs.test-script }}'
          if [[ "$TEST_SCRIPT" == *"gist.github.com"* ]] || [[ "$TEST_SCRIPT" == *"gist.githubusercontent.com"* ]]; then
            SCRIPT_PATH="/tmp/bisect_gist_script.sh"
            cp /work/bisect_gist_script.sh /tmp/bisect_gist_script.sh
          else
            cat > /tmp/bisect_command_script.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail
          ${{ inputs.test-script }}
          EOF
            chmod +x /tmp/bisect_command_script.sh
            SCRIPT_PATH="/tmp/bisect_command_script.sh"
          fi

          # Build test arguments (single attempt per run, no ND mode for counting)
          declare -a test_args
          if [[ "${{ inputs.tracy }}" == 'true' ]]; then
            test_args+=(--tracy)
          fi
          test_args+=(--artifact-mode)

          # Run test until failure
          ATTEMPT=1
          MAX_ATTEMPTS=100
          FAILED=false

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Retry determination: Attempt $ATTEMPT"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            # Run test_single_commit.sh with 1 attempt (no ND mode)
            if ./build_bisect/test_single_commit.sh "$TARGET_COMMIT" "$SCRIPT_PATH" "$TIMEOUT" "1" "${test_args[@]}" 2>&1; then
              echo "Attempt $ATTEMPT: PASSED"
              ATTEMPT=$((ATTEMPT + 1))
            else
              RC=$?
              if [ $RC -eq 2 ]; then
                echo "Attempt $ATTEMPT: SKIPPED (build failed or timeout)"
                echo "ERROR: Cannot determine retry count - test was skipped"
                exit 1
              else
                echo "Attempt $ATTEMPT: FAILED"
                FAILED=true
                break
              fi
            fi
          done

          if [ "$FAILED" = false ]; then
            echo "ERROR: Test did not fail after $MAX_ATTEMPTS attempts"
            echo "Cannot determine retry count - test appears to always pass"
            exit 1
          fi

          RETRIES=$((ATTEMPT * 3))
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Test failed after $ATTEMPT attempt(s)"
          echo "Setting ND bisect retries to: $RETRIES (3x $ATTEMPT)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          echo "retry-count=$RETRIES" >> $GITHUB_OUTPUT

      - name: Search for Failure Boundary
        if: ${{ inputs.search-mode == true }}
        id: search-boundary
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GIT_COMMITTER_NAME: "GitHub Actions"
          GIT_COMMITTER_EMAIL: "actions@github.com"
        run: |
          set -euo pipefail
          trap 'git checkout -' EXIT  # Return to original branch/commit on exit

          mkdir -p ./build_bisect
          cp ./tests/scripts/test_single_commit.sh ./build_bisect/
          cp ./tests/scripts/download_artifacts.sh ./build_bisect/
          chmod +x ./build_bisect/test_single_commit.sh
          chmod +x ./build_bisect/download_artifacts.sh

          TIMEOUT='${{ inputs.timeout }}'

          # Use determined retry count if auto, otherwise use provided value
          if [ '${{ inputs.attempts }}' == 'auto' ]; then
            ATTEMPTS='${{ steps.determine-retries.outputs.retry-count }}'
            echo "Using auto-determined retry count: $ATTEMPTS"
          else
            ATTEMPTS='${{ inputs.attempts }}'
          fi

          # Determine which script to run based on test-script input
          # IMPORTANT: Store test scripts in /tmp/ to ensure they don't change during git checkouts
          # The bisect process checks out different commits, which would change files in /work/
          # Using /tmp/ ensures the test script remains stable throughout the bisect
          SCRIPT_PATH=""
          TEST_SCRIPT='${{ inputs.test-script }}'

          if [[ "$TEST_SCRIPT" == *"gist.github.com"* ]] || [[ "$TEST_SCRIPT" == *"gist.githubusercontent.com"* ]]; then
            SCRIPT_PATH="/tmp/bisect_gist_script.sh"
            cp /work/bisect_gist_script.sh /tmp/bisect_gist_script.sh
          else
            cat > /tmp/bisect_command_script.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail
          ${{ inputs.test-script }}
          EOF
            chmod +x /tmp/bisect_command_script.sh
            SCRIPT_PATH="/tmp/bisect_command_script.sh"
          fi

          # Build test arguments
          declare -a test_args
          if [[ "${{ inputs.tracy }}" == 'true' ]]; then
            test_args+=(--tracy)
          fi
          if [[ "${{ inputs.nd-mode }}" == 'true' ]]; then
            test_args+=(--nd-mode)
          fi
          # Always enable artifact mode - test_single_commit.sh will try to download
          # and fall back to building if download fails
          test_args+=(--artifact-mode)

          # Start from specified commit or HEAD
          START_COMMIT='${{ inputs.start-commit }}'
          if [ -n "$START_COMMIT" ]; then
            # Validate and resolve the start commit
            if ! git cat-file -e "$START_COMMIT^{commit}" 2>/dev/null; then
              echo "ERROR: Start commit does not exist: $START_COMMIT"
              exit 1
            fi
            CURRENT_COMMIT=$(git rev-parse "$START_COMMIT")
            echo "Starting search from specified commit: $CURRENT_COMMIT"
            # Checkout the start commit so our search begins there
            git checkout "$CURRENT_COMMIT" >/dev/null 2>&1
          else
            CURRENT_COMMIT=$(git rev-parse HEAD)
            echo "Starting search from HEAD: $CURRENT_COMMIT"
          fi

          # Test current commit first
          echo "::group::Testing current commit $CURRENT_COMMIT"
          if ./build_bisect/test_single_commit.sh "$CURRENT_COMMIT" "$SCRIPT_PATH" "$TIMEOUT" "$ATTEMPTS" "${test_args[@]}" 2>&1; then
            CURRENT_RESULT=0  # Good
            echo "Current commit PASSES"
          else
            CURRENT_RESULT=$?
            if [ $CURRENT_RESULT -eq 2 ]; then
              echo "Current commit SKIPPED"
            else
              echo "Current commit FAILS"
            fi
          fi
          echo "::endgroup::"

          # If current commit passes, we're done (no failure to find)
          if [ $CURRENT_RESULT -eq 0 ]; then
            echo "Current commit passes - no failure detected. Nothing to bisect."
            echo "good-commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
            echo "bad-commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
            echo "search-complete=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Current commit fails, so we need to find when it started failing
          # We'll search backwards to find the oldest commit that passes
          # The bad commit for bisect will be the current commit (most recent failure)
          OLDEST_GOOD_COMMIT=""

          # Exponential backoff: 1 day, 2 days, 4 days, 8 days, etc.
          DAYS_BACK=1
          MAX_DAYS_BACK=365  # Safety limit: don't go back more than a year

          while [ $DAYS_BACK -le $MAX_DAYS_BACK ]; do
            echo "::group::Searching $DAYS_BACK days back"

            # Find a commit from N days ago
            TARGET_DATE=$(date -d "$DAYS_BACK days ago" -Iseconds 2>/dev/null || date -v-${DAYS_BACK}d +%Y-%m-%dT%H:%M:%S 2>/dev/null || echo "")

            if [ -z "$TARGET_DATE" ]; then
              echo "ERROR: Could not calculate target date"
              exit 1
            fi

            # Find the first commit before or at the target date
            TARGET_COMMIT=$(git log --until="$TARGET_DATE" --format="%H" -n 1 2>/dev/null || echo "")

            if [ -z "$TARGET_COMMIT" ]; then
              echo "No commit found $DAYS_BACK days back"
              if [ -n "$OLDEST_GOOD_COMMIT" ]; then
                echo "Stopping search - already found a good commit"
                break
              else
                echo "Continuing to search further back..."
                DAYS_BACK=$((DAYS_BACK * 2))
                echo "::endgroup::"
                continue
              fi
            fi

            echo "Testing commit from $DAYS_BACK days ago: $TARGET_COMMIT"

            # Test this commit
            if ./build_bisect/test_single_commit.sh "$TARGET_COMMIT" "$SCRIPT_PATH" "$TIMEOUT" "$ATTEMPTS" "${test_args[@]}" 2>&1; then
              TEST_RESULT=0  # Good
              echo "Commit $TARGET_COMMIT PASSES"
              # Update oldest good commit (keep the oldest one we've found)
              if [ -z "$OLDEST_GOOD_COMMIT" ] || git merge-base --is-ancestor "$OLDEST_GOOD_COMMIT" "$TARGET_COMMIT" 2>/dev/null; then
                OLDEST_GOOD_COMMIT="$TARGET_COMMIT"
              fi
              # We found a good commit - this means we've crossed the boundary
              # The failure started somewhere between this good commit and the current commit
              echo "Found good commit - failure boundary identified, stopping search"
              echo "::endgroup::"
              break
            else
              TEST_RESULT=$?
              if [ $TEST_RESULT -eq 2 ]; then
                echo "Commit $TARGET_COMMIT SKIPPED, continuing search"
              else
                echo "Commit $TARGET_COMMIT FAILS, continuing search backwards"
              fi
            fi

            echo "::endgroup::"

            # Exponential backoff: double the days
            DAYS_BACK=$((DAYS_BACK * 2))
          done

          # If we didn't find a good commit, use repository root as fallback
          if [ -z "$OLDEST_GOOD_COMMIT" ]; then
            echo "WARNING: Did not find a good commit within $MAX_DAYS_BACK days"
            echo "The failure may have existed for longer than expected."
            OLDEST_COMMIT=$(git rev-list --max-parents=0 HEAD | head -1)
            echo "Using repository root as good commit: $OLDEST_COMMIT"
            OLDEST_GOOD_COMMIT="$OLDEST_COMMIT"
          fi

          # Use current commit as the bad commit (most recent failure)
          OLDEST_BAD_COMMIT="$CURRENT_COMMIT"

          # Validate that good commit is an ancestor of bad commit
          if ! git merge-base --is-ancestor "$OLDEST_GOOD_COMMIT" "$OLDEST_BAD_COMMIT" 2>/dev/null; then
            echo "ERROR: Good commit ($OLDEST_GOOD_COMMIT) is not an ancestor of bad commit ($OLDEST_BAD_COMMIT)"
            echo "This should not happen. Please check the search logic."
            exit 1
          fi

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Search complete!"
          echo "Good commit (oldest without failure): $OLDEST_GOOD_COMMIT"
          echo "Bad commit (oldest with failure): $OLDEST_BAD_COMMIT"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          echo "good-commit=$OLDEST_GOOD_COMMIT" >> $GITHUB_OUTPUT
          echo "bad-commit=$OLDEST_BAD_COMMIT" >> $GITHUB_OUTPUT
          echo "search-complete=true" >> $GITHUB_OUTPUT

      - name: Run Git Bisect
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GIT_COMMITTER_NAME: "GitHub Actions"
          GIT_COMMITTER_EMAIL: "actions@github.com"
        run: |
          set -euo pipefail
          trap 'rm -rf ./build_bisect' EXIT
          mkdir -p ./build_bisect
          cp ./tests/scripts/tt_bisect.sh ./build_bisect/
          cp ./tests/scripts/download_artifacts.sh ./build_bisect/
          chmod +x ./build_bisect/tt_bisect.sh
          chmod +x ./build_bisect/download_artifacts.sh

          # Use commits from search-boundary step if search-mode is enabled, otherwise from validate step
          SEARCH_MODE='${{ inputs.search-mode }}'
          if [ "$SEARCH_MODE" == "true" ]; then
            GOOD_COMMIT='${{ steps.search-boundary.outputs.good-commit }}'
            BAD_COMMIT='${{ steps.search-boundary.outputs.bad-commit }}'

            # If search found that current commit passes, skip bisect
            if [ "$GOOD_COMMIT" == "$BAD_COMMIT" ]; then
              echo "No failure detected - skipping bisect"
              exit 0
            fi
          else
            GOOD_COMMIT='${{ steps.validate.outputs.good-commit }}'
            BAD_COMMIT='${{ steps.validate.outputs.bad-commit }}'
          fi
          TIMEOUT='${{ inputs.timeout }}'

          # Use determined retry count if auto, otherwise use provided value
          if [ '${{ inputs.attempts }}' == 'auto' ]; then
            ATTEMPTS='${{ steps.determine-retries.outputs.retry-count }}'
            echo "Using auto-determined retry count: $ATTEMPTS"
          else
            ATTEMPTS='${{ inputs.attempts }}'
          fi

          # IMPORTANT: Store test scripts in /tmp/ to ensure they don't change during git checkouts
          # The bisect process checks out different commits, which would change files in /work/
          # Using /tmp/ ensures the test script remains stable throughout the bisect
          SCRIPT_PATH=""
          TEST_SCRIPT='${{ inputs.test-script }}'

          if [[ "$TEST_SCRIPT" == *"gist.github.com"* ]] || [[ "$TEST_SCRIPT" == *"gist.githubusercontent.com"* ]]; then
            # It's a gist URL, copy the downloaded gist script to /tmp/
            SCRIPT_PATH="/tmp/bisect_gist_script.sh"
            cp /work/bisect_gist_script.sh /tmp/bisect_gist_script.sh
          else
            # It's an inline command, write it to /tmp/ to avoid being affected by git checkouts
            # Note: using heredoc with 'EOF' prevents variable expansion
            cat > /tmp/bisect_command_script.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail
          ${{ inputs.test-script }}
          EOF
            chmod +x /tmp/bisect_command_script.sh
            SCRIPT_PATH="/tmp/bisect_command_script.sh"
          fi

          # Build arguments in an array to avoid empty string issues
          declare -a bisect_args
          bisect_args+=(-t "$TIMEOUT")
          bisect_args+=(-b "$BAD_COMMIT")
          bisect_args+=(-g "$GOOD_COMMIT")
          bisect_args+=(-r "$ATTEMPTS")

          if [[ "${{ inputs.tracy }}" == 'true' ]]; then
            bisect_args+=(-p)
          fi
          if [[ "${{ inputs.nd-mode }}" == 'true' ]]; then
            bisect_args+=(-n)
          fi
          if [[ "${{ inputs.download-artifacts }}" == 'true' ]]; then
            bisect_args+=(-a)
          fi

          if [[ "${{ inputs.skip-commits }}" != '' ]]; then
            bisect_args+=(-c "${{ inputs.skip-commits }}")
          fi

          bisect_args+=(-s "$SCRIPT_PATH")

          # Run bisect with clean, properly quoted arguments
          set +e
          ./build_bisect/tt_bisect.sh "${bisect_args[@]}"
          BISECT_EXIT_CODE=$?
          set -e

          # Handle exit codes
          if [ $BISECT_EXIT_CODE -eq 2 ]; then
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Bisect completed with exit code 2"
            echo "Likely outcome: No problematic commit found, only skipped commits remain"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            exit 0
          elif [ $BISECT_EXIT_CODE -ne 0 ]; then
            echo "Bisect failed with exit code $BISECT_EXIT_CODE"
            exit $BISECT_EXIT_CODE
          fi

      - name: Upload ND results CSV
        if: ${{ hashFiles('docker-job/bisect_nd_results.csv') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: bisect-nd-results
          path: docker-job/bisect_nd_results.csv
          if-no-files-found: ignore

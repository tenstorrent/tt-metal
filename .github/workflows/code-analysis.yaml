name: "Code analysis"

on:
  schedule:
    - cron: "0 2 * * 1,3,5" # Static analysis: 2 AM UTC on Mon/Wed/Fri
  workflow_call:
    inputs:
      distro:
        required: false
        type: string
        default: "ubuntu"
      version:
        required: false
        type: string
        default: "24.04"
      architecture:
        required: false
        type: string
        default: "amd64"
      enable-static-analysis:
        description: "Enable Clang Static Analyzer (CSA) via CodeChecker"
        required: false
        type: boolean
        default: false
      previous-run-id:
        description: "Run ID of a previous workflow to download CodeChecker results from (skips analysis)"
        required: false
        type: string
        default: ""
      enable-copilot-fix:
        description: "Enable Copilot to automatically fix one ClangSA issue and create a PR"
        required: false
        type: boolean
        default: false
  workflow_dispatch:
    inputs:
      distro:
        required: false
        type: string
        default: "ubuntu"
      version:
        required: false
        type: string
        default: "24.04"
      architecture:
        required: false
        type: string
        default: "amd64"
      enable-static-analysis:
        description: "Enable Clang Static Analyzer (CSA) via CodeChecker"
        required: false
        type: boolean
        default: false
      previous-run-id:
        description: "Run ID of a previous workflow to download CodeChecker results from (skips analysis)"
        required: false
        type: string
        default: ""
      enable-copilot-fix:
        description: "Enable Copilot to automatically fix one ClangSA issue and create a PR"
        required: false
        type: boolean
        default: false

jobs:
  determine-scan-type:
    runs-on: ubuntu-latest
    outputs:
      do-full-scan: ${{ steps.compute-outputs.outputs.do-full-scan }}
      do-scan: ${{ steps.compute-outputs.outputs.do-scan }}
    steps:
      - id: find-changes
        uses: tenstorrent/tt-metal/.github/actions/find-changed-files@v0.63.0

      - id: compute-outputs
        shell: bash
        run: |
          do_full_scan=$([[ "${{ github.ref_name }}" == "main" || "${{ steps.find-changes.outputs.clang-tidy-config-changed }}" == "true" ]] && echo "true" || echo "false")
          do_scan=$([[ "$do_full_scan" == "true" || "${{ steps.find-changes.outputs.any-code-changed }}" == "true" || "${{ steps.find-changes.outputs.cmake-changed }}" == "true" ]] && echo "true" || echo "false")
          echo "Do a scan: $do_scan"
          echo "Do a full scan: $do_full_scan"
          echo "do-full-scan=$do_full_scan" >> "$GITHUB_OUTPUT"
          echo "do-scan=$do_scan" >> "$GITHUB_OUTPUT"

  build-docker-image:
    uses: ./.github/workflows/build-docker-artifact.yaml
    permissions:
      packages: write
    secrets: inherit
    with:
      distro: ${{ inputs.distro || 'ubuntu' }}
      version: ${{ inputs.version || '24.04' }}
      architecture: ${{ inputs.architecture || 'amd64' }}

  clang-tidy:
    name: ðŸ¤– Clang Tidy
    needs: [ build-docker-image, determine-scan-type ]
    if: ${{ needs.determine-scan-type.outputs.do-scan == 'true' }}
    runs-on: tt-ubuntu-2204-xlarge-stable
    environment: ${{ github.ref == 'refs/heads/main' && 'mainline' || '' }}
    container:
      image: harbor.ci.tenstorrent.net/${{ needs.build-docker-image.outputs.ci-build-tag || 'docker-image-unresolved!'}}
      env:
        CCACHE_REMOTE_ONLY: "true"
        CCACHE_TEMPDIR: /tmp/ccache
      volumes:
        - ${{ github.workspace }}:/work
        - /home/ubuntu/.ccache-ci:/github/home/.ccache # HOME is hardcoded for no clear reason: https://github.com/actions/runner/issues/863
      # Group 1457 is for the shared ccache drive
      # tmpfs is for efficiency
      options: >
        --group-add 1457
        --tmpfs /tmp
    defaults:
      run:
        shell: bash
        working-directory: /work # https://github.com/actions/runner/issues/878
    steps:
      - name: Check Redis credentials
        # Failing internal jobs draws attention immediately so we can fix them and make them fast.
        # Forks will never have secrets; don't fail the job for them, they'll just run slower
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        run: |
          if [ -z "${{ secrets.REDIS_PASSWORD }}" ]; then
            echo "Redis password is missing. Did you forget 'secrets: inherit'?"
            exit 1
          fi
          # Conditionally set this here so that it remains unset on forks, otherwise it resolves an invalid URL and the job fails
          CCACHE_REMOTE_STORAGE="redis://${{ vars.REDIS_USER }}:${{ secrets.REDIS_PASSWORD }}@${{ vars.REDIS_HOST }}:${{ vars.REDIS_PORT }}|read-only=${{ vars.REDIS_IS_READONLY }}"
          echo "CCACHE_REMOTE_STORAGE=${CCACHE_REMOTE_STORAGE}" >> $GITHUB_ENV
          echo "CCACHE_REMOTE_STORAGE: ${CCACHE_REMOTE_STORAGE}"

      - name: Create ccache tmpdir
        run: |
          mkdir -p /tmp/ccache

      - name: Check out repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: recursive
          clean: true

      - name: Configure git safe.directory
        run: git config --global --add safe.directory /work

      - name: Determine merge base
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          echo "Current branch: ${{ github.ref_name }}"
          MERGE_BASE=$(git merge-base ${{ github.ref_name }} origin/main)
          echo "Merge base between ${{ github.ref_name }} and main: $MERGE_BASE"
          echo "MERGE_BASE=$MERGE_BASE" >> $GITHUB_ENV

      - name: Check out baseline
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ env.MERGE_BASE }}
          fetch-depth: 0
          fetch-tags: true
          submodules: recursive
          clean: true

      - name: Create shim
        run: |
          # Suppress clang-tidy to first get an up-to-date build tree
          ln -sf /usr/bin/true ./clang-tidy-shim

      - name: ðŸ”§ CMake configure
        run: |
          cmake --preset clang-tidy -DCMAKE_CXX_CLANG_TIDY="$(pwd)/clang-tidy-shim;--warnings-as-errors=*" -DCMAKE_C_CLANG_TIDY="$(pwd)/clang-tidy-shim;--warnings-as-errors=*"

      - name: Prepare baseline ccache summary
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          # Zero out the stats so we can see how we did this build
          # NOTE: may be inaccurate if we have >1 build runner on the same machine, using the same local cache
          ccache -z

      - name: ðŸ› ï¸ Baseline Build
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          cmake --build --preset clang-tidy

      - name: Publish Ccache summary
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          echo '## CCache Summary' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ccache -s >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: recursive
          clean: false

      - name: Restore shim
        run: |
          # Restore shim to legit clang-tidy
          # Symlink tomfoolery here so that Ninja believes the build command has not changed from the previous run
          ln -sf $(which clang-tidy-20) ./clang-tidy-shim

      - name: Prepare ccache summary
        run: |
          # Zero out the stats so we can see how we did this build
          # NOTE: may be inaccurate if we have >1 build runner on the same machine, using the same local cache
          ccache -z

      - name: ðŸ” Analyze code with clang-tidy
        run: |
          cmake --build --preset clang-tidy

      - name: Publish Ccache summary
        run: |
          echo '## CCache Summary' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ccache -s >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  clang-static-analyzer:
    name: ðŸ”¬ Clang Static Analyzer
    needs: [ build-docker-image ]
    if: ${{ (inputs.enable-static-analysis == true || github.event_name == 'schedule') && inputs.previous-run-id == '' }}
    runs-on: tt-ubuntu-2204-xlarge-stable
    container:
      image: harbor.ci.tenstorrent.net/${{ needs.build-docker-image.outputs.ci-build-tag || 'docker-image-unresolved!'}}
      volumes:
        - ${{ github.workspace }}:/work
        - ${{ github.workspace }}/../../_actions:${{ github.workspace }}/../../_actions # HACK: make actions available inside container
      options: --tmpfs /tmp
    defaults:
      run:
        shell: bash
        working-directory: /work # https://github.com/actions/runner/issues/878
    steps:
      - name: Check out repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: recursive

      - name: Configure git safe.directory
        run: git config --global --add safe.directory /work

      - name: ðŸ”§ CMake configure
        run: cmake --preset clang-static-analyzer

      - name: ðŸ› ï¸ Generate files
        run: cmake --build .build/clang-static-analyzer --target all_generated_files

      - name: Setup clang symlinks for CodeChecker
        run: |
          update-alternatives --install /usr/bin/clang clang /usr/bin/clang-20 100
          update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-20 100

      - name: Install CodeChecker
        run: |
          # Pre-install CodeChecker in the container's venv using uv.
          # Pin to a specific version for reproducibility.
          uv pip install codechecker==6.27.1

      - name: ðŸ”¬ Analyze with CodeChecker
        uses: blozano-tt/CodeChecker-Action@v1.0.5-tt
        id: codechecker
        with:
          logfile: /work/.build/clang-static-analyzer/compile_commands.json
          llvm-version: ignore # Already installed in our Docker container
          config: /work/.codechecker.json
          version: ignore # Already installed in our Docker container

      - name: Upload CodeChecker HTML reports
        uses: actions/upload-artifact@v4
        if: always()
        timeout-minutes: 10
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: ${{ steps.codechecker.outputs.result-html-dir }}

      - name: Find and upload raw CodeChecker reports
        id: find-raw-reports
        if: always()
        run: |
          set -euo pipefail
          echo "=== Searching for CodeChecker plist reports ==="

          # CodeChecker-Action typically stores reports in various locations
          # Try to find the directory containing plist files
          POSSIBLE_DIRS=(
            "/work/.codechecker_reports"
            "/work/codechecker_reports"
            "/tmp/codechecker_reports"
            "${{ steps.codechecker.outputs.result-html-dir }}/../reports"
            "${{ steps.codechecker.outputs.result-html-dir }}/reports"
          )

          RAW_REPORTS_DIR=""

          # First check the possible directories
          for dir in "${POSSIBLE_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              echo "Found directory: $dir"
              if find "$dir" -name "*.plist" -type f 2>/dev/null | head -1 | grep -q .; then
                RAW_REPORTS_DIR="$dir"
                echo "Found plist files in: $dir"
                break
              fi
            fi
          done

          # If not found, search more broadly
          if [ -z "$RAW_REPORTS_DIR" ]; then
            echo "Searching for plist files in /work and /tmp..."
            PLIST_FILE=$(find /work /tmp -name "*.plist" -type f 2>/dev/null | head -1 || true)
            if [ -n "$PLIST_FILE" ]; then
              RAW_REPORTS_DIR=$(dirname "$PLIST_FILE")
              echo "Found plist files in: $RAW_REPORTS_DIR"
            fi
          fi

          if [ -n "$RAW_REPORTS_DIR" ] && [ -d "$RAW_REPORTS_DIR" ]; then
            echo "raw-reports-dir=$RAW_REPORTS_DIR" >> "$GITHUB_OUTPUT"
            echo "has-raw-reports=true" >> "$GITHUB_OUTPUT"
            PLIST_COUNT=$(find "$RAW_REPORTS_DIR" -name "*.plist" -type f | wc -l)
            echo "Found $PLIST_COUNT plist files"
          else
            echo "No raw reports directory found"
            echo "has-raw-reports=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload raw CodeChecker reports (plist)
        uses: actions/upload-artifact@v4
        if: always() && steps.find-raw-reports.outputs.has-raw-reports == 'true'
        timeout-minutes: 10
        with:
          name: CodeChecker-Raw-Reports
          path: ${{ steps.find-raw-reports.outputs.raw-reports-dir }}

      - name: Extract CodeChecker issues to JSON
        id: extract-issues
        if: always()
        run: |
          set -euo pipefail
          REPORT_DIR="${{ steps.codechecker.outputs.result-html-dir }}"
          if [ ! -d "$REPORT_DIR" ]; then
            echo "No CodeChecker reports found"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # CodeChecker stores reports in a specific structure
          # Try to find the actual report directory (contains plist files or can be parsed)
          # First, try to find plist files or the reports subdirectory
          REPORTS_BASE=""

          # Look for a reports subdirectory
          if [ -d "$REPORT_DIR/reports" ]; then
            REPORTS_BASE="$REPORT_DIR/reports"
          # Look for plist files in the directory
          elif find "$REPORT_DIR" -name "*.plist" -type f | head -1 | grep -q .; then
            REPORTS_BASE="$REPORT_DIR"
          # Try parent directory (sometimes reports are one level up)
          elif [ -d "$(dirname "$REPORT_DIR")/reports" ]; then
            REPORTS_BASE="$(dirname "$REPORT_DIR")/reports"
          else
            # Last resort: try the HTML dir itself
            REPORTS_BASE="$REPORT_DIR"
          fi

          echo "Using report directory: $REPORTS_BASE"

          # Export issues to JSON using CodeChecker parse
          JSON_OUTPUT="/tmp/codechecker_issues.json"
          if CodeChecker parse "$REPORTS_BASE" --export json > "$JSON_OUTPUT" 2>&1; then
            # Check if we have any issues
            if [ ! -s "$JSON_OUTPUT" ]; then
              echo "Empty JSON output from CodeChecker"
              echo "has-issues=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Try to parse as JSON array
            ISSUE_COUNT=$(jq 'if type == "array" then length else 0 end' "$JSON_OUTPUT" 2>/dev/null || echo "0")
            if [ "$ISSUE_COUNT" = "0" ]; then
              echo "No issues found in CodeChecker reports"
              echo "has-issues=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "Found $ISSUE_COUNT issues"
            echo "has-issues=true" >> "$GITHUB_OUTPUT"
            echo "issue-count=$ISSUE_COUNT" >> "$GITHUB_OUTPUT"

            # Upload JSON for use in next job
            cp "$JSON_OUTPUT" /work/codechecker_issues.json
          else
            echo "Failed to parse CodeChecker reports (this may be normal if no issues found)"
            cat "$JSON_OUTPUT" || true
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

      - name: Upload CodeChecker issues JSON
        uses: actions/upload-artifact@v4
        if: steps.extract-issues.outputs.has-issues == 'true'
        with:
          name: CodeChecker-Issues-JSON
          path: /work/codechecker_issues.json

  # Job to download CodeChecker artifacts from a previous workflow run
  download-previous-results:
    name: ðŸ“¥ Download Previous Results
    if: ${{ inputs.previous-run-id != '' }}
    runs-on: ubuntu-latest
    outputs:
      has-issues: ${{ steps.extract-issues.outputs.has-issues }}
    steps:
      # Download HTML reports (contains *.plist.html files with all issue info)
      - name: Download CodeChecker HTML Reports from previous run
        uses: actions/download-artifact@v4
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: /tmp/previous-html
          run-id: ${{ inputs.previous-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract issues from HTML reports
        id: extract-issues
        run: |
          set -euo pipefail
          REPORT_DIR="/tmp/previous-html"

          echo "=== Listing HTML report contents ==="
          ls -la "$REPORT_DIR" | head -20

          # Find all .plist.html files (each contains issues for one source file)
          PLIST_HTML_FILES=$(find "$REPORT_DIR" -name "*.plist.html" -type f 2>/dev/null)
          ISSUE_COUNT=$(echo "$PLIST_HTML_FILES" | grep -c . || echo "0")

          echo "Found $ISSUE_COUNT plist.html files (each represents a file with issues)"

          if [ "$ISSUE_COUNT" = "0" ]; then
            echo "No issues found in CodeChecker HTML reports"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "has-issues=true" >> "$GITHUB_OUTPUT"
          echo "issue-count=$ISSUE_COUNT" >> "$GITHUB_OUTPUT"

          # Extract issue information from the HTML files
          # Each .plist.html file contains issues for a specific source file
          # Format: {source_file}_clangsa_{hash}.plist.html
          JSON_OUTPUT="/tmp/codechecker_issues.json"
          echo "[" > "$JSON_OUTPUT"

          FIRST=true
          while IFS= read -r html_file; do
            [ -z "$html_file" ] && continue

            # Extract source file name from the HTML filename
            # Format: test_cleanup.cpp_clangsa_d8c936ee4957f9035b5c5ea49b7cc12b.plist.html
            basename_file=$(basename "$html_file")
            # Remove _clangsa_*.plist.html suffix to get source file
            source_file=$(echo "$basename_file" | sed 's/_clangsa_[a-f0-9]*\.plist\.html$//')

            # Parse HTML to extract issue details
            # Look for bug report entries - they typically contain checker name, line number, message
            # The HTML structure varies, so we'll extract what we can

            # Try to extract checker name from HTML (usually in a span or div with class containing "checker")
            checker=$(grep -oP '(?<=<span class="checker-name">)[^<]+' "$html_file" 2>/dev/null | head -1 || \
                      grep -oP 'clangsa\.[^<"]+' "$html_file" 2>/dev/null | head -1 || \
                      echo "clangsa.unknown")

            # Try to extract line number (usually in report-line or similar)
            line=$(grep -oP '(?<=<span class="line">)[0-9]+' "$html_file" 2>/dev/null | head -1 || \
                   grep -oP '(?<=line )[0-9]+' "$html_file" 2>/dev/null | head -1 || \
                   grep -oP ':[0-9]+:' "$html_file" 2>/dev/null | head -1 | tr -d ':' || \
                   echo "1")

            # Try to extract message
            message=$(grep -oP '(?<=<span class="message">)[^<]+' "$html_file" 2>/dev/null | head -1 || \
                      grep -oP '(?<=<div class="bug-message">)[^<]+' "$html_file" 2>/dev/null | head -1 || \
                      echo "Static analysis issue detected")

            # Clean up extracted values
            checker=$(echo "$checker" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -c 100)
            line=$(echo "$line" | grep -oP '[0-9]+' | head -1)
            [ -z "$line" ] && line="1"
            message=$(echo "$message" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/"/\\"/g' | head -c 500)

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              echo "," >> "$JSON_OUTPUT"
            fi

            cat >> "$JSON_OUTPUT" << JSONEOF
          {
            "file": "$source_file",
            "line": $line,
            "checker": "$checker",
            "message": "$message",
            "html_report": "$basename_file"
          }
          JSONEOF

          done <<< "$PLIST_HTML_FILES"

          echo "]" >> "$JSON_OUTPUT"

          echo "=== Generated JSON ==="
          cat "$JSON_OUTPUT"

          # Validate JSON
          if ! jq empty "$JSON_OUTPUT" 2>/dev/null; then
            echo "Warning: Generated invalid JSON, creating simple fallback"
            # Create a simple fallback with just file names
            echo "[" > "$JSON_OUTPUT"
            FIRST=true
            while IFS= read -r html_file; do
              [ -z "$html_file" ] && continue
              basename_file=$(basename "$html_file")
              source_file=$(echo "$basename_file" | sed 's/_clangsa_[a-f0-9]*\.plist\.html$//')
              if [ "$FIRST" = true ]; then
                FIRST=false
              else
                echo "," >> "$JSON_OUTPUT"
              fi
              echo "{\"file\": \"$source_file\", \"line\": 1, \"checker\": \"clangsa\", \"message\": \"See HTML report\", \"html_report\": \"$basename_file\"}" >> "$JSON_OUTPUT"
            done <<< "$PLIST_HTML_FILES"
            echo "]" >> "$JSON_OUTPUT"
          fi

      - name: Upload extracted issues JSON
        if: steps.extract-issues.outputs.has-issues == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: CodeChecker-Issues-JSON
          path: /tmp/codechecker_issues.json

      - name: Re-upload HTML reports as current workflow artifact
        uses: actions/upload-artifact@v4
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: /tmp/previous-html

  copilot-fix-clangsa-issue:
    name: ðŸ¤– Copilot Fix ClangSA Issue
    needs: [ clang-static-analyzer, download-previous-results ]
    # Run if: (analysis ran successfully OR we downloaded from previous run) AND copilot fix is enabled
    if: |
      always() &&
      inputs.enable-copilot-fix == true &&
      (needs.clang-static-analyzer.result == 'success' || needs.download-previous-results.result == 'success')
    runs-on: ubuntu-latest
    outputs:
      pr-url: ${{ steps.create-agent-task.outputs.pr-url }}
      session-url: ${{ steps.create-agent-task.outputs.session-url }}
    steps:
      - name: Download CodeChecker issues JSON
        id: download-json
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: CodeChecker-Issues-JSON
          path: /tmp

      - name: Check if issues exist and select one
        id: select-issue
        run: |
          set -euo pipefail
          if [ ! -f "/tmp/codechecker_issues.json" ]; then
            echo "No CodeChecker issues found"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Handle different JSON structures (array, object with reports, etc.)
          ISSUE_COUNT=$(jq '
            if type == "array" then length
            elif type == "object" and has("reports") then (.reports | length)
            elif type == "object" then length
            else 0 end
          ' /tmp/codechecker_issues.json 2>/dev/null || echo "0")

          if [ "$ISSUE_COUNT" = "0" ] || [ -z "$ISSUE_COUNT" ] || [ "$ISSUE_COUNT" = "null" ]; then
            echo "No issues found"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found $ISSUE_COUNT issues"
          echo "has-issues=true" >> "$GITHUB_OUTPUT"
          echo "issue-count=$ISSUE_COUNT" >> "$GITHUB_OUTPUT"

          # Extract the first issue
          ISSUE=$(jq -r '
            if type == "array" then .[0]
            elif type == "object" and has("reports") then .reports[0]
            elif type == "object" then .[keys[0]]
            else empty end
          ' /tmp/codechecker_issues.json)

          if [ -z "$ISSUE" ] || [ "$ISSUE" = "null" ]; then
            echo "Failed to extract issue from JSON"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract key information (handle different JSON structures)
          FILE_PATH=$(echo "$ISSUE" | jq -r '.file.path // .file.name // .file // .path // "unknown"')
          LINE=$(echo "$ISSUE" | jq -r '.line // .location.line // .lineNumber // "unknown"')
          COLUMN=$(echo "$ISSUE" | jq -r '.column // .location.col // .columnNumber // "unknown"')
          CHECKER_NAME=$(echo "$ISSUE" | jq -r '.checker.name // .checker // .checkerName // "unknown"')
          MESSAGE=$(echo "$ISSUE" | jq -r '.message // .description // .msg // "unknown"')
          SEVERITY=$(echo "$ISSUE" | jq -r '.severity // .severityLevel // "unknown"')

          # Get relative path (strip common prefixes)
          if [[ "$FILE_PATH" == "/work/"* ]]; then
            REL_PATH="${FILE_PATH#/work/}"
          else
            REL_PATH="$FILE_PATH"
          fi

          echo "file-path=$REL_PATH" >> "$GITHUB_OUTPUT"
          echo "line=$LINE" >> "$GITHUB_OUTPUT"
          echo "column=$COLUMN" >> "$GITHUB_OUTPUT"
          echo "checker-name=$CHECKER_NAME" >> "$GITHUB_OUTPUT"
          echo "message=$MESSAGE" >> "$GITHUB_OUTPUT"
          echo "severity=$SEVERITY" >> "$GITHUB_OUTPUT"

      - name: Create Copilot agent task via GitHub CLI
        if: steps.select-issue.outputs.has-issues == 'true'
        id: create-agent-task
        env:
          GH_TOKEN: ${{ secrets.AUTO_TRIAGE_TOKEN }}
        run: |
          set -euo pipefail

          FILE_PATH="${{ steps.select-issue.outputs.file-path }}"
          LINE="${{ steps.select-issue.outputs.line }}"
          COLUMN="${{ steps.select-issue.outputs.column }}"
          CHECKER_NAME="${{ steps.select-issue.outputs.checker-name }}"
          MESSAGE="${{ steps.select-issue.outputs.message }}"
          SEVERITY="${{ steps.select-issue.outputs.severity }}"

          # Construct the prompt for Copilot coding agent
          PROMPT="Fix the following Clang Static Analyzer issue in this repository:

          **File:** \`$FILE_PATH\`
          **Line:** $LINE
          **Column:** $COLUMN
          **Checker:** $CHECKER_NAME
          **Severity:** $SEVERITY
          **Message:** $MESSAGE

          Please:
          1. Review the issue and the surrounding code context
          2. Apply a fix that addresses the root cause
          3. Ensure the fix follows the project's coding standards
          4. Make sure the fix doesn't introduce new issues
          5. Keep changes minimal and focused on fixing this specific issue

          Create a PR with title: fix(clangsa): Fix $CHECKER_NAME issue in $FILE_PATH"

          # Determine base branch
          if [ "${{ github.event_name }}" = "schedule" ]; then
            BASE_BRANCH="main"
          else
            BASE_BRANCH="${{ github.ref_name }}"
          fi

          echo "=== Creating Copilot coding agent task ==="
          echo "Repository: ${{ github.repository }}"
          echo "Base branch: $BASE_BRANCH"
          echo "Prompt: $PROMPT"
          echo ""

          # Use gh agent-task create to start a Copilot coding agent session
          # This will create a PR using Copilot's native mechanism
          RESULT=$(gh agent-task create "$PROMPT" \
            --repo "${{ github.repository }}" \
            --base "$BASE_BRANCH" \
            --json url,number,sessionUrl 2>&1) || {
            echo "Failed to create agent task: $RESULT"
            echo "task-created=false" >> "$GITHUB_OUTPUT"
            exit 0
          }

          echo "Agent task result: $RESULT"

          # Parse the result
          PR_URL=$(echo "$RESULT" | jq -r '.url // empty')
          PR_NUMBER=$(echo "$RESULT" | jq -r '.number // empty')
          SESSION_URL=$(echo "$RESULT" | jq -r '.sessionUrl // empty')

          if [ -n "$PR_URL" ]; then
            echo "task-created=true" >> "$GITHUB_OUTPUT"
            echo "pr-url=$PR_URL" >> "$GITHUB_OUTPUT"
            echo "pr-number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
            echo "session-url=$SESSION_URL" >> "$GITHUB_OUTPUT"
          else
            echo "task-created=true" >> "$GITHUB_OUTPUT"
            echo "session-url=$SESSION_URL" >> "$GITHUB_OUTPUT"
            # The PR URL may not be immediately available; the session URL allows tracking
          fi

      - name: Output to job summary
        if: steps.select-issue.outputs.has-issues == 'true'
        run: |
          echo "## ðŸ¤– Copilot Coding Agent Task" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ steps.create-agent-task.outputs.task-created }}" = "true" ]; then
            echo "GitHub Copilot coding agent has been assigned to fix a Clang Static Analyzer issue:" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "**Issue Details:**" >> "$GITHUB_STEP_SUMMARY"
            echo "- **File:** \`${{ steps.select-issue.outputs.file-path }}\`" >> "$GITHUB_STEP_SUMMARY"
            echo "- **Line:** ${{ steps.select-issue.outputs.line }}" >> "$GITHUB_STEP_SUMMARY"
            echo "- **Checker:** \`${{ steps.select-issue.outputs.checker-name }}\`" >> "$GITHUB_STEP_SUMMARY"
            echo "- **Severity:** ${{ steps.select-issue.outputs.severity }}" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"

            if [ -n "${{ steps.create-agent-task.outputs.pr-url }}" ]; then
              echo "**Pull Request:** [${{ steps.create-agent-task.outputs.pr-url }}](${{ steps.create-agent-task.outputs.pr-url }})" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
            fi

            if [ -n "${{ steps.create-agent-task.outputs.session-url }}" ]; then
              echo "**Session:** [${{ steps.create-agent-task.outputs.session-url }}](${{ steps.create-agent-task.outputs.session-url }})" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "_Copilot is working on the fix. The PR will be created when Copilot finishes._" >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            echo "Failed to create Copilot coding agent task. Check the logs for details." >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "" >> "$GITHUB_STEP_SUMMARY"

      - name: Output no issues summary
        if: steps.select-issue.outputs.has-issues != 'true'
        run: |
          echo "## ðŸ¤– Copilot Coding Agent Task" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "No Clang Static Analyzer issues found to fix." >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ steps.download-json.outcome }}" = "failure" ]; then
            echo "**Note:** Could not download issue data." >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "This could mean:" >> "$GITHUB_STEP_SUMMARY"
            echo "- The previous run had no static analysis issues" >> "$GITHUB_STEP_SUMMARY"
            echo "- The HTML report parsing failed to extract issues" >> "$GITHUB_STEP_SUMMARY"
            echo "- The artifact has expired" >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "" >> "$GITHUB_STEP_SUMMARY"

  publish-clangsa-pages:
    name: ðŸ“„ Publish CSA HTML to GitHub Pages
    needs: [ clang-static-analyzer, download-previous-results ]
    if: ${{ always() && (needs.clang-static-analyzer.result == 'success' || needs.download-previous-results.result == 'success') }}
    runs-on: ubuntu-latest

    steps:
      - name: Download CodeChecker reports artifact
        uses: actions/download-artifact@v4
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: site

      - name: Add .nojekyll
        run: touch site/.nojekyll

      - name: Publish to blozano-tt/clangsa-results (gh-pages)
        uses: peaceiris/actions-gh-pages@v4
        with:
          personal_token: ${{ secrets.CLANGSA_RESULTS_PAT }}
          external_repository: blozano-tt/clangsa-results
          publish_branch: gh-pages
          publish_dir: site
          force_orphan: true
          commit_message: "Update CSA reports from tt-metal @ ${{ github.sha }}"

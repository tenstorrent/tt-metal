name: "Code analysis"

on:
  schedule:
    - cron: "0 2 * * 1,3,5" # Static analysis: 2 AM UTC on Mon/Wed/Fri
  workflow_call:
    inputs:
      distro:
        required: false
        type: string
        default: "ubuntu"
      version:
        required: false
        type: string
        default: "24.04"
      architecture:
        required: false
        type: string
        default: "amd64"
      enable-static-analysis:
        description: "Enable Clang Static Analyzer (CSA) via CodeChecker"
        required: false
        type: boolean
        default: false
      previous-run-id:
        description: "Run ID of a previous workflow to download CodeChecker results from (skips analysis)"
        required: false
        type: string
        default: ""
      enable-copilot-fix:
        description: "Enable Copilot to automatically fix one ClangSA issue and create a PR"
        required: false
        type: boolean
        default: false
  workflow_dispatch:
    inputs:
      distro:
        required: false
        type: string
        default: "ubuntu"
      version:
        required: false
        type: string
        default: "24.04"
      architecture:
        required: false
        type: string
        default: "amd64"
      enable-static-analysis:
        description: "Enable Clang Static Analyzer (CSA) via CodeChecker"
        required: false
        type: boolean
        default: false
      previous-run-id:
        description: "Run ID of a previous workflow to download CodeChecker results from (skips analysis)"
        required: false
        type: string
        default: ""
      enable-copilot-fix:
        description: "Enable Copilot to automatically fix one ClangSA issue and create a PR"
        required: false
        type: boolean
        default: false

jobs:
  determine-scan-type:
    runs-on: ubuntu-latest
    outputs:
      do-full-scan: ${{ steps.compute-outputs.outputs.do-full-scan }}
      do-scan: ${{ steps.compute-outputs.outputs.do-scan }}
    steps:
      - id: find-changes
        uses: tenstorrent/tt-metal/.github/actions/find-changed-files@v0.63.0

      - id: compute-outputs
        shell: bash
        run: |
          do_full_scan=$([[ "${{ github.ref_name }}" == "main" || "${{ steps.find-changes.outputs.clang-tidy-config-changed }}" == "true" ]] && echo "true" || echo "false")
          do_scan=$([[ "$do_full_scan" == "true" || "${{ steps.find-changes.outputs.any-code-changed }}" == "true" || "${{ steps.find-changes.outputs.cmake-changed }}" == "true" ]] && echo "true" || echo "false")
          echo "Do a scan: $do_scan"
          echo "Do a full scan: $do_full_scan"
          echo "do-full-scan=$do_full_scan" >> "$GITHUB_OUTPUT"
          echo "do-scan=$do_scan" >> "$GITHUB_OUTPUT"

  build-docker-image:
    uses: ./.github/workflows/build-docker-artifact.yaml
    permissions:
      packages: write
    secrets: inherit
    with:
      distro: ${{ inputs.distro || 'ubuntu' }}
      version: ${{ inputs.version || '24.04' }}
      architecture: ${{ inputs.architecture || 'amd64' }}

  clang-tidy:
    name: ðŸ¤– Clang Tidy
    needs: [ build-docker-image, determine-scan-type ]
    if: ${{ needs.determine-scan-type.outputs.do-scan == 'true' }}
    runs-on: tt-ubuntu-2204-xlarge-stable
    environment: ${{ github.ref == 'refs/heads/main' && 'mainline' || '' }}
    container:
      image: harbor.ci.tenstorrent.net/${{ needs.build-docker-image.outputs.ci-build-tag || 'docker-image-unresolved!'}}
      env:
        CCACHE_REMOTE_ONLY: "true"
        CCACHE_TEMPDIR: /tmp/ccache
      volumes:
        - ${{ github.workspace }}:/work
        - /home/ubuntu/.ccache-ci:/github/home/.ccache # HOME is hardcoded for no clear reason: https://github.com/actions/runner/issues/863
      # Group 1457 is for the shared ccache drive
      # tmpfs is for efficiency
      options: >
        --group-add 1457
        --tmpfs /tmp
    defaults:
      run:
        shell: bash
        working-directory: /work # https://github.com/actions/runner/issues/878
    steps:
      - name: Check Redis credentials
        # Failing internal jobs draws attention immediately so we can fix them and make them fast.
        # Forks will never have secrets; don't fail the job for them, they'll just run slower
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        run: |
          if [ -z "${{ secrets.REDIS_PASSWORD }}" ]; then
            echo "Redis password is missing. Did you forget 'secrets: inherit'?"
            exit 1
          fi
          # Conditionally set this here so that it remains unset on forks, otherwise it resolves an invalid URL and the job fails
          CCACHE_REMOTE_STORAGE="redis://${{ vars.REDIS_USER }}:${{ secrets.REDIS_PASSWORD }}@${{ vars.REDIS_HOST }}:${{ vars.REDIS_PORT }}|read-only=${{ vars.REDIS_IS_READONLY }}"
          echo "CCACHE_REMOTE_STORAGE=${CCACHE_REMOTE_STORAGE}" >> $GITHUB_ENV
          echo "CCACHE_REMOTE_STORAGE: ${CCACHE_REMOTE_STORAGE}"

      - name: Create ccache tmpdir
        run: |
          mkdir -p /tmp/ccache

      - name: Check out repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: recursive
          clean: true

      - name: Configure git safe.directory
        run: git config --global --add safe.directory /work

      - name: Determine merge base
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          echo "Current branch: ${{ github.ref_name }}"
          MERGE_BASE=$(git merge-base ${{ github.ref_name }} origin/main)
          echo "Merge base between ${{ github.ref_name }} and main: $MERGE_BASE"
          echo "MERGE_BASE=$MERGE_BASE" >> $GITHUB_ENV

      - name: Check out baseline
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ env.MERGE_BASE }}
          fetch-depth: 0
          fetch-tags: true
          submodules: recursive
          clean: true

      - name: Create shim
        run: |
          # Suppress clang-tidy to first get an up-to-date build tree
          ln -sf /usr/bin/true ./clang-tidy-shim

      - name: ðŸ”§ CMake configure
        run: |
          cmake --preset clang-tidy -DCMAKE_CXX_CLANG_TIDY="$(pwd)/clang-tidy-shim;--warnings-as-errors=*" -DCMAKE_C_CLANG_TIDY="$(pwd)/clang-tidy-shim;--warnings-as-errors=*"

      - name: Prepare baseline ccache summary
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          # Zero out the stats so we can see how we did this build
          # NOTE: may be inaccurate if we have >1 build runner on the same machine, using the same local cache
          ccache -z

      - name: ðŸ› ï¸ Baseline Build
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          cmake --build --preset clang-tidy

      - name: Publish Ccache summary
        if: ${{ needs.determine-scan-type.outputs.do-full-scan != 'true' }}
        run: |
          echo '## CCache Summary' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ccache -s >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: recursive
          clean: false

      - name: Restore shim
        run: |
          # Restore shim to legit clang-tidy
          # Symlink tomfoolery here so that Ninja believes the build command has not changed from the previous run
          ln -sf $(which clang-tidy-20) ./clang-tidy-shim

      - name: Prepare ccache summary
        run: |
          # Zero out the stats so we can see how we did this build
          # NOTE: may be inaccurate if we have >1 build runner on the same machine, using the same local cache
          ccache -z

      - name: ðŸ” Analyze code with clang-tidy
        run: |
          cmake --build --preset clang-tidy

      - name: Publish Ccache summary
        run: |
          echo '## CCache Summary' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ccache -s >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  clang-static-analyzer:
    name: ðŸ”¬ Clang Static Analyzer
    needs: [ build-docker-image ]
    if: ${{ (inputs.enable-static-analysis == true || github.event_name == 'schedule') && inputs.previous-run-id == '' }}
    runs-on: tt-ubuntu-2204-xlarge-stable
    container:
      image: harbor.ci.tenstorrent.net/${{ needs.build-docker-image.outputs.ci-build-tag || 'docker-image-unresolved!'}}
      volumes:
        - ${{ github.workspace }}:/work
        - ${{ github.workspace }}/../../_actions:${{ github.workspace }}/../../_actions # HACK: make actions available inside container
      options: --tmpfs /tmp
    defaults:
      run:
        shell: bash
        working-directory: /work # https://github.com/actions/runner/issues/878
    steps:
      - name: Check out repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: recursive

      - name: Configure git safe.directory
        run: git config --global --add safe.directory /work

      - name: ðŸ”§ CMake configure
        run: cmake --preset clang-static-analyzer

      - name: ðŸ› ï¸ Generate files
        run: cmake --build .build/clang-static-analyzer --target all_generated_files

      - name: Setup clang symlinks for CodeChecker
        run: |
          update-alternatives --install /usr/bin/clang clang /usr/bin/clang-20 100
          update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-20 100

      - name: Install CodeChecker
        run: |
          # Pre-install CodeChecker in the container's venv using uv.
          # Pin to a specific version for reproducibility.
          uv pip install codechecker==6.27.1

      - name: ðŸ”¬ Analyze with CodeChecker
        uses: blozano-tt/CodeChecker-Action@v1.0.5-tt
        id: codechecker
        with:
          logfile: /work/.build/clang-static-analyzer/compile_commands.json
          llvm-version: ignore # Already installed in our Docker container
          config: /work/.codechecker.json
          version: ignore # Already installed in our Docker container

      - name: Upload CodeChecker HTML reports
        uses: actions/upload-artifact@v4
        if: always()
        timeout-minutes: 10
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: ${{ steps.codechecker.outputs.result-html-dir }}

      - name: Find and upload raw CodeChecker reports
        id: find-raw-reports
        if: always()
        run: |
          set -euo pipefail
          echo "=== Searching for CodeChecker plist reports ==="

          # CodeChecker-Action typically stores reports in various locations
          # Try to find the directory containing plist files
          POSSIBLE_DIRS=(
            "/work/.codechecker_reports"
            "/work/codechecker_reports"
            "/tmp/codechecker_reports"
            "${{ steps.codechecker.outputs.result-html-dir }}/../reports"
            "${{ steps.codechecker.outputs.result-html-dir }}/reports"
          )

          RAW_REPORTS_DIR=""

          # First check the possible directories
          for dir in "${POSSIBLE_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              echo "Found directory: $dir"
              if find "$dir" -name "*.plist" -type f 2>/dev/null | head -1 | grep -q .; then
                RAW_REPORTS_DIR="$dir"
                echo "Found plist files in: $dir"
                break
              fi
            fi
          done

          # If not found, search more broadly
          if [ -z "$RAW_REPORTS_DIR" ]; then
            echo "Searching for plist files in /work and /tmp..."
            PLIST_FILE=$(find /work /tmp -name "*.plist" -type f 2>/dev/null | head -1 || true)
            if [ -n "$PLIST_FILE" ]; then
              RAW_REPORTS_DIR=$(dirname "$PLIST_FILE")
              echo "Found plist files in: $RAW_REPORTS_DIR"
            fi
          fi

          if [ -n "$RAW_REPORTS_DIR" ] && [ -d "$RAW_REPORTS_DIR" ]; then
            echo "raw-reports-dir=$RAW_REPORTS_DIR" >> "$GITHUB_OUTPUT"
            echo "has-raw-reports=true" >> "$GITHUB_OUTPUT"
            PLIST_COUNT=$(find "$RAW_REPORTS_DIR" -name "*.plist" -type f | wc -l)
            echo "Found $PLIST_COUNT plist files"
          else
            echo "No raw reports directory found"
            echo "has-raw-reports=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload raw CodeChecker reports (plist)
        uses: actions/upload-artifact@v4
        if: always() && steps.find-raw-reports.outputs.has-raw-reports == 'true'
        timeout-minutes: 10
        with:
          name: CodeChecker-Raw-Reports
          path: ${{ steps.find-raw-reports.outputs.raw-reports-dir }}

      - name: Extract CodeChecker issues to JSON
        id: extract-issues
        if: always()
        run: |
          set -euo pipefail
          REPORT_DIR="${{ steps.codechecker.outputs.result-html-dir }}"
          if [ ! -d "$REPORT_DIR" ]; then
            echo "No CodeChecker reports found"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # CodeChecker stores reports in a specific structure
          # Try to find the actual report directory (contains plist files or can be parsed)
          # First, try to find plist files or the reports subdirectory
          REPORTS_BASE=""

          # Look for a reports subdirectory
          if [ -d "$REPORT_DIR/reports" ]; then
            REPORTS_BASE="$REPORT_DIR/reports"
          # Look for plist files in the directory
          elif find "$REPORT_DIR" -name "*.plist" -type f | head -1 | grep -q .; then
            REPORTS_BASE="$REPORT_DIR"
          # Try parent directory (sometimes reports are one level up)
          elif [ -d "$(dirname "$REPORT_DIR")/reports" ]; then
            REPORTS_BASE="$(dirname "$REPORT_DIR")/reports"
          else
            # Last resort: try the HTML dir itself
            REPORTS_BASE="$REPORT_DIR"
          fi

          echo "Using report directory: $REPORTS_BASE"

          # Export issues to JSON using CodeChecker parse
          JSON_OUTPUT="/tmp/codechecker_issues.json"
          if CodeChecker parse "$REPORTS_BASE" --export json > "$JSON_OUTPUT" 2>&1; then
            # Check if we have any issues
            if [ ! -s "$JSON_OUTPUT" ]; then
              echo "Empty JSON output from CodeChecker"
              echo "has-issues=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Try to parse as JSON array
            ISSUE_COUNT=$(jq 'if type == "array" then length else 0 end' "$JSON_OUTPUT" 2>/dev/null || echo "0")
            if [ "$ISSUE_COUNT" = "0" ]; then
              echo "No issues found in CodeChecker reports"
              echo "has-issues=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "Found $ISSUE_COUNT issues"
            echo "has-issues=true" >> "$GITHUB_OUTPUT"
            echo "issue-count=$ISSUE_COUNT" >> "$GITHUB_OUTPUT"

            # Upload JSON for use in next job
            cp "$JSON_OUTPUT" /work/codechecker_issues.json
          else
            echo "Failed to parse CodeChecker reports (this may be normal if no issues found)"
            cat "$JSON_OUTPUT" || true
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

      - name: Upload CodeChecker issues JSON
        uses: actions/upload-artifact@v4
        if: steps.extract-issues.outputs.has-issues == 'true'
        with:
          name: CodeChecker-Issues-JSON
          path: /work/codechecker_issues.json

  # Job to download CodeChecker artifacts from a previous workflow run
  download-previous-results:
    name: ðŸ“¥ Download Previous Results
    if: ${{ inputs.previous-run-id != '' }}
    runs-on: ubuntu-latest
    outputs:
      has-issues: ${{ steps.extract-issues.outputs.has-issues }}
    steps:
      # Download HTML reports (contains *.plist.html files with all issue info)
      - name: Download CodeChecker HTML Reports from previous run
        uses: actions/download-artifact@v4
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: /tmp/previous-html
          run-id: ${{ inputs.previous-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract issues from HTML reports
        id: extract-issues
        run: |
          set -euo pipefail
          REPORT_DIR="/tmp/previous-html"

          # Find all .plist.html files (each contains embedded JSON with full issue details)
          mapfile -t PLIST_HTML_FILES < <(find "$REPORT_DIR" -name "*.plist.html" -type f 2>/dev/null | head -100)
          FILE_COUNT="${#PLIST_HTML_FILES[@]}"

          echo "Found $FILE_COUNT plist.html files"

          if [ "$FILE_COUNT" = "0" ]; then
            echo "No issues found in CodeChecker HTML reports"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract the embedded JSON from HTML files
          # The HTML contains: var data = {"files": {...}, "reports": [...]}
          JSON_OUTPUT="/tmp/codechecker_issues.json"
          echo "[" > "$JSON_OUTPUT"

          FIRST=true
          TOTAL_ISSUES=0
          for html_file in "${PLIST_HTML_FILES[@]}"; do
            [ -z "$html_file" ] && continue

            # Extract the JSON data from the HTML (it's in a "var data = {...}" line)
            # Use grep to find the line and sed to extract just the JSON
            DATA_LINE=$(grep -o 'var data = {.*};' "$html_file" 2>/dev/null | head -1 || true)

            if [ -z "$DATA_LINE" ]; then
              echo "Warning: Could not extract data from $html_file"
              continue
            fi

            # Extract just the JSON object (remove "var data = " prefix and ";" suffix)
            JSON_DATA=$(echo "$DATA_LINE" | sed 's/^var data = //; s/;$//')

            # Extract reports array and append to our output
            REPORTS=$(echo "$JSON_DATA" | jq -c '.reports[]?' 2>/dev/null || true)

            if [ -z "$REPORTS" ]; then
              continue
            fi

            while IFS= read -r report; do
              [ -z "$report" ] && continue
              TOTAL_ISSUES=$((TOTAL_ISSUES + 1))

              if [ "$FIRST" = true ]; then
                FIRST=false
              else
                echo "," >> "$JSON_OUTPUT"
              fi

              echo "$report" >> "$JSON_OUTPUT"
            done <<< "$REPORTS"
          done

          echo "]" >> "$JSON_OUTPUT"

          echo "Total issues extracted: $TOTAL_ISSUES"

          if [ "$TOTAL_ISSUES" = "0" ]; then
            echo "No issues found in CodeChecker HTML reports"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "has-issues=true" >> "$GITHUB_OUTPUT"
          echo "issue-count=$TOTAL_ISSUES" >> "$GITHUB_OUTPUT"

          echo "=== Sample of extracted issues ==="
          jq '.[0:3]' "$JSON_OUTPUT" || cat "$JSON_OUTPUT"

      - name: Upload extracted issues JSON
        if: steps.extract-issues.outputs.has-issues == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: CodeChecker-Issues-JSON
          path: /tmp/codechecker_issues.json

      - name: Re-upload HTML reports as current workflow artifact
        uses: actions/upload-artifact@v4
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: /tmp/previous-html

  copilot-fix-clangsa-issue:
    name: ðŸ¤– Copilot Fix ClangSA Issue
    needs: [ clang-static-analyzer, download-previous-results ]
    # Run if: (analysis ran successfully OR we downloaded from previous run) AND copilot fix is enabled
    if: |
      always() &&
      inputs.enable-copilot-fix == true &&
      (needs.clang-static-analyzer.result == 'success' || needs.download-previous-results.result == 'success')
    runs-on: ubuntu-latest
    outputs:
      pr-url: ${{ steps.create-pr.outputs.pr-url }}
      pr-created: ${{ steps.create-pr.outputs.pr-created }}
    steps:
      - name: Download CodeChecker issues JSON
        id: download-json
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: CodeChecker-Issues-JSON
          path: /tmp

      - name: Check if issues exist and prepare list
        id: select-issue
        run: |
          set -euo pipefail
          if [ ! -f "/tmp/codechecker_issues.json" ]; then
            echo "No CodeChecker issues found"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          ISSUE_COUNT=$(jq 'if type == "array" then length else 0 end' /tmp/codechecker_issues.json 2>/dev/null || echo "0")

          if [ "$ISSUE_COUNT" = "0" ] || [ -z "$ISSUE_COUNT" ]; then
            echo "No issues found"
            echo "has-issues=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found $ISSUE_COUNT issues"
          echo "has-issues=true" >> "$GITHUB_OUTPUT"
          echo "issue-count=$ISSUE_COUNT" >> "$GITHUB_OUTPUT"

          # Format a list of issues for Copilot to choose from (max 15 to keep prompt reasonable)
          ISSUE_LIST=$(jq -r '
            [.[:15][] | {
              file: (.path // .fileId | sub("^/work/"; "")),
              line: .line,
              checker: (.checker.name // .checker),
              severity: .severity,
              message: .message
            }] | to_entries | .[] |
            "\(.key + 1). **\(.value.severity)** - `\(.value.checker)` in `\(.value.file):\(.value.line)`\n   Message: \(.value.message)"
          ' /tmp/codechecker_issues.json)

          echo "=== Issues to present to Copilot ==="
          echo "$ISSUE_LIST"

          # Save to file for the next step (avoiding output escaping issues)
          echo "$ISSUE_LIST" > /tmp/issue_list.txt

      - name: Check out repo for Copilot
        if: steps.select-issue.outputs.has-issues == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.AUTO_TRIAGE_TOKEN }}

      - name: Setup Node.js
        if: steps.select-issue.outputs.has-issues == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install GitHub Copilot CLI
        if: steps.select-issue.outputs.has-issues == 'true'
        run: |
          npm install -g @github/copilot
          copilot --version || (echo "Copilot CLI installation failed" && exit 1)

      - name: Run Copilot to fix issue and create PR
        if: steps.select-issue.outputs.has-issues == 'true'
        id: copilot-fix
        env:
          COPILOT_GITHUB_TOKEN: ${{ secrets.AUTO_TRIAGE_TOKEN }}
          GH_TOKEN: ${{ secrets.AUTO_TRIAGE_TOKEN }}
        run: |
          set -euo pipefail

          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Determine base branch
          if [ "${{ github.event_name }}" = "schedule" ]; then
            BASE_BRANCH="main"
          else
            BASE_BRANCH="${{ github.ref_name }}"
          fi

          # Build prompt
          ISSUE_LIST=$(cat /tmp/issue_list.txt)

          read -r -d '' PROMPT << 'PROMPT_EOF' || true
          You are operating in a CI environment with no interactive approval.

          The Clang Static Analyzer found issues in this repository. Here are some of them:

          PROMPT_EOF

          PROMPT="${PROMPT}

          ${ISSUE_LIST}

          Please:
          1. Review these issues and choose ONE that is:
             - A real bug (not a false positive)
             - Safe to fix without changing program behavior
             - Reasonably straightforward to address
          2. Examine the code to understand the context
          3. Apply a minimal fix that addresses the root cause
          4. Ensure the fix follows the project's coding standards
          5. Create a new branch, commit the fix, push it, and create a PR
             - Branch name: copilot/fix-clangsa-TIMESTAMP (use current timestamp)
             - PR title: fix(clangsa): Fix [checker] in [filename]
             - Target branch: ${BASE_BRANCH}

          Note: Some of these may be false positives. Use your judgment to pick a genuine issue that can be safely fixed.
          "

          echo "=== Prompt ==="
          echo "$PROMPT"
          echo "=== End of prompt ==="

          echo ""
          echo "=== Launching GitHub Copilot CLI ==="

          # Save base branch for later steps
          echo "base-branch=$BASE_BRANCH" >> "$GITHUB_OUTPUT"

          # Use programmatic mode with --allow-all-tools for CI environment
          copilot -p "$PROMPT" --allow-all-tools || {
            echo "Copilot execution failed"
            echo "copilot-success=false" >> "$GITHUB_OUTPUT"
            exit 0
          }

          echo "copilot-success=true" >> "$GITHUB_OUTPUT"

      - name: Check for changes and create PR if needed
        if: steps.copilot-fix.outputs.copilot-success == 'true'
        id: create-pr
        env:
          GH_TOKEN: ${{ secrets.AUTO_TRIAGE_TOKEN }}
        run: |
          set -euo pipefail

          BASE_BRANCH="${{ steps.copilot-fix.outputs.base-branch }}"

          # Check if Copilot already created a PR
          EXISTING_PR=$(gh pr list --head "copilot/" --json number --jq '.[0].number' 2>/dev/null || true)
          if [ -n "$EXISTING_PR" ]; then
            echo "Copilot already created PR #$EXISTING_PR"
            PR_URL=$(gh pr view "$EXISTING_PR" --json url --jq '.url')
            echo "pr-url=$PR_URL" >> "$GITHUB_OUTPUT"
            echo "pr-created=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Check if there are any changes (staged, unstaged, or untracked)
          if git diff --quiet && git diff --cached --quiet && [ -z "$(git ls-files --others --exclude-standard)" ]; then
            echo "No changes detected - Copilot may not have made any fixes"
            echo "pr-created=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Changes detected - creating PR manually"

          # Create a branch with timestamp
          BRANCH_NAME="copilot/fix-clangsa-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"

          # Stage all changes
          git add -A

          # Commit
          git commit -m "fix(clangsa): Automated fix from Clang Static Analyzer

          This fix was generated by GitHub Copilot based on Clang Static Analyzer findings.

          Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"

          # Push
          git push -u origin "$BRANCH_NAME"

          # Create PR
          PR_URL=$(gh pr create \
            --title "fix(clangsa): Automated fix from Clang Static Analyzer" \
            --body "## ðŸ¤– Automated Clang Static Analyzer Fix

          This PR was automatically generated by GitHub Copilot to fix a Clang Static Analyzer issue.

          **Generated by:** GitHub Copilot CLI
          **Workflow run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          Please review the changes carefully before merging." \
            --base "$BASE_BRANCH" \
            --head "$BRANCH_NAME")

          echo "Created PR: $PR_URL"
          echo "pr-url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "pr-created=true" >> "$GITHUB_OUTPUT"

      - name: Output to job summary
        if: steps.select-issue.outputs.has-issues == 'true'
        run: |
          echo "## ðŸ¤– Copilot Coding Agent Task" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ steps.create-pr.outputs.pr-created }}" = "true" ]; then
            echo "âœ… **Success!** GitHub Copilot analyzed the Clang Static Analyzer issues and created a fix." >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "**Pull Request:** [${{ steps.create-pr.outputs.pr-url }}](${{ steps.create-pr.outputs.pr-url }})" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "Please review the changes carefully before merging." >> "$GITHUB_STEP_SUMMARY"
          elif [ "${{ steps.copilot-fix.outputs.copilot-success }}" = "true" ]; then
            echo "âš ï¸ Copilot ran successfully but no changes were made." >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "This could mean:" >> "$GITHUB_STEP_SUMMARY"
            echo "- All issues were determined to be false positives" >> "$GITHUB_STEP_SUMMARY"
            echo "- The issues were too complex to fix automatically" >> "$GITHUB_STEP_SUMMARY"
            echo "- Copilot decided not to make changes" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âŒ Copilot task did not complete successfully. Check the logs for details." >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "" >> "$GITHUB_STEP_SUMMARY"

      - name: Output no issues summary
        if: steps.select-issue.outputs.has-issues != 'true'
        run: |
          echo "## ðŸ¤– Copilot Coding Agent Task" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "No Clang Static Analyzer issues found to fix." >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ steps.download-json.outcome }}" = "failure" ]; then
            echo "**Note:** Could not download issue data." >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "This could mean:" >> "$GITHUB_STEP_SUMMARY"
            echo "- The previous run had no static analysis issues" >> "$GITHUB_STEP_SUMMARY"
            echo "- The HTML report parsing failed to extract issues" >> "$GITHUB_STEP_SUMMARY"
            echo "- The artifact has expired" >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "" >> "$GITHUB_STEP_SUMMARY"

  publish-clangsa-pages:
    name: ðŸ“„ Publish CSA HTML to GitHub Pages
    needs: [ clang-static-analyzer, download-previous-results ]
    if: ${{ always() && (needs.clang-static-analyzer.result == 'success' || needs.download-previous-results.result == 'success') }}
    runs-on: ubuntu-latest

    steps:
      - name: Download CodeChecker reports artifact
        uses: actions/download-artifact@v4
        with:
          name: CodeChecker-Static-Analysis-Reports
          path: site

      - name: Add .nojekyll
        run: touch site/.nojekyll

      - name: Publish to blozano-tt/clangsa-results (gh-pages)
        uses: peaceiris/actions-gh-pages@v4
        with:
          personal_token: ${{ secrets.CLANGSA_RESULTS_PAT }}
          external_repository: blozano-tt/clangsa-results
          publish_branch: gh-pages
          publish_dir: site
          force_orphan: true
          commit_message: "Update CSA reports from tt-metal @ ${{ github.sha }}"

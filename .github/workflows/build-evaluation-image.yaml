name: "Build Evaluation Image"

permissions:
  packages: write

on:
  workflow_call:
    inputs:
      evaluation-image-tag:
        required: false
        description: "(default: sha-run_id)"
        type: string
        default: ""
      build-args:
        required: false
        description: "Additional build arguments to pass to docker build"
        type: string
        default: ""
      buildkit:
        required: false
        description: "Whether to use BuildKit remote build or local docker installation"
        type: boolean
        default: false
      runner-label:
        required: false
        description: "runner requires kvm when buildkit disabled"
        type: string
        default: "tt-ubuntu-2204-large-stable"
      cache-from:
        required: false
        description: "Cache from option for docker build"
        type: string
        default: ""
      cache-to:
        required: false
        description: "Cache to option for docker build"
        type: string
        default: ""
      push-to-harbor:
        required: false
        description: "Whether to push the built image to Harbor registry"
        type: boolean
        default: true
      push-to-ghcr:
        required: false
        description: "Whether to push the built image to GitHub Container Registry"
        type: boolean
        default: false
    outputs:
      evaluation-image-url:
        description: "Docker image URL(s) for the evaluation image"
        value: ${{ jobs.build-evaluation-image.outputs.evaluation-image-url }}
  workflow_dispatch:
    inputs:
      evaluation-image-tag:
        required: false
        description: "(default: github sha)"
        type: string
        default: ""
      build-args:
        required: false
        description: "Additional build arguments to pass to docker build"
        type: string
        default: ""
      buildkit:
        required: false
        description: "Whether to use BuildKit remote build or local docker installation"
        type: boolean
        default: false
      runner-label:
        required: false
        description: "runner requires kvm when buildkit disabled"
        type: string
        default: "tt-ubuntu-2204-large-stable"
      cache-from:
        required: false
        description: "Cache from option for docker build"
        type: string
        default: "type=inline"
      cache-to:
        required: false
        description: "Cache to option for docker build"
        type: string
        default: "type=inline"
      push-to-harbor:
        required: false
        description: "Whether to push the built image to Harbor registry"
        type: boolean
        default: true
      push-to-ghcr:
        required: false
        description: "Whether to push the built image to GitHub Container Registry"
        type: boolean
        default: false

env:
  BUILDKIT_HOST: buildkitd.buildkit.svc.cluster.local
  BUILDKIT_PORT: 1234

jobs:
  # Compute tool image tags for pre-built dependencies
  # These are the same tags computed in build-docker-artifact.yaml
  check-tool-images:
    runs-on: ubuntu-latest
    outputs:
      ccache-tag: ${{ steps.tags.outputs.ccache-tag }}
      sfpi-tag: ${{ steps.tags.outputs.sfpi-tag }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Compute tool image tags
        id: tags
        run: |
          # Extract versions from Dockerfile.tools
          CCACHE_VERSION=$(grep -E "^ARG CCACHE_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          # SFPI version comes from tt_metal/sfpi-version (single source of truth)
          SFPI_VERSION=$(grep -E "^sfpi_version=" tt_metal/sfpi-version | cut -d"'" -f2)

          # Compute hashes for each tool (install script content)
          CCACHE_HASH=$(cat dockerfile/scripts/install-ccache.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          SFPI_HASH=$(cat dockerfile/scripts/install-sfpi.sh tt_metal/sfpi-version | sha1sum | cut -d' ' -f1 | head -c 8)

          # Generate tags: ghcr.io/<repo>/tt-metalium/tools/<tool>:<version>-<hash>
          BASE="ghcr.io/${{ github.repository }}/tt-metalium/tools"
          echo "ccache-tag=${BASE}/ccache:${CCACHE_VERSION}-${CCACHE_HASH}" >> $GITHUB_OUTPUT
          echo "sfpi-tag=${BASE}/sfpi:${SFPI_VERSION}-${SFPI_HASH}" >> $GITHUB_OUTPUT

  build-evaluation-image:
    name: "Build and push"
    needs: check-tool-images
    runs-on: ${{ inputs.runner-label }}
    timeout-minutes: 30
    outputs:
      evaluation-image-url: ${{ steps.docker-metadata.outputs.tags }}
    steps:
      - name: ⬇️ Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set evaluation image metadata
        id: evaluation-image-metadata
        run: |
          # Construct tag
          if [ -z "${{ inputs.evaluation-image-tag }}" ]; then
            eval_image_tag="${{ github.sha }}-${{ github.run_id }}"
          else
            eval_image_tag="${{ inputs.evaluation-image-tag }}"
          fi
          echo "Evaluation image tag: $eval_image_tag"

          # Construct image URLs
          image_urls=()
          if [ "${{ inputs.push-to-harbor }}" = "true" ]; then
            image_urls+=("harbor.ci.tenstorrent.net/evaluation/tt-metalium")
          fi
          if [ "${{ inputs.push-to-ghcr }}" = "true" ]; then
            image_urls+=("ghcr.io/tenstorrent/evaluation/tt-metalium")
          fi

          evaluation_image_names=$(IFS=$'\n' ; echo "${image_urls[*]}")

          echo "Evaluation image names: $evaluation_image_names"

          echo "evaluation-image-names=$evaluation_image_names" >> $GITHUB_OUTPUT
          echo "evaluation-image-tag=$eval_image_tag" >> $GITHUB_OUTPUT

      - name: Login to Harbor Container Registry
        if: ${{ inputs.push-to-harbor }}
        uses: docker/login-action@v3
        with:
          registry: harbor.ci.tenstorrent.net
          username: ${{ secrets.HARBOR_PUSH_USER }}
          password: ${{ secrets.HARBOR_PUSH_PASSWORD }}

      - name: Login to GitHub Container Registry
        if: ${{ inputs.push-to-ghcr }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify BuildKit connection
        if: ${{ inputs.buildkit }}
        run: |
          nc -zv ${{ env.BUILDKIT_HOST }} ${{ env.BUILDKIT_PORT }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        if: ${{ inputs.buildkit }}
        with:
          driver: remote
          endpoint: tcp://${{ env.BUILDKIT_HOST }}:${{ env.BUILDKIT_PORT }}
        env:
          BUILDER_NODE_0_AUTH_TLS_CACERT: ${{ secrets.BUILDKIT_CA_CERT }}
          BUILDER_NODE_0_AUTH_TLS_CERT: ${{ secrets.BUILDKIT_CERT }}
          BUILDER_NODE_0_AUTH_TLS_KEY: ${{ secrets.BUILDKIT_KEY }}

      - name: Extract metadata (tags, labels)
        id: docker-metadata
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.evaluation-image-metadata.outputs.evaluation-image-names }}
          tags: |
            # Tag as 'latest' for pushes to main branch
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.evaluation-image-metadata.outputs.evaluation-image-tag }}

      - name: Build and push Evaluation image
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.evaluation
          tags: ${{ steps.docker-metadata.outputs.tags }}
          labels: ${{ steps.docker-metadata.outputs.labels }}
          build-args: |
            TOOL_CCACHE_IMAGE=${{ needs.check-tool-images.outputs.ccache-tag }}
            TOOL_SFPI_IMAGE=${{ needs.check-tool-images.outputs.sfpi-tag }}
            ${{ inputs.build-args }}
          secrets: |
            CCACHE_REMOTE_STORAGE=redis://${{ vars.REDIS_USER }}:${{ secrets.REDIS_PASSWORD }}@${{ vars.REDIS_HOST }}:${{ vars.REDIS_PORT }}|read-only=${{ vars.REDIS_IS_READONLY }}
          cache-from: ${{ inputs.cache-from }}
          cache-to: ${{ inputs.cache-to }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

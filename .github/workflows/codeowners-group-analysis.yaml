name: CodeOwners Group Analysis

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch name to analyze (e.g., feature-branch-name)'
        required: true
        type: string
      create-new-comment:
        description: 'Create a new comment instead of editing existing one'
        required: false
        default: false
        type: boolean
      ping-pending-owners:
        description: 'Ping 2 random owners from pending approval groups'
        required: false
        default: false
        type: boolean
      send-slack-notification:
        description: 'Send ping notification to Slack channel'
        required: false
        default: false
        type: boolean
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  parse-comment:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.parse.outputs.should-run }}
      branch: ${{ steps.parse.outputs.branch }}
      create-new-comment: ${{ steps.parse.outputs.create-new-comment }}
      ping-pending-owners: ${{ steps.parse.outputs.ping-pending-owners }}
      send-slack-notification: ${{ steps.parse.outputs.send-slack-notification }}
      pr-number: ${{ steps.parse.outputs.pr-number }}
    steps:
      - name: Parse comment and get PR info
        id: parse
        run: |
          COMMENT_BODY="${{ github.event.comment.body }}"
          PR_NUMBER="${{ github.event.issue.number }}"
          COMMENT_AUTHOR="${{ github.event.comment.user.login }}"

          echo "Comment body: $COMMENT_BODY"
          echo "PR number: $PR_NUMBER"
          echo "Comment author: $COMMENT_AUTHOR"

          # Check if comment contains our trigger commands
          if echo "$COMMENT_BODY" | grep -E "^/codeowners?(\s|$)" > /dev/null; then
            # Add reaction to acknowledge we saw the command
            curl -s -X POST \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              -d '{"content": "eyes"}' \
              "https://api.github.com/repos/${{ github.repository }}/issues/comments/${{ github.event.comment.id }}/reactions"

            # Check if comment author is a member of tenstorrent organization
            MEMBERSHIP_API="https://api.github.com/orgs/tenstorrent/members/$COMMENT_AUTHOR"
            MEMBERSHIP_HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${{ secrets.ORG_READ_GITHUB_TOKEN }}" \
                                   -H "Accept: application/vnd.github.v3+json" \
                                   "$MEMBERSHIP_API")

            echo "Membership check for $COMMENT_AUTHOR: HTTP $MEMBERSHIP_HTTP_CODE"

            # HTTP 204 = member, HTTP 404 = not a member or private membership, HTTP 302 = public member
            if [ "$MEMBERSHIP_HTTP_CODE" = "204" ] || [ "$MEMBERSHIP_HTTP_CODE" = "302" ]; then
              echo "✅ User $COMMENT_AUTHOR is a member of tenstorrent organization"
              echo "should-run=true" >> $GITHUB_OUTPUT
              echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT

              # Get PR branch information
              PR_API="https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER"
              PR_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                             -H "Accept: application/vnd.github.v3+json" \
                             "$PR_API")

              BRANCH=$(echo "$PR_DATA" | jq -r '.head.ref')
              echo "branch=$BRANCH" >> $GITHUB_OUTPUT
              echo "Found branch: $BRANCH"

              # Parse command options
              if echo "$COMMENT_BODY" | grep -E "^/codeowners?\s+new(\s|$)" > /dev/null; then
                echo "create-new-comment=true" >> $GITHUB_OUTPUT
                echo "ping-pending-owners=false" >> $GITHUB_OUTPUT
                echo "send-slack-notification=false" >> $GITHUB_OUTPUT
                echo "Command: new comment"
              elif echo "$COMMENT_BODY" | grep -E "^/codeowners?\s+ping(\s|$)" > /dev/null; then
                echo "create-new-comment=false" >> $GITHUB_OUTPUT
                echo "ping-pending-owners=true" >> $GITHUB_OUTPUT
                # echo "send-slack-notification=true" >> $GITHUB_OUTPUT  # Slack temporarily disabled
                echo "send-slack-notification=false" >> $GITHUB_OUTPUT
                echo "Command: ping owners"
              else
                # Default: update existing comment
                echo "create-new-comment=false" >> $GITHUB_OUTPUT
                echo "ping-pending-owners=false" >> $GITHUB_OUTPUT
                echo "send-slack-notification=false" >> $GITHUB_OUTPUT
                echo "Command: update existing comment"
              fi

              # Add success reaction
              curl -s -X POST \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                -d '{"content": "rocket"}' \
                "https://api.github.com/repos/${{ github.repository }}/issues/comments/${{ github.event.comment.id }}/reactions"

            else
              echo "❌ User $COMMENT_AUTHOR is not a member of tenstorrent organization (HTTP $MEMBERSHIP_HTTP_CODE)"
              echo "should-run=false" >> $GITHUB_OUTPUT

              # Add unauthorized reaction
              curl -s -X POST \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                -d '{"content": "-1"}' \
                "https://api.github.com/repos/${{ github.repository }}/issues/comments/${{ github.event.comment.id }}/reactions"

              # Post a reply comment explaining the restriction
              REPLY_MESSAGE="❌ **Access Denied**: Only members of the \`tenstorrent\` organization can use CodeOwners commands.\n\nIf you believe this is an error, please contact a repository maintainer."

              # Create JSON payload for the reply
              TEMP_JSON_FILE=$(mktemp)
              jq -n --arg body "$REPLY_MESSAGE" '{"body": $body}' > "$TEMP_JSON_FILE"

              curl -s -X POST \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                --data-binary @"$TEMP_JSON_FILE" \
                "https://api.github.com/repos/${{ github.repository }}/issues/$PR_NUMBER/comments"

              rm -f "$TEMP_JSON_FILE"
            fi
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "Comment does not contain trigger commands"
          fi

  find-pr:
    needs: [parse-comment]
    if: always() && (github.event_name == 'workflow_dispatch' || (github.event_name == 'issue_comment' && needs.parse-comment.outputs.should-run == 'true'))
    runs-on: ubuntu-latest
    outputs:
      pr-number: ${{ steps.find-pr.outputs.pr-number }}
      pr-exists: ${{ steps.find-pr.outputs.pr-exists }}
    steps:
      - name: Find PR for branch
        id: find-pr
        run: |
          # Determine branch and PR based on trigger type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH="${{ github.event.inputs.branch }}"
            echo "Manual trigger - Looking for PR associated with branch: $BRANCH"

            # Use GitHub API to find PR for the branch
            API_URL="https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:$BRANCH&state=open"

            echo "API URL: $API_URL"

            # Get PR data
            PR_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                           -H "Accept: application/vnd.github.v3+json" \
                           "$API_URL")

            # Extract PR number
            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number // empty')

            if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
              echo "Found PR #$PR_NUMBER for branch $BRANCH"
              echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
              echo "pr-exists=true" >> $GITHUB_OUTPUT
            else
              echo "No open PR found for branch $BRANCH"
              echo "pr-number=" >> $GITHUB_OUTPUT
              echo "pr-exists=false" >> $GITHUB_OUTPUT
            fi
          else
            # Comment trigger - PR info is already available
            PR_NUMBER="${{ needs.parse-comment.outputs.pr-number }}"
            BRANCH="${{ needs.parse-comment.outputs.branch }}"
            echo "Comment trigger - Using PR #$PR_NUMBER for branch $BRANCH"
            echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "pr-exists=true" >> $GITHUB_OUTPUT
          fi

  get-reviews:
    needs: [find-pr]
    if: always() && needs.find-pr.outputs.pr-exists == 'true'
    runs-on: ubuntu-latest
    outputs:
      approved-reviewers: ${{ steps.get-reviews.outputs.approved-reviewers }}
    steps:
      - name: Get PR reviews and team members
        id: get-reviews
        run: |
          PR_NUMBER="${{ needs.find-pr.outputs.pr-number }}"

          # Get PR reviews using GitHub API
          REVIEWS_API="https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/reviews"
          REVIEWS_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                           -H "Accept: application/vnd.github.v3+json" \
                           "$REVIEWS_API" 2>/dev/null)

          # Check if API call was successful
          REVIEWS_HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                           -H "Accept: application/vnd.github.v3+json" \
                           "$REVIEWS_API")

          # Extract approved reviews (state: APPROVED)
          if [ "$REVIEWS_HTTP_CODE" = "200" ] && [ -n "$REVIEWS_DATA" ] && [ "$REVIEWS_DATA" != "null" ]; then
            APPROVED_REVIEWERS=$(echo "$REVIEWS_DATA" | jq -r '.[] | select(.state == "APPROVED") | .user.login' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
          else
            echo "Warning: Could not fetch PR reviews (HTTP $REVIEWS_HTTP_CODE)"
            APPROVED_REVIEWERS=""
          fi

          echo "approved-reviewers=$APPROVED_REVIEWERS" >> $GITHUB_OUTPUT

  analyze-codeowners:
    needs: [find-pr, get-reviews]
    if: always() && needs.find-pr.outputs.pr-exists == 'true'
    runs-on: ubuntu-latest
    outputs:
      codeowners-groups: ${{ steps.analyze.outputs.codeowners-groups }}
      codeowners-teams: ${{ steps.analyze.outputs.codeowners-teams }}
      codeowners-individuals: ${{ steps.analyze.outputs.codeowners-individuals }}
      changed-files: ${{ steps.analyze.outputs.changed-files }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR changed files
        id: get-files
        run: |
          PR_NUMBER="${{ needs.find-pr.outputs.pr-number }}"

          # Get all changed files using GitHub API (handle pagination)
          rm -f changed_files.txt

          PAGE=1
          TOTAL_FILES=0
          while true; do
            FILES_API="https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/files?per_page=100&page=$PAGE"
            FILES_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                             -H "Accept: application/vnd.github.v3+json" \
                             "$FILES_API")

            # Check if we got any data
            if [ -z "$FILES_DATA" ] || [ "$FILES_DATA" = "null" ] || [ "$FILES_DATA" = "[]" ]; then
              break
            fi

            # Extract filenames from this page and append to file
            PAGE_FILES=$(echo "$FILES_DATA" | jq -r '.[].filename' 2>/dev/null)
            if [ -z "$PAGE_FILES" ] || [ "$PAGE_FILES" = "null" ]; then
              break
            fi

            # Count files in this page
            PAGE_COUNT=$(echo "$PAGE_FILES" | wc -l)
            TOTAL_FILES=$((TOTAL_FILES + PAGE_COUNT))

            # Append to file
            echo "$PAGE_FILES" >> changed_files.txt

            PAGE=$((PAGE + 1))

            # Safety check to avoid infinite loop
            if [ $PAGE -gt 10 ]; then
              echo "Warning: Too many pages, stopping at page $PAGE"
              break
            fi
          done

          # Sort, remove duplicates and empty lines
          if [ -f changed_files.txt ]; then
            sort changed_files.txt | uniq | sed '/^$/d' > changed_files_sorted.txt
            mv changed_files_sorted.txt changed_files.txt
          fi

          # Count files and show first few
          FILE_COUNT=$(wc -l < changed_files.txt 2>/dev/null || echo 0)
          echo "Found $FILE_COUNT changed files across $((PAGE-1)) pages (total from API: $TOTAL_FILES)"
          echo "First 10 files:"
          head -10 changed_files.txt

          # Save files list for next step
          {
            echo "changed-files<<EOF"
            cat changed_files.txt
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Install codeowners package and analyze
        id: analyze
        run: |
          # Install required package
          pip install codeowners

          # Embedded Python script for CODEOWNERS analysis
          python3 - changed_files.txt .github/CODEOWNERS << 'EOF'
          #!/usr/bin/env python3
          """
          CodeOwners Analysis Script - Embedded Version
          """

          import os
          import sys
          import json
          import urllib.request
          from urllib.error import HTTPError

          # Import codeowners package (required)
          try:
              from codeowners import CodeOwners
          except ImportError:
              print("Error: codeowners package is required but not installed.")
              print("Install it with: pip install codeowners")
              sys.exit(1)


          def get_user_full_name(username):
              """Get full name for a GitHub username using GitHub API."""
              if not username or not username.startswith("@"):
                  return username

              # Remove @ prefix for API call
              clean_username = username[1:]  # Remove @

              # Skip API calls for team names (containing /)
              if "/" in clean_username:
                  return clean_username

              # Try both tokens
              token = (
                  os.environ.get("GITHUB_TOKEN") or os.environ.get("ORG_READ_GITHUB_TOKEN") or os.environ.get("ORG_READ") or ""
              )

              if not token:
                  print(f"Warning: No token available for user lookup of {username}")
                  return clean_username

              try:
                  # Use GitHub API to get user information
                  url = f"https://api.github.com/users/{clean_username}"
                  req = urllib.request.Request(url)
                  req.add_header("Authorization", f"Bearer {token}")
                  req.add_header("Accept", "application/vnd.github.v3+json")
                  req.add_header("User-Agent", "GitHub-Actions-CodeOwners-Analysis")

                  with urllib.request.urlopen(req) as response:
                      if response.getcode() == 200:
                          user_data = json.loads(response.read().decode())
                          return user_data.get("name") or clean_username
                      else:
                          print(f"Warning: API returned {response.getcode()} for user {username}")
                          return clean_username
              except HTTPError as e:
                  if e.code == 401:
                      print(f"Warning: Unauthorized access for user {username} (insufficient token permissions)")
                  elif e.code == 403:
                      print(f"Warning: Forbidden access for user {username} (token lacks user:read scope)")
                  elif e.code == 404:
                      print(f"Warning: User {username} not found")
                  else:
                      print(f"Warning: HTTP error {e.code} for user {username}")
                  return clean_username
              except Exception as e:
                  print(f"Warning: Error getting name for {username}: {e}")
                  return clean_username


          def analyze_codeowners(changed_files_path, codeowners_path):
              """Analyze CODEOWNERS file and return required groups using codeowners package."""

              # Read changed files
              with open(changed_files_path, "r") as f:
                  changed_files = [line.strip() for line in f if line.strip()]

              print(f"Analyzing {len(changed_files)} changed files using codeowners package...")

              # Use codeowners package - read file content first
              with open(codeowners_path, "r") as f:
                  codeowners_content = f.read()

              co = CodeOwners(codeowners_content)

              # Parse CODEOWNERS file - find all unique patterns that match changed files
              # and collect their owners
              pattern_groups = {}  # pattern -> set of (username, full_name) tuples
              team_groups = set()
              processed_patterns = set()  # Track patterns we've already processed

              # First pass: find all unique patterns that match any changed files
              for file_path in changed_files:
                  matching_lines = list(co.matching_lines(file_path))
                  if matching_lines:
                      # GitHub CODEOWNERS precedence: last matching pattern takes precedence
                      # Sort by line number (highest first) and use only the most specific match
                      sorted_matches = sorted(matching_lines, key=lambda x: x[1], reverse=True)
                      best_match = sorted_matches[0]

                      print(
                          f"Found {len(matching_lines)} matching lines for {file_path}, using most specific (line {best_match[1]})"
                      )

                      # Use only the owners from the most specific match
                      if len(best_match) >= 3:
                          owners_list = best_match[0]  # First element is the owners list
                          pattern = best_match[2]  # Third element is the pattern

                          # Only process this pattern if we haven't seen it before
                          if pattern not in processed_patterns:
                              processed_patterns.add(pattern)

                              if pattern not in pattern_groups:
                                  pattern_groups[pattern] = set()

                              for owner_type, owner in owners_list:
                                  if owner_type == "TEAM":
                                      # This is a team
                                      team_groups.add(owner)
                                  elif owner_type in ["USERNAME", "EMAIL"]:
                                      # This is an individual - get full name and store both username and full name
                                      full_name = get_user_full_name(owner)
                                      # Store as tuple: (username, full_name)
                                      username = owner[1:] if owner.startswith("@") else owner  # Remove @ prefix if present
                                      pattern_groups[pattern].add((username, full_name))
                  else:
                      print(f"No matches found for {file_path}")

              # Create output - teams are separate, individuals are grouped by pattern
              teams_list = ",".join(sorted(team_groups))

              # For individuals, we need to group them by their patterns
              # Each pattern becomes a "group" that requires approval from any of its members
              pattern_groups_list = []
              for pattern, owners in pattern_groups.items():
                  if owners:  # Only include patterns that have individuals
                      # Format: pattern:username1|full_name1,username2|full_name2,... (username|full_name pairs)
                      owners_pairs = []
                      for username, full_name in sorted(owners, key=lambda x: x[1]):  # Sort by full name
                          owners_pairs.append(f"{username}|{full_name}")
                      owners_str = ",".join(owners_pairs)
                      pattern_groups_list.append(f"{pattern}:{owners_str}")

              individuals_list = "@@@".join(pattern_groups_list) if pattern_groups_list else ""

              # Combine all groups
              if teams_list and individuals_list:
                  all_groups = teams_list + "," + individuals_list
              elif teams_list:
                  all_groups = teams_list
              else:
                  all_groups = individuals_list

              print(f"Found {len(team_groups)} team groups and {len(pattern_groups)} pattern groups")
              print(f"Teams: {teams_list}")
              print(f"Individuals: {individuals_list}")

              return {
                  "all_groups": all_groups,
                  "teams": teams_list,
                  "individuals": individuals_list,
                  "changed_files": "\n".join(changed_files),
              }


          def main():
              """Main entry point when run as script."""
              if len(sys.argv) != 3:
                  print("Usage: python codeowners_analysis.py <changed_files.txt> <codeowners_path>")
                  sys.exit(1)

              changed_files_path = sys.argv[1]
              codeowners_path = sys.argv[2]

              if not os.path.exists(changed_files_path):
                  print(f"Error: Changed files path '{changed_files_path}' does not exist")
                  sys.exit(1)

              if not os.path.exists(codeowners_path):
                  print(f"Error: CODEOWNERS path '{codeowners_path}' does not exist")
                  sys.exit(1)

              result = analyze_codeowners(changed_files_path, codeowners_path)

              # Output in GitHub Actions format if GITHUB_OUTPUT is available
              github_output = os.environ.get("GITHUB_OUTPUT")
              if github_output:
                  # Clear the file first, then write
                  with open(github_output, "w") as f:
                      f.write("changed-files<<EOF\n")
                      f.write(result["changed_files"])
                      f.write("\nEOF\n")

                      f.write("codeowners-groups<<EOF\n")
                      f.write(result["all_groups"])
                      f.write("\nEOF\n")

                      f.write("codeowners-teams<<EOF\n")
                      f.write(result["teams"])
                      f.write("\nEOF\n")

                      f.write("codeowners-individuals<<EOF\n")
                      f.write(result["individuals"])
                      f.write("\nEOF\n")
              else:
                  # When run outside GitHub Actions, print results to stdout
                  print("\n" + "=" * 50)
                  print("RESULTS (for GitHub Actions):")
                  print("=" * 50)
                  print(f"changed-files={repr(result['changed_files'])}")
                  print(f"codeowners-groups={repr(result['all_groups'])}")
                  print(f"codeowners-teams={repr(result['teams'])}")
                  print(f"codeowners-individuals={repr(result['individuals'])}")
                  print("=" * 50)


          if __name__ == "__main__":
              main()
          EOF
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ORG_READ_GITHUB_TOKEN: ${{ secrets.ORG_READ_GITHUB_TOKEN }}

  post-comment:
    needs: [find-pr, analyze-codeowners, get-reviews, parse-comment]
    if: always() && needs.find-pr.outputs.pr-exists == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate comment data
        id: generate-comment
        run: |
          PR_NUMBER="${{ needs.find-pr.outputs.pr-number }}"
          TEAMS="${{ needs.analyze-codeowners.outputs.codeowners-teams }}"
          INDIVIDUALS="${{ needs.analyze-codeowners.outputs.codeowners-individuals }}"
          APPROVED_REVIEWERS="${{ needs.get-reviews.outputs.approved-reviewers }}"

          # Determine parameters based on trigger type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            CREATE_NEW="${{ github.event.inputs.create-new-comment }}"
            PING_OWNERS="${{ github.event.inputs.ping-pending-owners }}"
            SEND_SLACK="${{ github.event.inputs.send-slack-notification }}"
          else
            # Comment trigger - use parsed parameters
            CREATE_NEW="${{ needs.parse-comment.outputs.create-new-comment }}"
            PING_OWNERS="${{ needs.parse-comment.outputs.ping-pending-owners }}"
            SEND_SLACK="${{ needs.parse-comment.outputs.send-slack-notification }}"
          fi

          echo "Using parameters: CREATE_NEW=$CREATE_NEW, PING_OWNERS=$PING_OWNERS, SEND_SLACK=$SEND_SLACK"

          # Get team members for teams that need approval
          TEAM_MEMBERS=""
          if [ -n "$TEAMS" ]; then
            IFS=',' read -ra TEAM_ARRAY <<< "$TEAMS"
            for team in "${TEAM_ARRAY[@]}"; do
              # Remove @org/ prefix for API call
              clean_team=$(echo "$team" | sed 's/^@[^\/]*\///')

              # Get team members using GitHub API (using ORG_READ_GITHUB_TOKEN for org access)
              MEMBERS_API="https://api.github.com/orgs/tenstorrent/teams/$clean_team/members"
              MEMBERS_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.ORG_READ_GITHUB_TOKEN }}" \
                               -H "Accept: application/vnd.github.v3+json" \
                               "$MEMBERS_API" 2>/dev/null)

              # Check if API call was successful (HTTP 200)
              MEMBERS_HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${{ secrets.ORG_READ_GITHUB_TOKEN }}" \
                               -H "Accept: application/vnd.github.v3+json" \
                               "$MEMBERS_API")

              if [ "$MEMBERS_HTTP_CODE" = "200" ] && [ -n "$MEMBERS_DATA" ] && [ "$MEMBERS_DATA" != "null" ]; then
                # Extract member logins successfully
                TEAM_MEMBER_LOGINS=$(echo "$MEMBERS_DATA" | jq -r '.[].login' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
                if [ -n "$TEAM_MEMBER_LOGINS" ]; then
                  TEAM_MEMBERS="$TEAM_MEMBERS$team:$TEAM_MEMBER_LOGINS|"
                else
                  TEAM_MEMBERS="$TEAM_MEMBERS$team:no-members|"
                fi
              elif [ "$MEMBERS_HTTP_CODE" = "404" ]; then
                # Team not found
                echo "Warning: Team $clean_team not found (HTTP $MEMBERS_HTTP_CODE)"
                TEAM_MEMBERS="$TEAM_MEMBERS$team:team-not-found|"
              elif [ "$MEMBERS_HTTP_CODE" = "403" ]; then
                # Insufficient permissions
                echo "Warning: Insufficient permissions to access team $clean_team (HTTP $MEMBERS_HTTP_CODE)"
                TEAM_MEMBERS="$TEAM_MEMBERS$team:insufficient-permissions|"
              elif [ "$MEMBERS_HTTP_CODE" = "401" ]; then
                # Unauthorized
                echo "Warning: Unauthorized access to team $clean_team (HTTP $MEMBERS_HTTP_CODE)"
                TEAM_MEMBERS="$TEAM_MEMBERS$team:unauthorized|"
              else
                # Other error
                echo "Warning: Failed to fetch members for team $clean_team (HTTP $MEMBERS_HTTP_CODE)"
                TEAM_MEMBERS="$TEAM_MEMBERS$team:api-error|"
              fi
            done
          fi

          # Collect pending and approved groups separately
          PENDING_GROUPS=""
          APPROVED_GROUPS=""
          PENDING_COUNT=0
          APPROVED_COUNT=0

          # Display teams with member information and approval status
          if [ -n "$TEAMS" ]; then
            IFS=',' read -ra TEAM_ARRAY <<< "$TEAMS"
            for team in "${TEAM_ARRAY[@]}"; do
              # Skip the large-changes team as requested
              if [ "$team" = "@tenstorrent/metalium-codeowners-large-changes" ]; then
                continue
              fi

              # Remove @ prefix for display
              clean_team=$(echo "$team" | sed 's/^@//')

              # Get team members
              team_members_info=""
              approved_members=""

              # Check team members against approved reviewers
              if [ -n "$TEAM_MEMBERS" ]; then
                # Find this team's members (extract just this team's entry)
                team_members_entry=$(echo "$TEAM_MEMBERS" | tr '|' '\n' | grep "^$team:" | head -1)
                if [ -n "$team_members_entry" ]; then
                  team_owners=$(echo "$team_members_entry" | cut -d':' -f2)

                    if [ "$team_owners" = "insufficient-permissions" ]; then
                      # Token doesn't have permission to read team members
                      team_members_info="Members: (insufficient token permissions)"
                    elif [ "$team_owners" = "team-not-found" ]; then
                      # Team doesn't exist
                      team_members_info="Members: (team not found)"
                    elif [ "$team_owners" = "unauthorized" ]; then
                      # Unauthorized access
                      team_members_info="Members: (unauthorized access)"
                    elif [ "$team_owners" = "api-error" ]; then
                      # Other API error
                      team_members_info="Members: (API error)"
                    elif [ "$team_owners" = "no-members" ]; then
                      # Team exists but has no members
                      team_members_info="Members: (no members)"
                    else
                      # Get full names for team members
                      all_members=""
                      IFS=',' read -ra MEMBERS_ARRAY <<< "$team_owners"
                      for member in "${MEMBERS_ARRAY[@]}"; do
                        # Try to get full name for this team member
                        member_name="$member"  # Default to username
                        if [ -n "$member" ] && [ "$member" != " " ]; then
                          # Get user info from GitHub API
                          USER_API="https://api.github.com/users/$member"
                          USER_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.ORG_READ_GITHUB_TOKEN }}" \
                                         -H "Accept: application/vnd.github.v3+json" \
                                         "$USER_API" 2>/dev/null)
                          USER_NAME=$(echo "$USER_DATA" | jq -r '.name // empty' 2>/dev/null)
                          if [ -n "$USER_NAME" ] && [ "$USER_NAME" != "null" ]; then
                            member_name="$USER_NAME"
                          fi
                        fi
                        all_members="$all_members$member_name, "
                      done
                      # Remove trailing comma and space
                      all_members=$(echo "$all_members" | sed 's/, $//')
                      team_members_info="Members: $all_members"

                      # Check which members have approved
                      for member in "${MEMBERS_ARRAY[@]}"; do
                        if echo "$APPROVED_REVIEWERS" | grep -q "$member"; then
                          # Get full name for approved member
                          approved_name="$member"
                          USER_API="https://api.github.com/users/$member"
                          USER_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.ORG_READ_GITHUB_TOKEN }}" \
                                         -H "Accept: application/vnd.github.v3+json" \
                                         "$USER_API" 2>/dev/null)
                          USER_NAME=$(echo "$USER_DATA" | jq -r '.name // empty' 2>/dev/null)
                          if [ -n "$USER_NAME" ] && [ "$USER_NAME" != "null" ]; then
                            approved_name="$USER_NAME"
                          fi
                          approved_members="$approved_members$approved_name, "
                        fi
                      done
                    fi
                  fi
                fi

                if [ -n "$approved_members" ]; then
                  # Remove trailing comma and space
                  approved_members=$(echo "$approved_members" | sed 's/, $//')
                  APPROVED_GROUPS="$APPROVED_GROUPS\n- ✅ **$clean_team** (Team) - $team_members_info | **Approved by:** $approved_members"
                  APPROVED_COUNT=$((APPROVED_COUNT + 1))
                else
                  PENDING_GROUPS="$PENDING_GROUPS\n- ⏳ **$clean_team** (Team) - $team_members_info | **Pending approval**"
                  PENDING_COUNT=$((PENDING_COUNT + 1))
                fi
              done
            fi

            # Add pattern groups with member information and approval status
            if [ -n "$INDIVIDUALS" ]; then
              # Individuals are now grouped by pattern: "pattern:username1|full_name1,username2|full_name2@@@pattern2:..."
              IFS='@@@' read -ra PATTERN_GROUPS <<< "$INDIVIDUALS"
              for pattern_group in "${PATTERN_GROUPS[@]}"; do
                # Skip empty groups
                [ -z "$pattern_group" ] && continue

                # Split pattern:owners
                pattern=$(echo "$pattern_group" | cut -d':' -f1)
                owners=$(echo "$pattern_group" | cut -d':' -f2)

                # Parse owners - each is username|full_name
                all_owners=""
                usernames=()
                full_names=()

                IFS=',' read -ra OWNERS_ARRAY <<< "$owners"
                for owner_pair in "${OWNERS_ARRAY[@]}"; do
                  # Split username|full_name
                  username=$(echo "$owner_pair" | cut -d'|' -f1)
                  full_name=$(echo "$owner_pair" | cut -d'|' -f2)

                  usernames+=("$username")
                  full_names+=("$full_name")
                  all_owners="$all_owners$full_name, "
                done

                # Remove trailing comma and space
                all_owners=$(echo "$all_owners" | sed 's/, $//')

                # Check if any owner in this pattern group has approved
                approved_owners=""
                for i in "${!usernames[@]}"; do
                  username="${usernames[$i]}"
                  full_name="${full_names[$i]}"
                  if echo "$APPROVED_REVIEWERS" | grep -q "$username"; then
                    approved_owners="$approved_owners$full_name, "
                  fi
                done

                if [ -n "$approved_owners" ]; then
                  # Remove trailing comma and space
                  approved_owners=$(echo "$approved_owners" | sed 's/, $//')
                  APPROVED_GROUPS="$APPROVED_GROUPS\n- ✅ **$pattern** (Group) - Members: $all_owners | **Approved by:** $approved_owners"
                  APPROVED_COUNT=$((APPROVED_COUNT + 1))
                else
                  PENDING_GROUPS="$PENDING_GROUPS\n- ⏳ **$pattern** (Group) - Members: $all_owners | **Pending approval**"
                  PENDING_COUNT=$((PENDING_COUNT + 1))
                fi
              done
            fi

            # Combine pending groups first, then approved groups
            if [ -z "$TEAMS" ] && [ -z "$INDIVIDUALS" ]; then
              COMMENT="<!-- CodeOwners-Workflow-Bot -->\n## CodeOwners Analysis\n\nNo specific codeowners found for the changed files in this PR.\n\n**Required Approvals:** At least one maintainer approval is required."
            else
              COMMENT="<!-- CodeOwners-Workflow-Bot -->\n## CodeOwners Group Analysis\n\nThis PR requires approval from **one member of each** of the following groups:\n\n**Summary:** $PENDING_COUNT pending groups, $APPROVED_COUNT approved groups\n\n### Group Information:$PENDING_GROUPS$APPROVED_GROUPS\n\n**Note:** At least one approval from each group is sufficient."
            fi

            # Output comment for next step
            {
              echo "comment<<EOF"
              echo "$COMMENT"
              echo "EOF"
            } >> $GITHUB_OUTPUT

            # Output other data for next steps
            {
              echo "pr-number<<EOF"
              echo "$PR_NUMBER"
              echo "EOF"
              echo "team-members<<EOF"
              echo "$TEAM_MEMBERS"
              echo "EOF"
              echo "create-new<<EOF"
              echo "$CREATE_NEW"
              echo "EOF"
              echo "ping-owners<<EOF"
              echo "$PING_OWNERS"
              echo "EOF"
              echo "send-slack<<EOF"
              echo "$SEND_SLACK"
              echo "EOF"
            } >> $GITHUB_OUTPUT

      - name: Post comment to PR
        run: |
          PR_NUMBER="${{ steps.generate-comment.outputs.pr-number }}"
          COMMENT="${{ steps.generate-comment.outputs.comment }}"
          CREATE_NEW="${{ steps.generate-comment.outputs.create-new }}"

          # Get existing comments to find if we should edit or create new
          COMMENTS_API="https://api.github.com/repos/${{ github.repository }}/issues/$PR_NUMBER/comments"
          EXISTING_COMMENTS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                                -H "Accept: application/vnd.github.v3+json" \
                                "$COMMENTS_API")

          # Find existing comment from this workflow (starts with CodeOwners Analysis or contains our marker)
          # Get the most recent one by sorting by created_at descending
          EXISTING_COMMENT_ID=$(echo "$EXISTING_COMMENTS" | jq -r "[.[] | select(.body | startswith(\"## CodeOwners\") or contains(\"CodeOwners-Workflow-Bot\"))] | sort_by(.created_at) | reverse | .[0].id")

          if [ "$CREATE_NEW" = "true" ] || [ -z "$EXISTING_COMMENT_ID" ] || [ "$EXISTING_COMMENT_ID" = "null" ]; then
            # Create new comment
            echo "Creating new comment..."
            curl -s -X POST \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              -d "{\"body\": \"$COMMENT\"}" \
              "$COMMENTS_API"
          else
            # Edit existing comment
            echo "Updating existing comment (ID: $EXISTING_COMMENT_ID)..."
            curl -s -X PATCH \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              -d "{\"body\": \"$COMMENT\"}" \
              "https://api.github.com/repos/${{ github.repository }}/issues/comments/$EXISTING_COMMENT_ID"
          fi

          echo "Comment updated for PR #$PR_NUMBER"

      - name: Send notifications
        run: |
          PR_NUMBER="${{ steps.generate-comment.outputs.pr-number }}"
          TEAM_MEMBERS="${{ steps.generate-comment.outputs.team-members }}"
          TEAMS="${{ needs.analyze-codeowners.outputs.codeowners-teams }}"
          INDIVIDUALS="${{ needs.analyze-codeowners.outputs.codeowners-individuals }}"
          APPROVED_REVIEWERS="${{ needs.get-reviews.outputs.approved-reviewers }}"
          PING_OWNERS="${{ steps.generate-comment.outputs.ping-owners }}"
          SEND_SLACK="${{ steps.generate-comment.outputs.send-slack }}"

          # Define API endpoint
          COMMENTS_API="https://api.github.com/repos/${{ github.repository }}/issues/$PR_NUMBER/comments"

          # Validate PR_NUMBER
          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
            echo "ERROR: PR_NUMBER is not set or is null"
            exit 1
          fi

          echo "Generating ping message for pending owners..."

          # Get PR information
          PR_API="https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER"
          PR_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                         -H "Accept: application/vnd.github.v3+json" \
                         "$PR_API")
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
          PR_AUTHOR_LOGIN=$(echo "$PR_DATA" | jq -r '.user.login')
          PR_AUTHOR_NAME=$(echo "$PR_DATA" | jq -r '.user.name // .user.login')

          # Collect 2 owners from EACH pending group, then deduplicate
          TEMP_SELECTED_OWNERS=""

          # Process pending teams - select up to 2 owners from each pending team
          if [ -n "$TEAMS" ]; then
            IFS=',' read -ra TEAM_ARRAY <<< "$TEAMS"
            for team in "${TEAM_ARRAY[@]}"; do
              if [ "$team" = "@tenstorrent/metalium-codeowners-large-changes" ]; then
                continue
              fi
              if [ -n "$TEAM_MEMBERS" ]; then
                team_members_entry=$(echo "$TEAM_MEMBERS" | tr '|' '\n' | grep "^$team:" | head -1)
                if [ -n "$team_members_entry" ]; then
                  team_owners=$(echo "$team_members_entry" | cut -d':' -f2)
                  if [ "$team_owners" != "insufficient-permissions" ] && [ "$team_owners" != "team-not-found" ] && [ "$team_owners" != "unauthorized" ] && [ "$team_owners" != "api-error" ] && [ "$team_owners" != "no-members" ]; then
                    IFS=',' read -ra MEMBERS_ARRAY <<< "$team_owners"

                    # Check if any member of this team has approved
                    team_has_approval=false
                    for member in "${MEMBERS_ARRAY[@]}"; do
                      if echo "$APPROVED_REVIEWERS" | grep -q "$member"; then
                        team_has_approval=true
                        break
                      fi
                    done

                    # Only select owners from pending teams
                    if [ "$team_has_approval" = false ]; then
                      # Collect unapproved members for this team
                      TEAM_UNAPPROVED=""
                      for member in "${MEMBERS_ARRAY[@]}"; do
                        if ! echo "$APPROVED_REVIEWERS" | grep -q "$member"; then
                          TEAM_UNAPPROVED="$TEAM_UNAPPROVED$member,"
                        fi
                      done
                      TEAM_UNAPPROVED=$(echo "$TEAM_UNAPPROVED" | sed 's/,$//')

                      # Select up to 2 owners from this pending team
                      if [ -n "$TEAM_UNAPPROVED" ]; then
                        IFS=',' read -ra TEAM_MEMBERS_ARRAY <<< "$TEAM_UNAPPROVED"
                        TEAM_MEMBER_COUNT=${#TEAM_MEMBERS_ARRAY[@]}

                        if [ $TEAM_MEMBER_COUNT -eq 1 ]; then
                          # Only 1 member
                          TEMP_SELECTED_OWNERS="$TEMP_SELECTED_OWNERS${TEAM_MEMBERS_ARRAY[0]},"
                        elif [ $TEAM_MEMBER_COUNT -ge 2 ]; then
                          # Select 2 random members
                          RAND1=$((RANDOM % TEAM_MEMBER_COUNT))
                          RAND2=$((RANDOM % TEAM_MEMBER_COUNT))
                          while [ $RAND2 -eq $RAND1 ]; do
                            RAND2=$((RANDOM % TEAM_MEMBER_COUNT))
                          done
                          TEMP_SELECTED_OWNERS="$TEMP_SELECTED_OWNERS${TEAM_MEMBERS_ARRAY[$RAND1]},${TEAM_MEMBERS_ARRAY[$RAND2]},"
                        fi
                      fi
                    fi
                  fi
                fi
              fi
            done
          fi

          # Process pending individual patterns - select up to 2 owners from each pending pattern
          if [ -n "$INDIVIDUALS" ]; then
            IFS='@@@' read -ra PATTERN_GROUPS <<< "$INDIVIDUALS"
            for pattern_group in "${PATTERN_GROUPS[@]}"; do
              [ -z "$pattern_group" ] && continue
              pattern=$(echo "$pattern_group" | cut -d':' -f1)
              owners=$(echo "$pattern_group" | cut -d':' -f2)
              IFS=',' read -ra OWNERS_ARRAY <<< "$owners"

              # Check if any owner in this pattern has approved
              pattern_has_approval=false
              for owner_pair in "${OWNERS_ARRAY[@]}"; do
                username=$(echo "$owner_pair" | cut -d'|' -f1)
                if echo "$APPROVED_REVIEWERS" | grep -q "$username"; then
                  pattern_has_approval=true
                  break
                fi
              done

              # Only select owners from pending patterns
              if [ "$pattern_has_approval" = false ]; then
                # Collect unapproved owners for this pattern
                PATTERN_UNAPPROVED=""
                for owner_pair in "${OWNERS_ARRAY[@]}"; do
                  username=$(echo "$owner_pair" | cut -d'|' -f1)
                  if ! echo "$APPROVED_REVIEWERS" | grep -q "$username"; then
                    PATTERN_UNAPPROVED="$PATTERN_UNAPPROVED$username,"
                  fi
                done
                PATTERN_UNAPPROVED=$(echo "$PATTERN_UNAPPROVED" | sed 's/,$//')

                # Select up to 2 owners from this pending pattern
                if [ -n "$PATTERN_UNAPPROVED" ]; then
                  IFS=',' read -ra PATTERN_OWNERS_ARRAY <<< "$PATTERN_UNAPPROVED"
                  PATTERN_OWNER_COUNT=${#PATTERN_OWNERS_ARRAY[@]}

                  if [ $PATTERN_OWNER_COUNT -eq 1 ]; then
                    # Only 1 owner
                    TEMP_SELECTED_OWNERS="$TEMP_SELECTED_OWNERS${PATTERN_OWNERS_ARRAY[0]},"
                  elif [ $PATTERN_OWNER_COUNT -ge 2 ]; then
                    # Select 2 random owners
                    RAND1=$((RANDOM % PATTERN_OWNER_COUNT))
                    RAND2=$((RANDOM % PATTERN_OWNER_COUNT))
                    while [ $RAND2 -eq $RAND1 ]; do
                      RAND2=$((RANDOM % PATTERN_OWNER_COUNT))
                    done
                    TEMP_SELECTED_OWNERS="$TEMP_SELECTED_OWNERS${PATTERN_OWNERS_ARRAY[$RAND1]},${PATTERN_OWNERS_ARRAY[$RAND2]},"
                  fi
                fi
              fi
            done
          fi

          # Remove trailing comma and deduplicate the selected owners
          TEMP_SELECTED_OWNERS=$(echo "$TEMP_SELECTED_OWNERS" | sed 's/,$//')
          if [ -n "$TEMP_SELECTED_OWNERS" ]; then
            # Sort and deduplicate
            SELECTED_OWNERS=$(echo "$TEMP_SELECTED_OWNERS" | tr ',' '\n' | sort | uniq | tr '\n' ',' | sed 's/,$//')
          else
            SELECTED_OWNERS=""
          fi

          # Check if we have any owners to ping
          if [ -n "$SELECTED_OWNERS" ]; then
            # Get full names for selected owners and build ping message
            PING_MESSAGE="Hi"
            IFS=',' read -ra SELECTED_ARRAY <<< "$SELECTED_OWNERS"
            OWNER_COUNT=${#SELECTED_ARRAY[@]}
            for i in "${!SELECTED_ARRAY[@]}"; do
              owner="${SELECTED_ARRAY[$i]}"
              if [ -n "$owner" ]; then
                # Get user info
                USER_API="https://api.github.com/users/$owner"
                USER_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.ORG_READ_GITHUB_TOKEN }}" \
                               -H "Accept: application/vnd.github.v3+json" \
                               "$USER_API" 2>/dev/null)
                USER_NAME=$(echo "$USER_DATA" | jq -r '.name // empty' 2>/dev/null)
                if [ -n "$USER_NAME" ] && [ "$USER_NAME" != "null" ]; then
                  PING_MESSAGE="$PING_MESSAGE $USER_NAME [@$owner]"
                else
                  PING_MESSAGE="$PING_MESSAGE [@$owner]"
                fi

                # Add comma if not the last owner
                if [ $((i + 1)) -lt $OWNER_COUNT ]; then
                  PING_MESSAGE="$PING_MESSAGE,"
                fi
              fi
            done

            # Get full name for PR author
            PR_AUTHOR_FULL_NAME="$PR_AUTHOR_NAME"  # Default to what we got from PR API
            if [ "$PR_AUTHOR_FULL_NAME" = "$PR_AUTHOR_LOGIN" ] || [ -z "$PR_AUTHOR_FULL_NAME" ] || [ "$PR_AUTHOR_FULL_NAME" = "null" ]; then
              # Try to fetch full name from GitHub API
              AUTHOR_USER_API="https://api.github.com/users/$PR_AUTHOR_LOGIN"
              AUTHOR_USER_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.ORG_READ_GITHUB_TOKEN }}" \
                                     -H "Accept: application/vnd.github.v3+json" \
                                     "$AUTHOR_USER_API" 2>/dev/null)
              AUTHOR_FULL_NAME=$(echo "$AUTHOR_USER_DATA" | jq -r '.name // empty' 2>/dev/null)
              if [ -n "$AUTHOR_FULL_NAME" ] && [ "$AUTHOR_FULL_NAME" != "null" ]; then
                PR_AUTHOR_FULL_NAME="$AUTHOR_FULL_NAME"
              fi
            fi

            PING_MESSAGE="$PING_MESSAGE, this PR **[$PR_TITLE](${{ github.server_url }}/${{ github.repository }}/pull/$PR_NUMBER)** by $PR_AUTHOR_FULL_NAME [@$PR_AUTHOR_LOGIN] needs your approval/review to merge this."

            if [ "$PING_OWNERS" = "true" ]; then
              # Create new ping comment
              echo "Creating ping comment..."

              # Create temporary file to avoid shell interpretation of JSON
              TEMP_JSON_FILE=$(mktemp)
              if jq -n --arg body "$PING_MESSAGE" '{"body": $body}' > "$TEMP_JSON_FILE"; then
                echo "JSON file created successfully"
              else
                echo "Failed to create JSON file"
                exit 1
              fi
              RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};" -X POST \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                --data-binary @"$TEMP_JSON_FILE" \
                "$COMMENTS_API")
              # Clean up temp file
              rm -f "$TEMP_JSON_FILE"

              # Extract HTTP status code
              HTTP_STATUS=$(echo "$RESPONSE" | tr -d '\n' | sed -e 's/.*HTTPSTATUS://' | sed 's/;//')
              RESPONSE_BODY=$(echo "$RESPONSE" | sed -e 's/HTTPSTATUS:.*//')

              if [ "$HTTP_STATUS" = "201" ]; then
                echo "✅ Ping comment created successfully for PR #$PR_NUMBER"
              else
                echo "❌ ERROR: Failed to create ping comment (HTTP $HTTP_STATUS)"
                echo "Response body: $RESPONSE_BODY"
                echo "Full response: $RESPONSE"
                exit 1
              fi
            else
              # Just output the ping message to workflow logs
              echo "Ping message (not sent):"
              echo "$PING_MESSAGE"
            fi
          else
            echo "No pending owners to ping"
          fi

name: "Build tt-metal docker artifact"

# =============================================================================
# NAMING CONVENTION: Docker Image Tags
# =============================================================================
# This workflow outputs use the "-tag" suffix (e.g., ci-build-tag, dev-tag)
# to indicate these are Docker image tags that were built/verified.
#
# Consuming workflows (like build-artifact.yaml) accept these values via
# inputs with the "-docker-image" suffix (e.g., ci-build-docker-image) to
# indicate these are pre-built Docker images to use.
#
# Example usage:
#   build-docker-images:
#     uses: ./.github/workflows/build-docker-artifact.yaml
#   build:
#     uses: ./.github/workflows/build-artifact.yaml
#     with:
#       ci-build-docker-image: ${{ needs.build-docker-images.outputs.ci-build-tag }}
#
# TOOL IMAGES:
# Third-party tools (ccache, mold, doxygen, etc.) are built once and pushed to
# GHCR to avoid repeatedly hitting upstream endpoints. These tool images are
# versioned by tool version + install script hash, and are pulled by the main
# Dockerfile during builds.
# =============================================================================

# Required to push images to GHCR (organization or user). Without this you may see:
# "denied: installation not allowed to Create organization package"
permissions:
  packages: write

on:
  workflow_call:
    inputs:
      platform:
        required: false
        type: string
        default: "Ubuntu 22.04"
        description: "Platform to build Docker images for"
      architecture:
        required: false
        type: string
        default: "amd64"
      build-manylinux:
        required: false
        type: boolean
        default: true
        description: |
          When true, build the manylinux image. Set to false when build-all-docker-images
          calls this workflow for both platforms (22.04 and 24.04) in parallel‚Äîonly the
          22.04 run should build manylinux to avoid duplicate work. Standalone callers
          should leave true.
      tool-tags:
        required: false
        type: string
        default: ""
        description: |
          JSON object containing all tool image tags (from build-docker-tools.yaml).
          When provided, skips building tool images and uses these tags instead.
          Use with .github/actions/setup-tool-buildargs to extract individual tags.
          Example: ${{ needs.build-tools.outputs.tool-tags }}
    outputs:
      ci-build-tag:
        description: "Docker tag for the CI Build Docker image for building TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.ci-build-tag }}
      ci-test-tag:
        description: "Docker tag for the CI Test Docker image for testing TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.ci-test-tag }}
      dev-tag:
        description: "Docker tag for the dev Docker image for developing TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.dev-tag }}
      basic-dev-tag:
        description: "Docker tag for the basic dev Docker image for basic development"
        value: ${{ jobs.check-docker-images.outputs.basic-dev-tag }}
      basic-ttnn-runtime-tag:
        description: "Docker tag for the basic TTNN runtime Docker image for running TTNN"
        value: ${{ jobs.check-docker-images.outputs.basic-ttnn-runtime-tag }}
      manylinux-tag:
        description: "Docker tag for the manylinux Docker image for building TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.manylinux-tag }}
      # Tool image tags as JSON bundle
      # Use with .github/actions/setup-tool-buildargs to extract individual tags
      tool-tags:
        description: "JSON object containing all tool image tags"
        value: ${{ inputs.tool-tags || jobs.build-tools.outputs.tool-tags }}
      # Python venv image tags
      python-ci-build-venv-tag:
        description: "Docker tag for the Python CI Build venv image"
        value: ${{ jobs.build-python-venvs.outputs.ci-build-venv-tag }}
      python-ci-test-venv-tag:
        description: "Docker tag for the Python CI Test venv image"
        value: ${{ jobs.build-python-venvs.outputs.ci-test-venv-tag }}
  workflow_dispatch:
    inputs:
      platform:
        required: false
        type: choice
        default: "Ubuntu 22.04"
        options:
            - "Ubuntu 22.04"
            - "Ubuntu 24.04"
        description: "Platform to build Docker images for"
      architecture:
        required: false
        type: choice
        default: "amd64"
        options:
            - "amd64"
      build-manylinux:
        required: false
        type: boolean
        default: true
        description: |
          When true, build the manylinux image. Set to false when build-all-docker-images
          calls this workflow for both platforms (22.04 and 24.04) in parallel‚Äîonly the
          22.04 run should build manylinux to avoid duplicate work. Standalone callers
          should leave true.

jobs:
  # =============================================================================
  # TOOL IMAGES: Check and build third-party tool images (reusable workflow)
  # When tool-tags input is provided, caller has pre-built tools; skip building.
  # =============================================================================
  build-tools:
    if: inputs.tool-tags == ''
    uses: ./.github/workflows/build-docker-tools.yaml
    secrets: inherit

  # Resolve tool tags from either input (external) or build-tools job
  resolve-tools:
    runs-on: ubuntu-latest
    needs: build-tools
    if: always() && !failure() && !cancelled()
    outputs:
      tool-tags: ${{ steps.resolve.outputs.tool-tags }}
    steps:
      - name: Resolve tool tags source
        id: resolve
        run: |
          # Use input tool-tags if provided, otherwise use build-tools output
          if [ -n '${{ inputs.tool-tags }}' ]; then
            echo "Using external tool-tags from input"
            echo 'tool-tags=${{ inputs.tool-tags }}' >> $GITHUB_OUTPUT
          else
            echo "Using tool-tags from build-tools job"
            echo 'tool-tags=${{ needs.build-tools.outputs.tool-tags }}' >> $GITHUB_OUTPUT
          fi

  # =============================================================================
  # PYTHON VENV IMAGES: Check and build pre-built Python virtual environments
  # =============================================================================
  build-python-venvs:
    uses: ./.github/workflows/build-docker-python-venvs.yaml
    with:
      platform: ${{ inputs.platform }}
    secrets: inherit

  # =============================================================================
  # MAIN DOCKER IMAGES: Check and build CI/Dev/Test images
  # =============================================================================

  check-docker-images:
    runs-on: ubuntu-latest
    outputs:
      ci-build-exists: ${{ steps.images.outputs.ci-build-exists }}
      ci-build-tag: ${{ steps.tags.outputs.ci-build-tag }}
      ci-test-exists: ${{ steps.images.outputs.ci-test-exists }}
      ci-test-tag: ${{ steps.tags.outputs.ci-test-tag }}
      dev-exists: ${{ steps.images.outputs.dev-exists }}
      dev-tag: ${{ steps.tags.outputs.dev-tag }}
      basic-dev-exists: ${{ steps.images.outputs.basic-dev-exists }}
      basic-dev-tag: ${{ steps.tags.outputs.basic-dev-tag }}
      basic-ttnn-runtime-exists: ${{ steps.images.outputs.basic-ttnn-runtime-exists }}
      basic-ttnn-runtime-tag: ${{ steps.tags.outputs.basic-ttnn-runtime-tag }}
      manylinux-exists: ${{ steps.images.outputs.manylinux-exists }}
      manylinux-tag: ${{ steps.tags.outputs.manylinux-tag }}
      distro: ${{ steps.platform.outputs.distro }}
      version: ${{ steps.platform.outputs.version }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Parse platform
        id: platform
        uses: ./.github/actions/parse-platform
        with:
          platform: ${{ inputs.platform }}

      - name: Set environment variables
        run: |
          DISTRO="${{ steps.platform.outputs.distro }}"
          VERSION="${{ steps.platform.outputs.version }}"
          ARCH="${{ inputs.architecture || 'amd64' }}"

          echo "CI_BUILD_IMAGE_NAME=${DISTRO}-${VERSION}-ci-build-${ARCH}" >> $GITHUB_ENV
          echo "CI_TEST_IMAGE_NAME=${DISTRO}-${VERSION}-ci-test-${ARCH}" >> $GITHUB_ENV
          echo "DEV_IMAGE_NAME=${DISTRO}-${VERSION}-dev-${ARCH}" >> $GITHUB_ENV
          echo "BASIC_DEV_IMAGE_NAME=${DISTRO}-${VERSION}-basic-dev-${ARCH}" >> $GITHUB_ENV
          echo "BASIC_TTNN_RUNTIME_IMAGE_NAME=${DISTRO}-${VERSION}-basic-ttnn-runtime-${ARCH}" >> $GITHUB_ENV
          echo "MANYLINUX_IMAGE_NAME=manylinux-${ARCH}" >> $GITHUB_ENV

      - name: Compute tags
        id: tags
        run: |
          # Include workflow file and tool images Dockerfile in hash
          # Tool images are versioned separately, but changes to Dockerfile.tools
          # that affect the main build should trigger a rebuild
          EXTRA_FILES=".github/workflows/build-docker-artifact.yaml dockerfile/Dockerfile.tools"

          HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile $EXTRA_FILES)
          echo "ci-build-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.CI_BUILD_IMAGE_NAME }}:${HASH}" >> $GITHUB_OUTPUT
          echo "ci-test-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.CI_TEST_IMAGE_NAME }}:${HASH}" >> $GITHUB_OUTPUT
          echo "dev-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.DEV_IMAGE_NAME }}:${HASH}" >> $GITHUB_OUTPUT

          # basic-dev uses tool images (cmake, sfpi, openmpi, ccache), so include tool-related files in hash
          BASIC_DEV_EXTRA_FILES="$EXTRA_FILES"
          BASIC_DEV_HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile.basic-dev $BASIC_DEV_EXTRA_FILES)
          echo "basic-dev-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.BASIC_DEV_IMAGE_NAME }}:${BASIC_DEV_HASH}" >> $GITHUB_OUTPUT

          BASIC_TTNN_RUNTIME_HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile.basic-dev $BASIC_DEV_EXTRA_FILES)
          echo "basic-ttnn-runtime-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.BASIC_TTNN_RUNTIME_IMAGE_NAME }}:${BASIC_TTNN_RUNTIME_HASH}" >> $GITHUB_OUTPUT

          # Manylinux image copies OpenMPI from the tool image; include install-openmpi.sh
          # in its tag so that when the OpenMPI build method changes (e.g. git vs tarball,
          # which changes library SONAMEs), manylinux is rebuilt and the wheel sees the
          # correct library names.
          MANYLINUX_EXTRA_FILES="$EXTRA_FILES dockerfile/scripts/install-openmpi.sh"
          MANYLINUX_HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile.manylinux $MANYLINUX_EXTRA_FILES)
          echo "manylinux-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.MANYLINUX_IMAGE_NAME }}:${MANYLINUX_HASH}" >> $GITHUB_OUTPUT

      # Assume if dev-tag exists, the others will exist too
      - name: Query images exist
        id: images
        run: |
          if docker manifest inspect ${{ steps.tags.outputs.dev-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.dev-tag }} exists"
            echo "ci-build-exists=true" >> $GITHUB_OUTPUT
            echo "ci-test-exists=true" >> $GITHUB_OUTPUT
            echo "dev-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.dev-tag }} does not exist"
            echo "ci-build-exists=false" >> $GITHUB_OUTPUT
            echo "ci-test-exists=false" >> $GITHUB_OUTPUT
            echo "dev-exists=false" >> $GITHUB_OUTPUT
          fi

          if docker manifest inspect ${{ steps.tags.outputs.basic-dev-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.basic-dev-tag }} exists"
            echo "basic-dev-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.basic-dev-tag }} does not exist"
            echo "basic-dev-exists=false" >> $GITHUB_OUTPUT
          fi
          if docker manifest inspect ${{ steps.tags.outputs.basic-ttnn-runtime-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.basic-ttnn-runtime-tag }} exists"
            echo "basic-ttnn-runtime-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.basic-ttnn-runtime-tag }} does not exist"
            echo "basic-ttnn-runtime-exists=false" >> $GITHUB_OUTPUT
          fi

          if docker manifest inspect ${{ steps.tags.outputs.manylinux-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.manylinux-tag }} exists"
            echo "manylinux-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.manylinux-tag }} does not exist"
            echo "manylinux-exists=false" >> $GITHUB_OUTPUT
          fi

  # Build Ubuntu images
  build-ubuntu-images:
    name: "üê≥Ô∏è Build Ubuntu images"
    needs: [check-docker-images, resolve-tools, build-python-venvs]
    # Run if distro is ubuntu AND (main images missing OR basic images missing)
    # Use always() to run even when tool/venv build jobs inside build-tools/build-python-venvs are skipped (all exist)
    if: |
      always() && !failure() && !cancelled() &&
      needs.resolve-tools.result == 'success' &&
      needs.check-docker-images.outputs.distro == 'ubuntu' &&
      (needs.check-docker-images.outputs.dev-exists != 'true' ||
       needs.check-docker-images.outputs.basic-dev-exists != 'true' ||
       needs.check-docker-images.outputs.basic-ttnn-runtime-exists != 'true')
    timeout-minutes: 90
    runs-on: tt-ubuntu-2204-large-stable
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup tool build args
        id: tools
        uses: ./.github/actions/setup-tool-buildargs
        with:
          tool-tags: ${{ needs.resolve-tools.outputs.tool-tags }}
      - name: Setup build args
        id: buildargs
        run: |
          # Main images need all tools + python venvs
          {
            echo "main<<EOF"
            echo "UBUNTU_VERSION=${{ needs.check-docker-images.outputs.version }}"
            echo "${{ steps.tools.outputs.build-args }}"
            echo "PYTHON_CI_BUILD_VENV_IMAGE=${{ needs.build-python-venvs.outputs.ci-build-venv-tag }}"
            echo "PYTHON_CI_TEST_VENV_IMAGE=${{ needs.build-python-venvs.outputs.ci-test-venv-tag }}"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          # Basic-dev needs only a subset of tools
          {
            echo "basic-dev<<EOF"
            echo "UBUNTU_VERSION=${{ needs.check-docker-images.outputs.version }}"
            echo "TOOL_CMAKE_IMAGE=${{ steps.tools.outputs.cmake-tag }}"
            echo "TOOL_SFPI_IMAGE=${{ steps.tools.outputs.sfpi-tag }}"
            echo "TOOL_OPENMPI_IMAGE=${{ steps.tools.outputs.openmpi-tag }}"
            echo "TOOL_CCACHE_IMAGE=${{ steps.tools.outputs.ccache-tag }}"
            echo "EOF"
          } >> $GITHUB_OUTPUT
      - name: Build and push CI Build image
        if: needs.check-docker-images.outputs.dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile
          target: ci-build
          tags: ${{ needs.check-docker-images.outputs.ci-build-tag }}
          build-args: ${{ steps.buildargs.outputs.main }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push CI Test image
        if: needs.check-docker-images.outputs.dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile
          target: ci-test
          tags: ${{ needs.check-docker-images.outputs.ci-test-tag }}
          build-args: ${{ steps.buildargs.outputs.main }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push Dev image
        if: needs.check-docker-images.outputs.dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile
          target: dev
          tags: ${{ needs.check-docker-images.outputs.dev-tag }}
          build-args: ${{ steps.buildargs.outputs.main }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push Basic Dev image
        if: needs.check-docker-images.outputs.basic-dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.basic-dev
          target: base
          tags: ${{ needs.check-docker-images.outputs.basic-dev-tag }}
          build-args: ${{ steps.buildargs.outputs.basic-dev }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push Basic TTNN runtime image
        if: needs.check-docker-images.outputs.basic-ttnn-runtime-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.basic-dev
          target: basic-ttnn-runtime
          tags: ${{ needs.check-docker-images.outputs.basic-ttnn-runtime-tag }}
          build-args: ${{ steps.buildargs.outputs.basic-dev }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

  # Build ManyLinux image (runs in parallel with Ubuntu)
  build-manylinux-image:
    name: "üê≥Ô∏è Build ManyLinux image"
    needs: [check-docker-images, resolve-tools]
    # Run if manylinux needs build AND tool images are ready AND this run is responsible for manylinux
    # Use always() to run even when build-tool-images job inside build-tools is skipped (all exist)
    # When build-manylinux input is false (e.g. second platform in build-all-docker-images), skip so manylinux is built only once
    if: |
      always() && !failure() && !cancelled() &&
      needs.resolve-tools.result == 'success' &&
      needs.check-docker-images.outputs.manylinux-exists != 'true' &&
      inputs.build-manylinux != false
    timeout-minutes: 90
    runs-on: tt-ubuntu-2204-large-stable
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup tool build args
        id: tools
        uses: ./.github/actions/setup-tool-buildargs
        with:
          tool-tags: ${{ needs.resolve-tools.outputs.tool-tags }}
          include: ccache,mold,sfpi,openmpi
      - name: Setup build args
        id: buildargs
        run: |
          {
            echo "manylinux<<EOF"
            echo "${{ steps.tools.outputs.build-args }}"
            echo "EOF"
          } >> $GITHUB_OUTPUT
      - name: Build and push ManyLinux image
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.manylinux
          tags: ${{ needs.check-docker-images.outputs.manylinux-tag }}
          build-args: ${{ steps.buildargs.outputs.manylinux }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

  # tag-latest runs after check-docker-images only (not after build jobs) because adding
  # needs.build-ubuntu-images would cause this job to be skipped when builds are skipped
  # (images already exist). The trade-off: on a push to main where images were just built
  # on a branch, tag-latest may run before the build jobs complete, so "latest" could lag
  # one run. This self-corrects on the next merge. For direct workflow_dispatch of
  # build-docker-artifact, images are typically pre-built.
  tag-latest:
    name: "üîÑ Update latest tag"
    needs: check-docker-images
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: .github/actions/push-latest-image-to-ghcr
          sparse-checkout-cone-mode: false

      - name: "Push latest CI Build tag"
        if: needs.check-docker-images.outputs.ci-build-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.ci-build-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest CI Test tag"
        if: needs.check-docker-images.outputs.ci-test-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.ci-test-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Dev tag"
        if: needs.check-docker-images.outputs.dev-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.dev-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Basic Dev tag"
        if: needs.check-docker-images.outputs.basic-dev-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.basic-dev-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Basic TTNN Runtime tag"
        if: needs.check-docker-images.outputs.basic-ttnn-runtime-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.basic-ttnn-runtime-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Manylinux tag"
        if: needs.check-docker-images.outputs.manylinux-exists == 'true' && inputs.build-manylinux != false
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.manylinux-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

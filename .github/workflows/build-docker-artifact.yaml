name: "Build tt-metal docker artifact"

# =============================================================================
# NAMING CONVENTION: Docker Image Tags
# =============================================================================
# This workflow outputs use the "-tag" suffix (e.g., ci-build-tag, dev-tag)
# to indicate these are Docker image tags that were built/verified.
#
# Consuming workflows (like build-artifact.yaml) accept these values via
# inputs with the "-docker-image" suffix (e.g., ci-build-docker-image) to
# indicate these are pre-built Docker images to use.
#
# Example usage:
#   build-docker-images:
#     uses: ./.github/workflows/build-docker-artifact.yaml
#   build:
#     uses: ./.github/workflows/build-artifact.yaml
#     with:
#       ci-build-docker-image: ${{ needs.build-docker-images.outputs.ci-build-tag }}
#
# TOOL IMAGES:
# Third-party tools (ccache, mold, doxygen, etc.) are built once and pushed to
# GHCR to avoid repeatedly hitting upstream endpoints. These tool images are
# versioned by tool version + install script hash, and are pulled by the main
# Dockerfile during builds.
# =============================================================================

# Required to push images to GHCR (organization or user). Without this you may see:
# "denied: installation not allowed to Create organization package"
permissions:
  packages: write

on:
  workflow_call:
    inputs:
      platform:
        required: false
        type: string
        default: "Ubuntu 22.04"
        description: "Platform to build Docker images for"
      architecture:
        required: false
        type: string
        default: "amd64"
      build-manylinux:
        required: false
        type: boolean
        default: true
        description: "When false, skip building the manylinux image. Set to false for one platform when build-all-docker-images calls this workflow twice so manylinux is built only once."
    outputs:
      ci-build-tag:
        description: "Docker tag for the CI Build Docker image for building TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.ci-build-tag }}
      ci-test-tag:
        description: "Docker tag for the CI Test Docker image for testing TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.ci-test-tag }}
      dev-tag:
        description: "Docker tag for the dev Docker image for developing TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.dev-tag }}
      basic-dev-tag:
        description: "Docker tag for the basic dev Docker image for basic development"
        value: ${{ jobs.check-docker-images.outputs.basic-dev-tag }}
      basic-ttnn-runtime-tag:
        description: "Docker tag for the basic TTNN runtime Docker image for running TTNN"
        value: ${{ jobs.check-docker-images.outputs.basic-ttnn-runtime-tag }}
      manylinux-tag:
        description: "Docker tag for the manylinux Docker image for building TT-Metalium et al"
        value: ${{ jobs.check-docker-images.outputs.manylinux-tag }}
      # Tool image tags (for consumers that need them)
      tool-ccache-tag:
        description: "Docker tag for the ccache tool image"
        value: ${{ jobs.check-tool-images.outputs.ccache-tag }}
      tool-mold-tag:
        description: "Docker tag for the mold tool image"
        value: ${{ jobs.check-tool-images.outputs.mold-tag }}
      tool-doxygen-tag:
        description: "Docker tag for the doxygen tool image"
        value: ${{ jobs.check-tool-images.outputs.doxygen-tag }}
      tool-cba-tag:
        description: "Docker tag for the ClangBuildAnalyzer tool image"
        value: ${{ jobs.check-tool-images.outputs.cba-tag }}
      tool-gdb-tag:
        description: "Docker tag for the GDB tool image"
        value: ${{ jobs.check-tool-images.outputs.gdb-tag }}
      tool-cmake-tag:
        description: "Docker tag for the cmake tool image"
        value: ${{ jobs.check-tool-images.outputs.cmake-tag }}
      tool-yq-tag:
        description: "Docker tag for the yq tool image"
        value: ${{ jobs.check-tool-images.outputs.yq-tag }}
      tool-sfpi-tag:
        description: "Docker tag for the SFPI tool image"
        value: ${{ jobs.check-tool-images.outputs.sfpi-tag }}
      tool-openmpi-tag:
        description: "Docker tag for the OpenMPI (ULFM) tool image"
        value: ${{ jobs.check-tool-images.outputs.openmpi-tag }}
      # Python venv image tags
      python-ci-build-venv-tag:
        description: "Docker tag for the Python CI Build venv image"
        value: ${{ jobs.check-python-venv-images.outputs.ci-build-venv-tag }}
      python-ci-test-venv-tag:
        description: "Docker tag for the Python CI Test venv image"
        value: ${{ jobs.check-python-venv-images.outputs.ci-test-venv-tag }}
  workflow_dispatch:
    inputs:
      platform:
        required: false
        type: choice
        default: "Ubuntu 22.04"
        options:
            - "Ubuntu 22.04"
            - "Ubuntu 24.04"
        description: "Platform to build Docker images for"
      architecture:
        required: false
        type: choice
        default: "amd64"
        options:
            - "amd64"
      build-manylinux:
        required: false
        type: boolean
        default: true
        description: "Build the manylinux image (set false only when another run is building it)"

jobs:
  # =============================================================================
  # TOOL IMAGES: Check and build third-party tool images
  # =============================================================================
  # These images contain pre-built binaries for tools like ccache, mold, etc.
  # They are built once and pushed to GHCR, then pulled by the main Dockerfile.
  # This eliminates repeated downloads from upstream sources.
  # =============================================================================

  check-tool-images:
    runs-on: ubuntu-latest
    outputs:
      ccache-tag: ${{ steps.tags.outputs.ccache-tag }}
      ccache-exists: ${{ steps.check.outputs.ccache-exists }}
      mold-tag: ${{ steps.tags.outputs.mold-tag }}
      mold-exists: ${{ steps.check.outputs.mold-exists }}
      doxygen-tag: ${{ steps.tags.outputs.doxygen-tag }}
      doxygen-exists: ${{ steps.check.outputs.doxygen-exists }}
      cba-tag: ${{ steps.tags.outputs.cba-tag }}
      cba-exists: ${{ steps.check.outputs.cba-exists }}
      gdb-tag: ${{ steps.tags.outputs.gdb-tag }}
      gdb-exists: ${{ steps.check.outputs.gdb-exists }}
      cmake-tag: ${{ steps.tags.outputs.cmake-tag }}
      cmake-exists: ${{ steps.check.outputs.cmake-exists }}
      yq-tag: ${{ steps.tags.outputs.yq-tag }}
      yq-exists: ${{ steps.check.outputs.yq-exists }}
      sfpi-tag: ${{ steps.tags.outputs.sfpi-tag }}
      sfpi-exists: ${{ steps.check.outputs.sfpi-exists }}
      openmpi-tag: ${{ steps.tags.outputs.openmpi-tag }}
      openmpi-exists: ${{ steps.check.outputs.openmpi-exists }}
      any-missing: ${{ steps.check.outputs.any-missing }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Compute tool image tags
        id: tags
        run: |
          # Extract versions from Dockerfile.tools (head -1 so multiple ARG lines don't produce multiline output)
          CCACHE_VERSION=$(grep -E "^ARG CCACHE_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          MOLD_VERSION=$(grep -E "^ARG MOLD_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          DOXYGEN_VERSION=$(grep -E "^ARG DOXYGEN_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          CBA_VERSION=$(grep -E "^ARG CBA_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          GDB_VERSION=$(grep -E "^ARG GDB_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          CMAKE_VERSION=$(grep -E "^ARG CMAKE_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          YQ_VERSION=$(grep -E "^ARG YQ_VERSION=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          OMPI_TAG=$(grep -E "^ARG OMPI_TAG=" dockerfile/Dockerfile.tools | head -1 | cut -d= -f2)
          # SFPI version comes from tt_metal/sfpi-version (single source of truth)
          SFPI_VERSION=$(grep -E "^sfpi_version=" tt_metal/sfpi-version | cut -d"'" -f2)

          # Compute hashes for each tool (version + install script)
          CCACHE_HASH=$(cat dockerfile/scripts/install-ccache.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          MOLD_HASH=$(cat dockerfile/scripts/install-mold.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          DOXYGEN_HASH=$(cat dockerfile/scripts/install-doxygen.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          CBA_HASH=$(cat dockerfile/scripts/install-clangbuildanalyzer.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          GDB_HASH=$(cat dockerfile/scripts/install-gdb.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          CMAKE_HASH=$(cat dockerfile/scripts/install-cmake.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          YQ_HASH=$(cat dockerfile/scripts/install-yq.sh | sha1sum | cut -d' ' -f1 | head -c 8)
          SFPI_HASH=$(cat dockerfile/scripts/install-sfpi.sh tt_metal/sfpi-version | sha1sum | cut -d' ' -f1 | head -c 8)
          OPENMPI_HASH=$(cat dockerfile/scripts/install-openmpi.sh | sha1sum | cut -d' ' -f1 | head -c 8)

          # Generate tags: ghcr.io/<repo>/tt-metalium/tools/<tool>:<version>-<hash>
          BASE="ghcr.io/${{ github.repository }}/tt-metalium/tools"
          echo "ccache-tag=${BASE}/ccache:${CCACHE_VERSION}-${CCACHE_HASH}" >> $GITHUB_OUTPUT
          echo "mold-tag=${BASE}/mold:${MOLD_VERSION}-${MOLD_HASH}" >> $GITHUB_OUTPUT
          echo "doxygen-tag=${BASE}/doxygen:${DOXYGEN_VERSION}-${DOXYGEN_HASH}" >> $GITHUB_OUTPUT
          echo "cba-tag=${BASE}/cba:${CBA_VERSION}-${CBA_HASH}" >> $GITHUB_OUTPUT
          echo "gdb-tag=${BASE}/gdb:${GDB_VERSION}-${GDB_HASH}" >> $GITHUB_OUTPUT
          echo "cmake-tag=${BASE}/cmake:${CMAKE_VERSION}-${CMAKE_HASH}" >> $GITHUB_OUTPUT
          echo "yq-tag=${BASE}/yq:${YQ_VERSION}-${YQ_HASH}" >> $GITHUB_OUTPUT
          echo "sfpi-tag=${BASE}/sfpi:${SFPI_VERSION}-${SFPI_HASH}" >> $GITHUB_OUTPUT
          echo "openmpi-tag=${BASE}/openmpi:${OMPI_TAG}-${OPENMPI_HASH}" >> $GITHUB_OUTPUT

          # Also output versions for build args
          echo "ccache-version=${CCACHE_VERSION}" >> $GITHUB_OUTPUT
          echo "mold-version=${MOLD_VERSION}" >> $GITHUB_OUTPUT
          echo "doxygen-version=${DOXYGEN_VERSION}" >> $GITHUB_OUTPUT
          echo "cba-version=${CBA_VERSION}" >> $GITHUB_OUTPUT
          echo "gdb-version=${GDB_VERSION}" >> $GITHUB_OUTPUT
          echo "cmake-version=${CMAKE_VERSION}" >> $GITHUB_OUTPUT
          echo "yq-version=${YQ_VERSION}" >> $GITHUB_OUTPUT
          echo "sfpi-version=${SFPI_VERSION}" >> $GITHUB_OUTPUT
          echo "openmpi-version=${OMPI_TAG}" >> $GITHUB_OUTPUT

      - name: Check if tool images exist
        id: check
        run: |
          check_image() {
            local tag="$1"
            local name="$2"
            if docker manifest inspect "$tag" > /dev/null 2>&1; then
              echo "$tag exists"
              echo "${name}-exists=true" >> $GITHUB_OUTPUT
            else
              echo "$tag does not exist"
              echo "${name}-exists=false" >> $GITHUB_OUTPUT
            fi
          }

          check_image "${{ steps.tags.outputs.ccache-tag }}" "ccache"
          check_image "${{ steps.tags.outputs.mold-tag }}" "mold"
          check_image "${{ steps.tags.outputs.doxygen-tag }}" "doxygen"
          check_image "${{ steps.tags.outputs.cba-tag }}" "cba"
          check_image "${{ steps.tags.outputs.gdb-tag }}" "gdb"
          check_image "${{ steps.tags.outputs.cmake-tag }}" "cmake"
          check_image "${{ steps.tags.outputs.yq-tag }}" "yq"
          check_image "${{ steps.tags.outputs.sfpi-tag }}" "sfpi"
          check_image "${{ steps.tags.outputs.openmpi-tag }}" "openmpi"

          # Check if any are missing
          if [[ "${{ steps.tags.outputs.ccache-tag }}" == "" ]] || \
             ! docker manifest inspect "${{ steps.tags.outputs.ccache-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.mold-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.doxygen-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.cba-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.gdb-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.cmake-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.yq-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.sfpi-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.openmpi-tag }}" > /dev/null 2>&1; then
            echo "any-missing=true" >> $GITHUB_OUTPUT
          else
            echo "any-missing=false" >> $GITHUB_OUTPUT
          fi

  build-tool-images:
    name: "üîß Build tool images"
    needs: check-tool-images
    if: needs.check-tool-images.outputs.any-missing == 'true'
    timeout-minutes: 60
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ccache image
        if: needs.check-tool-images.outputs.ccache-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: ccache
          push: true
          tags: ${{ needs.check-tool-images.outputs.ccache-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push mold image
        if: needs.check-tool-images.outputs.mold-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: mold
          push: true
          tags: ${{ needs.check-tool-images.outputs.mold-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push doxygen image
        if: needs.check-tool-images.outputs.doxygen-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: doxygen
          push: true
          tags: ${{ needs.check-tool-images.outputs.doxygen-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push ClangBuildAnalyzer image
        if: needs.check-tool-images.outputs.cba-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: cba
          push: true
          tags: ${{ needs.check-tool-images.outputs.cba-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push GDB image
        if: needs.check-tool-images.outputs.gdb-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: gdb
          push: true
          tags: ${{ needs.check-tool-images.outputs.gdb-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push cmake image
        if: needs.check-tool-images.outputs.cmake-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: cmake
          push: true
          tags: ${{ needs.check-tool-images.outputs.cmake-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push yq image
        if: needs.check-tool-images.outputs.yq-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: yq
          push: true
          tags: ${{ needs.check-tool-images.outputs.yq-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push sfpi image
        if: needs.check-tool-images.outputs.sfpi-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: sfpi
          push: true
          tags: ${{ needs.check-tool-images.outputs.sfpi-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push openmpi image
        if: needs.check-tool-images.outputs.openmpi-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.tools
          target: openmpi
          push: true
          tags: ${{ needs.check-tool-images.outputs.openmpi-tag }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

  # =============================================================================
  # PYTHON VENV IMAGES: Check and build pre-built Python virtual environments
  # =============================================================================
  # These images contain pre-built Python virtual environments with all dependencies
  # installed. They are built once per requirements change and pushed to GHCR.
  # Using pre-built venvs saves 5-10 minutes per build.
  # =============================================================================

  check-python-venv-images:
    runs-on: ubuntu-latest
    outputs:
      ci-build-venv-tag: ${{ steps.tags.outputs.ci-build-venv-tag }}
      ci-build-venv-exists: ${{ steps.check.outputs.ci-build-venv-exists }}
      ci-test-venv-tag: ${{ steps.tags.outputs.ci-test-venv-tag }}
      ci-test-venv-exists: ${{ steps.check.outputs.ci-test-venv-exists }}
      any-missing: ${{ steps.check.outputs.any-missing }}
      ubuntu-version: ${{ steps.platform.outputs.version }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Parse platform
        id: platform
        uses: ./.github/actions/parse-platform
        with:
          platform: ${{ inputs.platform }}

      - name: Compute Python venv image tags
        id: tags
        run: |
          VERSION="${{ steps.platform.outputs.version }}"
          # Remove dots from version for image tag (22.04 -> 2204)
          VERSION_NODOT="${VERSION//.}"

          # Hash Dockerfile.python + its COPY source files (requirements files)
          # dockerfile-hash.sh automatically discovers COPY sources from the Dockerfile
          VENV_HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile.python)

          # Generate tags: ghcr.io/<repo>/tt-metalium/python-venv/<type>:<ubuntu-version>-<hash>
          BASE="ghcr.io/${{ github.repository }}/tt-metalium/python-venv"
          echo "ci-build-venv-tag=${BASE}/ci-build:${VERSION_NODOT}-${VENV_HASH}" >> $GITHUB_OUTPUT
          echo "ci-test-venv-tag=${BASE}/ci-test:${VERSION_NODOT}-${VENV_HASH}" >> $GITHUB_OUTPUT

          # Store version and target suffix for build step
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version-nodot=${VERSION_NODOT}" >> $GITHUB_OUTPUT

      - name: Check if Python venv images exist
        id: check
        run: |
          check_image() {
            local tag="$1"
            local name="$2"
            if docker manifest inspect "$tag" > /dev/null 2>&1; then
              echo "$tag exists"
              echo "${name}-exists=true" >> $GITHUB_OUTPUT
            else
              echo "$tag does not exist"
              echo "${name}-exists=false" >> $GITHUB_OUTPUT
            fi
          }

          check_image "${{ steps.tags.outputs.ci-build-venv-tag }}" "ci-build-venv"
          check_image "${{ steps.tags.outputs.ci-test-venv-tag }}" "ci-test-venv"

          # Check if any are missing
          if ! docker manifest inspect "${{ steps.tags.outputs.ci-build-venv-tag }}" > /dev/null 2>&1 || \
             ! docker manifest inspect "${{ steps.tags.outputs.ci-test-venv-tag }}" > /dev/null 2>&1; then
            echo "any-missing=true" >> $GITHUB_OUTPUT
          else
            echo "any-missing=false" >> $GITHUB_OUTPUT
          fi

  build-python-venv-images:
    name: "üêç Build Python venv images"
    needs: check-python-venv-images
    if: needs.check-python-venv-images.outputs.any-missing == 'true'
    timeout-minutes: 45
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ci-build-venv image
        if: needs.check-python-venv-images.outputs.ci-build-venv-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.python
          target: ci-build-venv
          push: true
          tags: ${{ needs.check-python-venv-images.outputs.ci-build-venv-tag }}
          build-args: |
            UBUNTU_VERSION=${{ needs.check-python-venv-images.outputs.ubuntu-version }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

      - name: Build and push ci-test-venv image
        if: needs.check-python-venv-images.outputs.ci-test-venv-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.python
          target: ci-test-venv
          push: true
          tags: ${{ needs.check-python-venv-images.outputs.ci-test-venv-tag }}
          build-args: |
            UBUNTU_VERSION=${{ needs.check-python-venv-images.outputs.ubuntu-version }}
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

  # =============================================================================
  # MAIN DOCKER IMAGES: Check and build CI/Dev/Test images
  # =============================================================================

  check-docker-images:
    runs-on: ubuntu-latest
    outputs:
      ci-build-exists: ${{ steps.images.outputs.ci-build-exists }}
      ci-build-tag: ${{ steps.tags.outputs.ci-build-tag }}
      ci-test-exists: ${{ steps.images.outputs.ci-test-exists }}
      ci-test-tag: ${{ steps.tags.outputs.ci-test-tag }}
      dev-exists: ${{ steps.images.outputs.dev-exists }}
      dev-tag: ${{ steps.tags.outputs.dev-tag }}
      basic-dev-exists: ${{ steps.images.outputs.basic-dev-exists }}
      basic-dev-tag: ${{ steps.tags.outputs.basic-dev-tag }}
      basic-ttnn-runtime-exists: ${{ steps.images.outputs.basic-ttnn-runtime-exists }}
      basic-ttnn-runtime-tag: ${{ steps.tags.outputs.basic-ttnn-runtime-tag }}
      manylinux-exists: ${{ steps.images.outputs.manylinux-exists }}
      manylinux-tag: ${{ steps.tags.outputs.manylinux-tag }}
      distro: ${{ steps.platform.outputs.distro }}
      version: ${{ steps.platform.outputs.version }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Parse platform
        id: platform
        uses: ./.github/actions/parse-platform
        with:
          platform: ${{ inputs.platform }}

      - name: Set environment variables
        run: |
          DISTRO="${{ steps.platform.outputs.distro }}"
          VERSION="${{ steps.platform.outputs.version }}"
          ARCH="${{ inputs.architecture || 'amd64' }}"

          echo "CI_BUILD_IMAGE_NAME=${DISTRO}-${VERSION}-ci-build-${ARCH}" >> $GITHUB_ENV
          echo "CI_TEST_IMAGE_NAME=${DISTRO}-${VERSION}-ci-test-${ARCH}" >> $GITHUB_ENV
          echo "DEV_IMAGE_NAME=${DISTRO}-${VERSION}-dev-${ARCH}" >> $GITHUB_ENV
          echo "BASIC_DEV_IMAGE_NAME=${DISTRO}-${VERSION}-basic-dev-${ARCH}" >> $GITHUB_ENV
          echo "BASIC_TTNN_RUNTIME_IMAGE_NAME=${DISTRO}-${VERSION}-basic-ttnn-runtime-${ARCH}" >> $GITHUB_ENV
          echo "MANYLINUX_IMAGE_NAME=manylinux-${ARCH}" >> $GITHUB_ENV

      - name: Compute tags
        id: tags
        run: |
          # Include workflow file and tool images Dockerfile in hash
          # Tool images are versioned separately, but changes to Dockerfile.tools
          # that affect the main build should trigger a rebuild
          EXTRA_FILES=".github/workflows/build-docker-artifact.yaml dockerfile/Dockerfile.tools"

          HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile $EXTRA_FILES)
          echo "ci-build-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.CI_BUILD_IMAGE_NAME }}:${HASH}" >> $GITHUB_OUTPUT
          echo "ci-test-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.CI_TEST_IMAGE_NAME }}:${HASH}" >> $GITHUB_OUTPUT
          echo "dev-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.DEV_IMAGE_NAME }}:${HASH}" >> $GITHUB_OUTPUT

          # basic-dev uses tool images (cmake, sfpi, openmpi, ccache), so include tool-related files in hash
          BASIC_DEV_EXTRA_FILES="$EXTRA_FILES"
          BASIC_DEV_HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile.basic-dev $BASIC_DEV_EXTRA_FILES)
          echo "basic-dev-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.BASIC_DEV_IMAGE_NAME }}:${BASIC_DEV_HASH}" >> $GITHUB_OUTPUT

          BASIC_TTNN_RUNTIME_HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile.basic-dev $BASIC_DEV_EXTRA_FILES)
          echo "basic-ttnn-runtime-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.BASIC_TTNN_RUNTIME_IMAGE_NAME }}:${BASIC_TTNN_RUNTIME_HASH}" >> $GITHUB_OUTPUT

          # Manylinux image copies OpenMPI from the tool image; include install-openmpi.sh
          # in its tag so that when the OpenMPI build method changes (e.g. git vs tarball,
          # which changes library SONAMEs), manylinux is rebuilt and the wheel sees the
          # correct library names.
          MANYLINUX_EXTRA_FILES="$EXTRA_FILES dockerfile/scripts/install-openmpi.sh"
          MANYLINUX_HASH=$(.github/scripts/dockerfile-hash.sh dockerfile/Dockerfile.manylinux $MANYLINUX_EXTRA_FILES)
          echo "manylinux-tag=ghcr.io/${{ github.repository }}/tt-metalium/${{ env.MANYLINUX_IMAGE_NAME }}:${MANYLINUX_HASH}" >> $GITHUB_OUTPUT

      # Assume if dev-tag exists, the others will exist too
      - name: Query images exist
        id: images
        run: |
          if docker manifest inspect ${{ steps.tags.outputs.dev-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.dev-tag }} exists"
            echo "ci-build-exists=true" >> $GITHUB_OUTPUT
            echo "ci-test-exists=true" >> $GITHUB_OUTPUT
            echo "dev-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.dev-tag }} does not exist"
            echo "ci-build-exists=false" >> $GITHUB_OUTPUT
            echo "ci-test-exists=false" >> $GITHUB_OUTPUT
            echo "dev-exists=false" >> $GITHUB_OUTPUT
          fi

          if docker manifest inspect ${{ steps.tags.outputs.basic-dev-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.basic-dev-tag }} exists"
            echo "basic-dev-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.basic-dev-tag }} does not exist"
            echo "basic-dev-exists=false" >> $GITHUB_OUTPUT
          fi
          if docker manifest inspect ${{ steps.tags.outputs.basic-ttnn-runtime-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.basic-ttnn-runtime-tag }} exists"
            echo "basic-ttnn-runtime-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.basic-ttnn-runtime-tag }} does not exist"
            echo "basic-ttnn-runtime-exists=false" >> $GITHUB_OUTPUT
          fi

          if docker manifest inspect ${{ steps.tags.outputs.manylinux-tag }} > /dev/null 2>&1; then
            echo "${{ steps.tags.outputs.manylinux-tag }} exists"
            echo "manylinux-exists=true" >> $GITHUB_OUTPUT
          else
            echo "${{ steps.tags.outputs.manylinux-tag }} does not exist"
            echo "manylinux-exists=false" >> $GITHUB_OUTPUT
          fi

  # Build Ubuntu images
  build-ubuntu-images:
    name: "üê≥Ô∏è Build Ubuntu images"
    needs: [check-docker-images, check-tool-images, build-tool-images, check-python-venv-images, build-python-venv-images]
    # Run if distro is ubuntu AND (main images missing OR basic images missing)
    # Use always() to run even when build-tool-images or build-python-venv-images is skipped (all exist)
    if: |
      always() && !failure() && !cancelled() &&
      needs.check-docker-images.outputs.distro == 'ubuntu' &&
      (needs.check-docker-images.outputs.dev-exists != 'true' ||
       needs.check-docker-images.outputs.basic-dev-exists != 'true' ||
       needs.check-docker-images.outputs.basic-ttnn-runtime-exists != 'true')
    timeout-minutes: 90
    runs-on: tt-ubuntu-2204-large-stable
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push CI Build image
        if: needs.check-docker-images.outputs.dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile
          target: ci-build
          tags: ${{ needs.check-docker-images.outputs.ci-build-tag }}
          build-args: |
            UBUNTU_VERSION=${{ needs.check-docker-images.outputs.version }}
            TOOL_CCACHE_IMAGE=${{ needs.check-tool-images.outputs.ccache-tag }}
            TOOL_MOLD_IMAGE=${{ needs.check-tool-images.outputs.mold-tag }}
            TOOL_DOXYGEN_IMAGE=${{ needs.check-tool-images.outputs.doxygen-tag }}
            TOOL_CBA_IMAGE=${{ needs.check-tool-images.outputs.cba-tag }}
            TOOL_GDB_IMAGE=${{ needs.check-tool-images.outputs.gdb-tag }}
            TOOL_CMAKE_IMAGE=${{ needs.check-tool-images.outputs.cmake-tag }}
            TOOL_YQ_IMAGE=${{ needs.check-tool-images.outputs.yq-tag }}
            TOOL_SFPI_IMAGE=${{ needs.check-tool-images.outputs.sfpi-tag }}
            TOOL_OPENMPI_IMAGE=${{ needs.check-tool-images.outputs.openmpi-tag }}
            PYTHON_CI_BUILD_VENV_IMAGE=${{ needs.check-python-venv-images.outputs.ci-build-venv-tag }}
            PYTHON_CI_TEST_VENV_IMAGE=${{ needs.check-python-venv-images.outputs.ci-test-venv-tag }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push CI Test image
        if: needs.check-docker-images.outputs.dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile
          target: ci-test
          tags: ${{ needs.check-docker-images.outputs.ci-test-tag }}
          build-args: |
            UBUNTU_VERSION=${{ needs.check-docker-images.outputs.version }}
            TOOL_CCACHE_IMAGE=${{ needs.check-tool-images.outputs.ccache-tag }}
            TOOL_MOLD_IMAGE=${{ needs.check-tool-images.outputs.mold-tag }}
            TOOL_DOXYGEN_IMAGE=${{ needs.check-tool-images.outputs.doxygen-tag }}
            TOOL_CBA_IMAGE=${{ needs.check-tool-images.outputs.cba-tag }}
            TOOL_GDB_IMAGE=${{ needs.check-tool-images.outputs.gdb-tag }}
            TOOL_CMAKE_IMAGE=${{ needs.check-tool-images.outputs.cmake-tag }}
            TOOL_YQ_IMAGE=${{ needs.check-tool-images.outputs.yq-tag }}
            TOOL_SFPI_IMAGE=${{ needs.check-tool-images.outputs.sfpi-tag }}
            TOOL_OPENMPI_IMAGE=${{ needs.check-tool-images.outputs.openmpi-tag }}
            PYTHON_CI_BUILD_VENV_IMAGE=${{ needs.check-python-venv-images.outputs.ci-build-venv-tag }}
            PYTHON_CI_TEST_VENV_IMAGE=${{ needs.check-python-venv-images.outputs.ci-test-venv-tag }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push Dev image
        if: needs.check-docker-images.outputs.dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile
          target: dev
          tags: ${{ needs.check-docker-images.outputs.dev-tag }}
          build-args: |
            UBUNTU_VERSION=${{ needs.check-docker-images.outputs.version }}
            TOOL_CCACHE_IMAGE=${{ needs.check-tool-images.outputs.ccache-tag }}
            TOOL_MOLD_IMAGE=${{ needs.check-tool-images.outputs.mold-tag }}
            TOOL_DOXYGEN_IMAGE=${{ needs.check-tool-images.outputs.doxygen-tag }}
            TOOL_CBA_IMAGE=${{ needs.check-tool-images.outputs.cba-tag }}
            TOOL_GDB_IMAGE=${{ needs.check-tool-images.outputs.gdb-tag }}
            TOOL_CMAKE_IMAGE=${{ needs.check-tool-images.outputs.cmake-tag }}
            TOOL_YQ_IMAGE=${{ needs.check-tool-images.outputs.yq-tag }}
            TOOL_SFPI_IMAGE=${{ needs.check-tool-images.outputs.sfpi-tag }}
            TOOL_OPENMPI_IMAGE=${{ needs.check-tool-images.outputs.openmpi-tag }}
            PYTHON_CI_BUILD_VENV_IMAGE=${{ needs.check-python-venv-images.outputs.ci-build-venv-tag }}
            PYTHON_CI_TEST_VENV_IMAGE=${{ needs.check-python-venv-images.outputs.ci-test-venv-tag }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push Basic Dev image
        if: needs.check-docker-images.outputs.basic-dev-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.basic-dev
          target: base
          tags: ${{ needs.check-docker-images.outputs.basic-dev-tag }}
          build-args: |
            UBUNTU_VERSION=${{ needs.check-docker-images.outputs.version }}
            TOOL_CMAKE_IMAGE=${{ needs.check-tool-images.outputs.cmake-tag }}
            TOOL_SFPI_IMAGE=${{ needs.check-tool-images.outputs.sfpi-tag }}
            TOOL_OPENMPI_IMAGE=${{ needs.check-tool-images.outputs.openmpi-tag }}
            TOOL_CCACHE_IMAGE=${{ needs.check-tool-images.outputs.ccache-tag }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true
      - name: Build and push Basic TTNN runtime image
        if: needs.check-docker-images.outputs.basic-ttnn-runtime-exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.basic-dev
          target: basic-ttnn-runtime
          tags: ${{ needs.check-docker-images.outputs.basic-ttnn-runtime-tag }}
          build-args: |
            UBUNTU_VERSION=${{ needs.check-docker-images.outputs.version }}
            TOOL_CMAKE_IMAGE=${{ needs.check-tool-images.outputs.cmake-tag }}
            TOOL_SFPI_IMAGE=${{ needs.check-tool-images.outputs.sfpi-tag }}
            TOOL_OPENMPI_IMAGE=${{ needs.check-tool-images.outputs.openmpi-tag }}
            TOOL_CCACHE_IMAGE=${{ needs.check-tool-images.outputs.ccache-tag }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

  # Build ManyLinux image (runs in parallel with Ubuntu)
  build-manylinux-image:
    name: "üê≥Ô∏è Build ManyLinux image"
    needs: [check-docker-images, check-tool-images, build-tool-images]
    # Run if manylinux needs build AND tool images are ready AND this run is responsible for manylinux
    # Use always() to run even when build-tool-images is skipped (all exist)
    # When build-manylinux input is false (e.g. second platform in build-all-docker-images), skip so manylinux is built only once
    if: |
      always() && !failure() && !cancelled() &&
      needs.check-docker-images.outputs.manylinux-exists != 'true' &&
      inputs.build-manylinux != false
    timeout-minutes: 90
    runs-on: tt-ubuntu-2204-large-stable
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push ManyLinux image
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: dockerfile/Dockerfile.manylinux
          tags: ${{ needs.check-docker-images.outputs.manylinux-tag }}
          build-args: |
            TOOL_CCACHE_IMAGE=${{ needs.check-tool-images.outputs.ccache-tag }}
            TOOL_MOLD_IMAGE=${{ needs.check-tool-images.outputs.mold-tag }}
            TOOL_SFPI_IMAGE=${{ needs.check-tool-images.outputs.sfpi-tag }}
            TOOL_OPENMPI_IMAGE=${{ needs.check-tool-images.outputs.openmpi-tag }}
          cache-to: type=inline
          pull: true
          outputs: |
            type=registry,push=true,compression=zstd,compression-level=3,force-compression=true,oci-mediatypes=true

  # Cannot use needs.build-*-images to ensure this job runs sequentially after the build jobs because it would break when the build jobs are skipped
  # Instead, this setup causes the tag-latest job to lag one run behind the actual build.
  # However, this isn't a huge issue because the image should already have been built on a branch before merging, and if it wasn't (like in a push scenario),
  # the problem would self-correct on the next merge to main, which happens frequently.
  tag-latest:
    name: "üîÑ Update latest tag"
    needs: check-docker-images
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: .github/actions/push-latest-image-to-ghcr
          sparse-checkout-cone-mode: false

      - name: "Push latest CI Build tag"
        if: needs.check-docker-images.outputs.ci-build-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.ci-build-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest CI Test tag"
        if: needs.check-docker-images.outputs.ci-test-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.ci-test-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Dev tag"
        if: needs.check-docker-images.outputs.dev-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.dev-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Basic Dev tag"
        if: needs.check-docker-images.outputs.basic-dev-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.basic-dev-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Basic TTNN Runtime tag"
        if: needs.check-docker-images.outputs.basic-ttnn-runtime-exists == 'true'
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.basic-ttnn-runtime-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Push latest Manylinux tag"
        if: needs.check-docker-images.outputs.manylinux-exists == 'true' && inputs.build-manylinux != false
        uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ needs.check-docker-images.outputs.manylinux-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

name: Test LLK to Metal integration

on:
  workflow_dispatch:
    inputs:
      mirrored_branch:
        description: 'Mirrored branch name (e.g., mirror/branch-name)'
        required: true
        type: string
      run_all_post_commit:
        description: 'Run all post-commit tests'
        required: false
        type: boolean
        default: false
      run_blackhole_post_commit:
        description: 'Run Blackhole post-commit tests'
        required: false
        type: boolean
        default: false
      workflow_timeout:
        description: 'Timeout for workflows in minutes'
        required: false
        type: number
        default: 720
  workflow_call:
    inputs:
      mirrored_branch:
        description: 'Mirrored branch name (e.g., mirror/branch-name)'
        required: true
        type: string
      run_all_post_commit:
        description: 'Run all post-commit tests'
        required: false
        type: boolean
        default: false
      run_blackhole_post_commit:
        description: 'Run Blackhole post-commit tests'
        required: false
        type: boolean
        default: false
      workflow_timeout:
        description: 'Timeout for workflows in minutes'
        required: false
        type: number
        default: 720
    outputs:
      all-post-commit-result:
        description: 'Result of All post-commit tests (status:url format)'
        value: ${{ jobs.setup-and-test.outputs.all-post-commit-result }}
      blackhole-result:
        description: 'Result of Blackhole post-commit tests (status:url format)'
        value: ${{ jobs.setup-and-test.outputs.blackhole-result }}
      tt-metal-l2-nightly-result:
        description: 'Result of All post-commit C++ tests (status:url format)'
        value: ${{ jobs.setup-and-test.outputs.tt-metal-l2-nightly-result }}
      perf-device-models-result:
        description: 'Result of Device perf regressions (status:url format)'
        value: ${{ jobs.setup-and-test.outputs.perf-device-models-result }}

concurrency:
  group: llk-integration-${{ inputs.mirrored_branch }}
  cancel-in-progress: true

env:
  PARENT_BRANCH_NAME: test-llk-${{ inputs.mirrored_branch }}-${{ github.run_id }}
  SUBMODULE_PATH: tt_metal/third_party/tt_llk
  WORKFLOW_TIMEOUT: ${{ inputs.workflow_timeout || 720 }}
  METAL_REPO: tenstorrent/tt-metal
  LLK_REPO: tenstorrent/tt-llk
  GH_TOKEN: ${{ secrets.LLK_UPLIFT_PAT }}
  MAX_RETRIES: 3
  POLL_INTERVAL: 120

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write
  checks: read

jobs:
  setup-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 720
    outputs:
      branch-exists: ${{ steps.check-branch.outputs.branch-exists }}
      test-branch-name: ${{ steps.check-branch.outputs.test-branch-name }}
      parent-branch-name: ${{ env.PARENT_BRANCH_NAME }}
      all-post-commit-run-id: ${{ steps.trigger-workflows.outputs.all-post-commit-run-id }}
      blackhole-run-id: ${{ steps.trigger-workflows.outputs.blackhole-run-id }}
      tt-metal-l2-nightly-run-id: ${{ steps.trigger-workflows.outputs.tt-metal-l2-nightly-run-id }}
      perf-device-models-run-id: ${{ steps.trigger-workflows.outputs.perf-device-models-run-id }}
      all-post-commit-result: ${{ steps.monitor-workflows.outputs.all-post-commit-result }}
      blackhole-result: ${{ steps.monitor-workflows.outputs.blackhole-result }}
      tt-metal-l2-nightly-result: ${{ steps.monitor-workflows.outputs.tt-metal-l2-nightly-result }}
      perf-device-models-result: ${{ steps.monitor-workflows.outputs.perf-device-models-result }}
    steps:
      - name: Setup
        uses: actions/checkout@v4
        with:
          repository: tenstorrent/tt-metal
          submodules: recursive
          token: ${{ secrets.LLK_UPLIFT_PAT }}
          fetch-depth: 0
          ref: main
          clean: true
      - name: Configure git
        run: |
          git config --global user.name "LLK Integration Tester [bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
      - name: Setup test branch and parent repository
        id: check-branch
        run: |
          MIRRORED_BRANCH="${{ inputs.mirrored_branch }}"
          TEST_BRANCH_NAME="test-llk-$MIRRORED_BRANCH-$(date +%s)"
          SUBMODULE_PATH="${{ env.SUBMODULE_PATH }}"
          cd "$SUBMODULE_PATH"

          # Ensure correct remote and fetch mirrored branch
          git remote set-url origin https://${{ secrets.LLK_UPLIFT_PAT }}@github.com/tenstorrent/tt-llk.git
          if git fetch origin "$MIRRORED_BRANCH:$MIRRORED_BRANCH" 2>/dev/null; then
            echo "branch-exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Mirrored branch '$MIRRORED_BRANCH' exists in submodule"

            # Get the commit currently pinned in the parent repo
            cd "${{ github.workspace }}"
            PARENT_PINNED_COMMIT=$(git ls-tree main "$SUBMODULE_PATH" | awk '{print $3}')
            cd "$SUBMODULE_PATH"

            # Checkout mirrored branch
            git checkout -b "$TEST_BRANCH_NAME" "$MIRRORED_BRANCH"

            # Ensure branch is up to date with latest submodule's main
            echo "ðŸ” Checking if branch needs updates from latest submodule main..."
            BRANCH_VS_MAIN_COMMITS=$(git rev-list --count HEAD..origin/main)
            if [ "$BRANCH_VS_MAIN_COMMITS" -gt 0 ]; then
              echo "ðŸ”„ Branch is $BRANCH_VS_MAIN_COMMITS commits behind latest main - merging latest changes"
              if ! git merge origin/main --no-edit; then
                echo "âŒ Merge with latest main failed - conflicts need manual resolution"
                echo "ðŸ’¡ This suggests genuine conflicts between your changes and recent main updates"
                echo "ðŸ’¡ Please resolve conflicts locally and push updated branch"
                exit 1
              fi
              echo "âœ… Successfully merged latest submodule main into branch"
            else
              echo "âœ… Branch is up to date with latest submodule main"
            fi

            echo "âœ… Branch updated with latest submodule changes - ready for testing"

            # Push test branch to origin
            if ! git push origin "$TEST_BRANCH_NAME"; then
              echo "âŒ Failed to push test branch to origin"
              exit 1
            fi

            # Update parent repository to reference new submodule commit
            cd "${{ github.workspace }}"
            git checkout -b "${{ env.PARENT_BRANCH_NAME }}"
            git add "$SUBMODULE_PATH"
            git commit -m "test: update LLK submodule to test branch $TEST_BRANCH_NAME from mirrored branch $MIRRORED_BRANCH"
            if ! git push origin "${{ env.PARENT_BRANCH_NAME }}"; then
              echo "âŒ Failed to push parent branch to origin"
              exit 1
            fi

            echo "test-branch-name=$TEST_BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "âœ… Created test branch '$TEST_BRANCH_NAME' and updated parent repository"
          else
            echo "branch-exists=false" >> $GITHUB_OUTPUT
            echo "âŒ Mirrored branch '$MIRRORED_BRANCH' does not exist in submodule"
          fi
      - name: Trigger workflows
        id: trigger-workflows
        if: |
          steps.check-branch.outputs.branch-exists == 'true' &&
          (inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true)
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
          PARENT_BRANCH_NAME: ${{ env.PARENT_BRANCH_NAME }}
        run: |
          # Define workflows to trigger
          declare -A workflows
          workflows["all-post-commit-workflows.yaml"]="${{ inputs.run_all_post_commit }}"
          workflows["blackhole-post-commit.yaml"]="${{ inputs.run_blackhole_post_commit }}"
          workflows["tt-metal-l2-nightly.yaml"]="${{ inputs.run_all_post_commit || inputs.run_blackhole_post_commit }}"
          workflows["perf-device-models.yaml"]="${{ inputs.run_all_post_commit || inputs.run_blackhole_post_commit }}"

          declare -A run_ids

          # Build architecture parameter based on which post-commit tests are enabled
          if [ "${{ inputs.run_all_post_commit }}" = "true" ] && [ "${{ inputs.run_blackhole_post_commit }}" = "true" ]; then
            ARCH_PARAM='["wormhole_b0", "blackhole"]'
          elif [ "${{ inputs.run_all_post_commit }}" = "true" ]; then
            ARCH_PARAM='["wormhole_b0"]'
          else
            ARCH_PARAM='["blackhole"]'
          fi

          # Function to trigger workflow and get run ID and URL
          trigger_and_get_id() {
            local workflow_file="$1"
            local display_name="$2"

            if [ "$workflow_file" = "tt-metal-l2-nightly.yaml" ]; then
              gh workflow run "$workflow_file" --ref "$PARENT_BRANCH_NAME" --repo "${{ env.METAL_REPO }}" \
              -f architecture="$ARCH_PARAM" \
              -f run_cpp_tests=true \
              -f run_metal_iommu_tests=true \
              -f run_sd_unit_tests=true \
              -f run_fd_unit_tests=true \
              -f run_profiler_regression=true \
              -f run_tt_train_cpp_unit_tests=true \
              -f run_models_unit_tests=true \
              -f run_tt_cnn_unit_tests=true
            elif [ "$workflow_file" = "perf-device-models.yaml" ]; then
              gh workflow run "$workflow_file" --ref "$PARENT_BRANCH_NAME" --repo "${{ env.METAL_REPO }}" \
              -f architecture="$ARCH_PARAM"
            else
              gh workflow run "$workflow_file" --ref "$PARENT_BRANCH_NAME" --repo "${{ env.METAL_REPO }}"
            fi

            # Poll for run ID and URL
            local run_data=""
            for i in {1..12}; do
              sleep 5
              run_data=$(gh run list --workflow "$workflow_file" --branch "$PARENT_BRANCH_NAME" --limit 1 --json databaseId,url --jq '.[0] | select(.databaseId != null) | "\(.databaseId)|\(.url)"' --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "")
              if [ -n "$run_data" ] && [ "$run_data" != "null" ]; then
                break
              fi
            done
            echo "$run_data"
          }

          # Trigger enabled workflows
          for workflow in "${!workflows[@]}"; do
            if [ "${workflows[$workflow]}" = "true" ]; then
              echo "ðŸš€ Triggering $workflow..."
              case "$workflow" in
                "all-post-commit-workflows.yaml")
                  run_data=$(trigger_and_get_id "$workflow" "All post-commit")
                  if [ -n "$run_data" ]; then
                    run_ids["all-post-commit"]=$(echo "$run_data" | cut -d'|' -f1)
                    run_url=$(echo "$run_data" | cut -d'|' -f2)
                    echo "âœ… All post-commit run: $run_url"
                  fi
                  ;;
                "blackhole-post-commit.yaml")
                  run_data=$(trigger_and_get_id "$workflow" "Blackhole")
                  if [ -n "$run_data" ]; then
                    run_ids["blackhole"]=$(echo "$run_data" | cut -d'|' -f1)
                    run_url=$(echo "$run_data" | cut -d'|' -f2)
                    echo "âœ… Blackhole post-commit run: $run_url"
                  fi
                  ;;
                "tt-metal-l2-nightly.yaml")
                  run_data=$(trigger_and_get_id "$workflow" "TT-Metal L2 Nightly APC")
                  if [ -n "$run_data" ]; then
                    run_ids["tt-metal-l2-nightly"]=$(echo "$run_data" | cut -d'|' -f1)
                    run_url=$(echo "$run_data" | cut -d'|' -f2)
                    echo "âœ… All post-commit C++ tests run: $run_url"
                  fi
                  ;;
                "perf-device-models.yaml")
                  run_data=$(trigger_and_get_id "$workflow" "Device Perf Regressions")
                  if [ -n "$run_data" ]; then
                    run_ids["perf-device-models"]=$(echo "$run_data" | cut -d'|' -f1)
                    run_url=$(echo "$run_data" | cut -d'|' -f2)
                    echo "âœ… Device perf regressions run: $run_url"
                  fi
                  ;;
              esac
            fi
          done

          # Output run IDs for monitoring steps
          echo "all-post-commit-run-id=${run_ids[all-post-commit]}" >> $GITHUB_OUTPUT
          echo "blackhole-run-id=${run_ids[blackhole]}" >> $GITHUB_OUTPUT
          echo "tt-metal-l2-nightly-run-id=${run_ids[tt-metal-l2-nightly]}" >> $GITHUB_OUTPUT
          echo "perf-device-models-run-id=${run_ids[perf-device-models]}" >> $GITHUB_OUTPUT
      - name: Monitor triggered workflows
        id: monitor-workflows
        if: |
          steps.check-branch.outputs.branch-exists == 'true' &&
          (inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true)
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
          WORKFLOW_TIMEOUT: ${{ env.WORKFLOW_TIMEOUT }}
          MAX_RETRIES: ${{ env.MAX_RETRIES }}
          POLL_INTERVAL: ${{ env.POLL_INTERVAL }}
          ALL_POST_COMMIT_RUN_ID: ${{ steps.trigger-workflows.outputs.all-post-commit-run-id }}
          BLACKHOLE_RUN_ID: ${{ steps.trigger-workflows.outputs.blackhole-run-id }}
          TT_METAL_L2_NIGHTLY_RUN_ID: ${{ steps.trigger-workflows.outputs.tt-metal-l2-nightly-run-id }}
          PERF_DEVICE_MODELS_RUN_ID: ${{ steps.trigger-workflows.outputs.perf-device-models-run-id }}
        run: |
          # Helper function to check if failures exist in main branch
          check_failure_exists_in_main() {
            local run_id=$1
            local workflow=$2

            echo "ðŸ” Checking if failures exist in main branch for workflow: $workflow"

            # Get detailed failure info from branch run: job name + failed step names
            local branch_failure_details=$(gh run view "$run_id" --json jobs --jq '
              [.jobs[] | select(.conclusion == "failure") | {
                job: .name,
                failed_steps: [.steps[] | select(.conclusion == "failure") | .name] | sort
              }] | sort_by(.job)
            ' --repo "${{ env.METAL_REPO }}" 2>/dev/null)

            if [ -z "$branch_failure_details" ] || [ "$branch_failure_details" = "[]" ]; then
              echo "No failed jobs found in current run"
              return 1
            fi

            echo "Branch failure details: $branch_failure_details"

            # Get annotations (test failures) from branch run - extract test identifiers only (path + title), NOT error messages
            # This avoids false negatives from floating-point drift in error outputs
            # Use headSha to query check runs for the commit
            local branch_head_sha=$(gh run view "$run_id" --json headSha --jq '.headSha' --repo "${{ env.METAL_REPO }}" 2>/dev/null)
            local branch_annotations="[]"
            if [ -n "$branch_head_sha" ]; then
              branch_annotations=$(gh api "/repos/${{ env.METAL_REPO }}/commits/$branch_head_sha/check-runs" \
                --jq '[.check_runs[] | select(.conclusion == "failure") | .output.annotations // [] | .[] | select(.annotation_level == "failure") | "\(.path // ""):\(.title // "")"] | sort | unique' 2>/dev/null || echo "[]")
            fi

            echo "Branch failed tests count: $(echo "$branch_annotations" | jq 'length' 2>/dev/null || echo 0)"

            # Find the latest completed run of the same workflow on main
            local main_run_id=$(gh run list \
              --workflow "$workflow" \
              --branch "main" \
              --limit 5 \
              --json databaseId,status,conclusion \
              --jq '[.[] | select(.status == "completed")] | .[0].databaseId // empty' \
              --repo "${{ env.METAL_REPO }}" 2>/dev/null)

            if [ -z "$main_run_id" ]; then
              echo "No completed runs found on main for $workflow"
              return 1
            fi

            echo "Found main run ID: $main_run_id"

            # Get detailed failure info from main run
            local main_failure_details=$(gh run view "$main_run_id" --json jobs --jq '
              [.jobs[] | select(.conclusion == "failure") | {
                job: .name,
                failed_steps: [.steps[] | select(.conclusion == "failure") | .name] | sort
              }] | sort_by(.job)
            ' --repo "${{ env.METAL_REPO }}" 2>/dev/null)

            if [ -z "$main_failure_details" ] || [ "$main_failure_details" = "[]" ]; then
              echo "No failed jobs found in main run - main is passing"
              return 1
            fi

            echo "Main failure details: $main_failure_details"

            # Get annotations from main run - extract test identifiers only (path + title), NOT error messages
            local main_head_sha=$(gh run view "$main_run_id" --json headSha --jq '.headSha' --repo "${{ env.METAL_REPO }}" 2>/dev/null)
            local main_annotations="[]"
            if [ -n "$main_head_sha" ]; then
              main_annotations=$(gh api "/repos/${{ env.METAL_REPO }}/commits/$main_head_sha/check-runs" \
                --jq '[.check_runs[] | select(.conclusion == "failure") | .output.annotations // [] | .[] | select(.annotation_level == "failure") | "\(.path // ""):\(.title // "")"] | sort | unique' 2>/dev/null || echo "[]")
            fi

            echo "Main failed tests count: $(echo "$main_annotations" | jq 'length' 2>/dev/null || echo 0)"

            # Compare job+step failures
            local all_failures_in_main=true

            # Iterate through each branch failure
            local branch_jobs=$(echo "$branch_failure_details" | jq -r '.[].job')

            while IFS= read -r job_name; do
              [ -z "$job_name" ] && continue

              # Get failed steps for this job in branch
              local branch_steps=$(echo "$branch_failure_details" | jq -r --arg job "$job_name" '.[] | select(.job == $job) | .failed_steps | .[]' 2>/dev/null)

              # Check if this job exists in main failures
              local main_job_exists=$(echo "$main_failure_details" | jq -e --arg job "$job_name" '.[] | select(.job == $job)' > /dev/null 2>&1 && echo "true" || echo "false")

              if [ "$main_job_exists" = "false" ]; then
                echo "âœ— Job '$job_name' does NOT fail in main - this is a new failure"
                all_failures_in_main=false
                break
              fi

              # Get failed steps for this job in main
              local main_steps=$(echo "$main_failure_details" | jq -r --arg job "$job_name" '.[] | select(.job == $job) | .failed_steps | .[]' 2>/dev/null)

              # Check if all branch steps exist in main steps
              while IFS= read -r step_name; do
                [ -z "$step_name" ] && continue

                if echo "$main_steps" | grep -qxF "$step_name"; then
                  echo "âœ“ Job '$job_name' / Step '$step_name' also fails in main"
                else
                  echo "âœ— Job '$job_name' / Step '$step_name' does NOT fail in main - this is a new failure"
                  all_failures_in_main=false
                  break 2
                fi
              done <<< "$branch_steps"

            done <<< "$branch_jobs"

            # If job+step comparison passed, also check annotations (test-level failures)
            if [ "$all_failures_in_main" = "true" ]; then
              local branch_anno_count=$(echo "$branch_annotations" | jq 'length' 2>/dev/null || echo "0")
              local main_anno_count=$(echo "$main_annotations" | jq 'length' 2>/dev/null || echo "0")

              # Handle cases where annotations might not exist
              if [ "$branch_anno_count" -eq 0 ] && [ "$main_anno_count" -eq 0 ]; then
                echo "â„¹ï¸ No test annotations found in either run - job+step match is sufficient"
              elif [ "$branch_anno_count" -eq 0 ]; then
                echo "â„¹ï¸ No test annotations in branch run - job+step match is sufficient"
              elif [ "$branch_anno_count" -gt 0 ]; then
                echo "Comparing $branch_anno_count branch annotations against $main_anno_count main annotations..."

                if [ "$main_anno_count" -eq 0 ]; then
                  echo "âš ï¸ Branch has $branch_anno_count test annotations but main has none - cannot compare tests"
                  echo "â„¹ï¸ Falling back to job+step match (sufficient for pre-existing failure detection)"
                else
                  # Check if all branch annotations exist in main
                  local new_annotations=$(echo "$branch_annotations" | jq --argjson main "$main_annotations" '[.[] | select(. as $a | $main | index($a) | not)]')
                  local new_anno_count=$(echo "$new_annotations" | jq 'length')

                  if [ "$new_anno_count" -gt 0 ]; then
                    echo "âœ— Found $new_anno_count new test failures not in main:"
                    echo "$new_annotations" | jq -r '.[:5][]' | while read -r anno; do
                      echo "  - ${anno:0:100}..."
                    done
                    all_failures_in_main=false
                  else
                    echo "âœ“ All test failure annotations also exist in main"
                  fi
                fi
              fi
            fi

            if [ "$all_failures_in_main" = "true" ]; then
              echo "âœ… All failures (jobs, steps, and tests) exist in main branch - treating as pre-existing issues"
              return 0
            else
              echo "âŒ New failures detected that don't exist in main"
              return 1
            fi
          }

          # Helper function for workflow monitoring
          monitor_workflow() {
            local run_id="$1"
            local workflow_name="$2"
            local output_var="$3"

            if [ -z "$run_id" ] || [ "$run_id" = "" ]; then
              echo "âšª Skipping $workflow_name - not triggered"
              return 0
            fi

            local retries=0
            local timeout_seconds=$((WORKFLOW_TIMEOUT * 60))
            local elapsed=0
            local run_url="https://github.com/tenstorrent/tt-metal/actions/runs/$run_id"
            echo "ðŸš€ Monitoring $workflow_name (run ID: $run_id) - $run_url"
            while [ $retries -lt $MAX_RETRIES ]; do
              while [ $elapsed -lt $timeout_seconds ]; do
                status=$(gh run view "$run_id" --json status,conclusion --jq '.status + ":" + (.conclusion // "unknown")' --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "unknown:unknown")
                run_status=$(echo "$status" | cut -d: -f1)
                conclusion=$(echo "$status" | cut -d: -f2)

                if [ "$run_status" = "completed" ]; then
                  if [ "$conclusion" = "success" ]; then
                    echo "ðŸŽ¯ $workflow_name passed: $run_url"
                    echo "$output_var=success:$run_url" >> $GITHUB_OUTPUT
                    return 0
                  else
                    # Check if failures also exist in main branch
                    if check_failure_exists_in_main "$run_id" "$workflow_name"; then
                      local main_run_url=$(gh run list --workflow "$workflow_name" --branch "main" --limit 1 --json url --jq '.[0].url // empty' --repo "${{ env.METAL_REPO }}")
                      echo "âš ï¸ $workflow_name failed, but same failures exist in main - treating as pre-existing issue: [View run]($run_url) | [Main run]($main_run_url)"
                      echo "$output_var=success:$run_url" >> $GITHUB_OUTPUT
                      return 0
                    fi

                    echo "ðŸ›‘ $workflow_name failed (attempt $((retries + 1))): $run_url/attempts/$(($retries + 1))"
                    if [ $retries -ge $((MAX_RETRIES - 1)) ]; then
                      echo "$output_var=failure:$run_url" >> $GITHUB_OUTPUT
                      return 1
                    fi
                    break
                  fi
                fi
                sleep $POLL_INTERVAL
                elapsed=$((elapsed + POLL_INTERVAL))
              done
              # Handle timeout
              if [ $elapsed -ge $timeout_seconds ]; then
                echo "â° $workflow_name timed out after ${WORKFLOW_TIMEOUT}m: $run_url"
                echo "$output_var=timeout:$run_url" >> $GITHUB_OUTPUT
                return 1
              fi
              # Retry logic
              retries=$((retries + 1))
              if [ $retries -lt $MAX_RETRIES ]; then
                echo "ðŸ”„ Retrying $workflow_name (attempt $((retries + 1))/$MAX_RETRIES)"
                if gh run rerun "$run_id" --failed --repo "${{ env.METAL_REPO }}"; then
                  sleep 30
                  elapsed=0 # Reset timer for retry
                else
                  echo "ðŸ›‘ Failed to trigger retry for $workflow_name"
                  echo "$output_var=failure:$run_url" >> $GITHUB_OUTPUT
                  return 1
                fi
              fi
            done
            echo "$output_var=failure:$run_url" >> $GITHUB_OUTPUT
            return 1
          }

          # Monitor workflows using data-driven approach
          declare -A workflow_configs
          workflow_configs["all-post-commit-workflows.yaml"]="${{ inputs.run_all_post_commit }}:$ALL_POST_COMMIT_RUN_ID:all-post-commit-result"
          workflow_configs["blackhole-post-commit.yaml"]="${{ inputs.run_blackhole_post_commit }}:$BLACKHOLE_RUN_ID:blackhole-result"
          workflow_configs["tt-metal-l2-nightly.yaml"]="${{ inputs.run_all_post_commit || inputs.run_blackhole_post_commit }}:$TT_METAL_L2_NIGHTLY_RUN_ID:tt-metal-l2-nightly-result"
          workflow_configs["perf-device-models.yaml"]="${{ inputs.run_all_post_commit || inputs.run_blackhole_post_commit }}:$PERF_DEVICE_MODELS_RUN_ID:perf-device-models-result"
          exit_code=0
          for workflow_file in "${!workflow_configs[@]}"; do
            IFS=':' read -r enabled run_id output_var <<< "${workflow_configs[$workflow_file]}"

            if [ "$enabled" = "true" ]; then
              if ! monitor_workflow "$run_id" "$workflow_file" "$output_var"; then
                exit_code=1
              fi
            fi
          done
          exit $exit_code
      - name: Terminate spawned workflows on cancellation
        if: cancelled()
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
          PARENT_BRANCH_NAME: ${{ env.PARENT_BRANCH_NAME }}
        run: |
          echo "ðŸ”„ Parent workflow cancelled - cleaning up spawned workflows..."
          # Workflows spawned by this job
          SPAWNED_WORKFLOWS=("all-post-commit-workflows.yaml" "blackhole-post-commit.yaml" "tt-metal-l2-nightly.yaml" "perf-device-models.yaml")
          # Consider both queued and in_progress runs
          STATUSES=("queued" "in_progress")
          for workflow in "${SPAWNED_WORKFLOWS[@]}"; do
            for status in "${STATUSES[@]}"; do
              echo "ðŸ” Checking for $status instances of $workflow on branch $PARENT_BRANCH_NAME..."
              run_ids=$(gh run list \
                --workflow "$workflow" \
                --branch "$PARENT_BRANCH_NAME" \
                --status "$status" \
                --limit 100 \
                --json databaseId \
                --jq '.[].databaseId' \
                --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "")
              if [ -n "$run_ids" ]; then
                for run_id in $run_ids; do
                  echo "ðŸ›‘ Cancelling $status spawned workflow run $run_id ($workflow)..."
                  if gh run cancel "$run_id" --repo "${{ env.METAL_REPO }}"; then
                    echo "âœ… Successfully cancelled run $run_id"
                  else
                    echo "âš ï¸ Failed to cancel run $run_id (may have already completed)"
                  fi
                done
              else
                echo "â„¹ï¸ No $status instances of $workflow found"
              fi
            done
          done
          echo "âœ… Spawned workflow cleanup completed"

  cleanup-and-report:
    needs: setup-and-test
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Cleanup test branches
        if: needs.setup-and-test.outputs.branch-exists == 'true'
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          TEST_BRANCH_NAME="${{ needs.setup-and-test.outputs.test-branch-name }}"
          PARENT_BRANCH_NAME="${{ needs.setup-and-test.outputs.parent-branch-name }}"

          # Clean up test branch in submodule

          gh api --method DELETE "repos/${{ env.LLK_REPO }}/git/refs/heads/$TEST_BRANCH_NAME" 2>/dev/null || echo "Test branch already deleted or doesn't exist"

          # Clean up parent branch
          gh api --method DELETE "repos/${{ env.METAL_REPO }}/git/refs/heads/$PARENT_BRANCH_NAME" 2>/dev/null || echo "Parent branch already deleted or doesn't exist"

          echo "âœ… Cleaned up test branches"
      - name: Generate test report
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ inputs.mirrored_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.setup-and-test.outputs.branch-exists }}" = "true" ]; then
            echo "**Test Branch:** ${{ needs.setup-and-test.outputs.test-branch-name }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Test Configuration:**" >> $GITHUB_STEP_SUMMARY
            echo "- All Post-Commit Tests: ${{ inputs.run_all_post_commit && 'ðŸŸ¢ Enabled' || 'âšª Disabled' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Blackhole Post-Commit Tests: ${{ inputs.run_blackhole_post_commit && 'ðŸŸ¢ Enabled' || 'âšª Disabled' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Display detailed test results with links
            echo "**Test Results:**" >> $GITHUB_STEP_SUMMARY

            # Display test results using data-driven approach
            declare -A test_configs
            test_configs["All Post-Commit Tests"]="${{ inputs.run_all_post_commit }}:${{ needs.setup-and-test.outputs.all-post-commit-result }}"
            test_configs["Blackhole Post-Commit Tests"]="${{ inputs.run_blackhole_post_commit }}:${{ needs.setup-and-test.outputs.blackhole-result }}"
            test_configs["TT-Metal L2 Nightly APC Tests"]="${{ inputs.run_all_post_commit || inputs.run_blackhole_post_commit }}:${{ needs.setup-and-test.outputs.tt-metal-l2-nightly-result }}"
            test_configs["Device Perf Regressions"]="${{ inputs.run_all_post_commit || inputs.run_blackhole_post_commit }}:${{ needs.setup-and-test.outputs.perf-device-models-result }}"

            # Function to display test result
            display_test_result() {
              local test_name="$1"
              local enabled="$2"
              local result="$3"

              if [ "$enabled" = "true" ]; then
                if [ -n "$result" ]; then
                  local status=$(echo "$result" | cut -d: -f1)
                  local url=$(echo "$result" | cut -d: -f2-)
                  case "$status" in
                    "success") echo "- ðŸŽ¯ **$test_name:** Passed - [View run]($url)" >> $GITHUB_STEP_SUMMARY ;;
                    "failure") echo "- ðŸ›‘ **$test_name:** Failed - [View run]($url)" >> $GITHUB_STEP_SUMMARY ;;
                    "timeout") echo "- â° **$test_name:** Timed Out - [View run]($url)" >> $GITHUB_STEP_SUMMARY ;;
                    *) echo "- âšª **$test_name:** Status unknown ($status)" >> $GITHUB_STEP_SUMMARY ;;
                  esac
                else
                  echo "- âšª **$test_name:** No result captured" >> $GITHUB_STEP_SUMMARY
                fi
              else
                echo "- âšª **$test_name:** Not run" >> $GITHUB_STEP_SUMMARY
              fi
            }

            # Display results for all test types
            for test_name in "${!test_configs[@]}"; do
              IFS=':' read -r enabled result <<< "${test_configs[$test_name]}"
              display_test_result "$test_name" "$enabled" "$result"
            done

            echo "" >> $GITHUB_STEP_SUMMARY

          else
            echo "âŒ **Branch Setup:** Mirrored branch '${{ inputs.mirrored_branch }}' does not exist" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please ensure the branch has been mirrored using the mirror workflow first." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

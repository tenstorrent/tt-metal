name: Test LLK to Metal integration

on:
  workflow_dispatch:
    inputs:
      mirrored_branch:
        description: 'Mirrored branch name (e.g., mirror/branch-name)'
        required: true
        type: string
      run_all_post_commit:
        description: 'Run all post-commit tests'
        required: false
        type: boolean
        default: false
      run_blackhole_post_commit:
        description: 'Run Blackhole post-commit tests'
        required: false
        type: boolean
        default: false
      workflow_timeout:
        description: 'Timeout for workflows in minutes'
        required: false
        type: number
        default: 720
  workflow_call:
    inputs:
      mirrored_branch:
        description: 'Mirrored branch name (e.g., mirror/branch-name)'
        required: true
        type: string
      run_all_post_commit:
        description: 'Run all post-commit tests'
        required: false
        type: boolean
        default: false
      run_blackhole_post_commit:
        description: 'Run Blackhole post-commit tests'
        required: false
        type: boolean
        default: false
      workflow_timeout:
        description: 'Timeout for workflows in minutes'
        required: false
        type: number
        default: 720
    outputs:
      run-tests-result:
        description: 'Overall result of all test workflows (success/failure/cancelled)'
        value: ${{ jobs.run-tests.result }}
      branch-exists:
        description: 'Whether the mirrored branch exists'
        value: ${{ jobs.setup.outputs.branch-exists }}
      test-branch-name:
        description: 'Name of the test branch created'
        value: ${{ jobs.setup.outputs.test-branch-name }}
      all-post-commit-result:
        description: 'Result of All post-commit tests (status:url format)'
        value: ${{ jobs.run-tests.outputs.all-post-commit-result }}
      blackhole-result:
        description: 'Result of Blackhole post-commit tests (status:url format)'
        value: ${{ jobs.run-tests.outputs.blackhole-result }}
      tt-metal-l2-nightly-result:
        description: 'Result of All post-commit C++ tests (status:url format)'
        value: ${{ jobs.run-tests.outputs.tt-metal-l2-nightly-result }}
      perf-device-models-result:
        description: 'Result of Device perf regressions (status:url format)'
        value: ${{ jobs.run-tests.outputs.perf-device-models-result }}

# NOTE: Concurrency is intentionally NOT set here.
# When called via workflow_call, the caller (tt-llk) manages concurrency.
# This workflow's proactive cancellation step handles cleanup of spawned workflows.
# Setting concurrency here would conflict with the caller's concurrency settings.

env:
  PARENT_BRANCH_NAME: test-llk-${{ inputs.mirrored_branch }}-${{ github.run_id }}
  SUBMODULE_PATH: tt_metal/third_party/tt_llk
  WORKFLOW_TIMEOUT: ${{ inputs.workflow_timeout || 720 }}
  METAL_REPO: tenstorrent/tt-metal
  LLK_REPO: tenstorrent/tt-llk
  GH_TOKEN: ${{ secrets.LLK_UPLIFT_PAT }}
  MAX_RETRIES: 3
  POLL_INTERVAL: 120

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write
  checks: read

jobs:
  # Job 1: Setup - Prepare branches and determine which workflows to run
  setup:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      branch-exists: ${{ steps.check-branch.outputs.branch-exists }}
      test-branch-name: ${{ steps.check-branch.outputs.test-branch-name }}
      parent-branch-name: ${{ env.PARENT_BRANCH_NAME }}
      should-run-all-post-commit: ${{ inputs.run_all_post_commit }}
      should-run-blackhole: ${{ inputs.run_blackhole_post_commit }}
      should-run-l2-nightly: ${{ inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true }}
      should-run-perf: ${{ inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true }}
    steps:
      - name: Setup
        uses: actions/checkout@v4
        with:
          repository: tenstorrent/tt-metal
          submodules: recursive
          token: ${{ secrets.LLK_UPLIFT_PAT }}
          fetch-depth: 0
          ref: main
          clean: true

      - name: Configure git
        run: |
          git config --global user.name "LLK Integration Tester [bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Cancel any previous spawned workflows
        env:
          GH_TOKEN: ${{ secrets.LLK_UPLIFT_PAT }}
        run: |
          echo "ðŸ” Proactively cancelling any previous spawned workflows for this branch..."
          MIRRORED_BRANCH="${{ inputs.mirrored_branch }}"
          SPAWNED_WORKFLOWS=("all-post-commit-workflows.yaml" "blackhole-post-commit.yaml" "tt-metal-l2-nightly.yaml" "perf-device-models.yaml")
          STATUSES=("queued" "in_progress")

          for workflow in "${SPAWNED_WORKFLOWS[@]}"; do
            for status in "${STATUSES[@]}"; do
              echo "ðŸ” Checking for $status instances of $workflow..."
              run_data=$(gh run list \
                --workflow "$workflow" \
                --status "$status" \
                --limit 100 \
                --json databaseId,headBranch \
                --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "[]")

              run_ids=$(echo "$run_data" | jq -r --arg pattern "test-llk-$MIRRORED_BRANCH-" \
                '.[] | select(.headBranch | startswith($pattern)) | .databaseId')

              if [ -n "$run_ids" ]; then
                for run_id in $run_ids; do
                  echo "ðŸ›‘ Cancelling previous spawned workflow run $run_id ($workflow)..."
                  if gh run cancel "$run_id" --repo "${{ env.METAL_REPO }}"; then
                    echo "âœ… Successfully cancelled run $run_id"
                  else
                    echo "âš ï¸ Failed to cancel run $run_id (may have already completed)"
                  fi
                done
              else
                echo "â„¹ï¸ No $status instances of $workflow found for branch pattern test-llk-$MIRRORED_BRANCH-*"
              fi
            done
          done

          # Clean up old parent branches
          echo "ðŸ§¹ Cleaning up old parent branches..."
          OLD_BRANCHES=$(gh api "repos/${{ env.METAL_REPO }}/branches" --paginate --jq \
            --arg pattern "test-llk-$MIRRORED_BRANCH-" \
            '.[] | select(.name | startswith($pattern)) | .name' 2>/dev/null || echo "")

          if [ -n "$OLD_BRANCHES" ]; then
            for branch in $OLD_BRANCHES; do
              echo "ðŸ—‘ï¸ Deleting old parent branch: $branch"
              gh api --method DELETE "repos/${{ env.METAL_REPO }}/git/refs/heads/$branch" 2>/dev/null || \
                echo "âš ï¸ Failed to delete branch $branch (may not exist)"
            done
          else
            echo "â„¹ï¸ No old parent branches found"
          fi

          echo "âœ… Proactive cleanup completed"

      - name: Setup test branch and parent repository
        id: check-branch
        run: |
          MIRRORED_BRANCH="${{ inputs.mirrored_branch }}"
          TEST_BRANCH_NAME="test-llk-$MIRRORED_BRANCH-$(date +%s)"
          SUBMODULE_PATH="${{ env.SUBMODULE_PATH }}"
          cd "$SUBMODULE_PATH"

          # Ensure correct remote and fetch mirrored branch
          git remote set-url origin https://${{ secrets.LLK_UPLIFT_PAT }}@github.com/tenstorrent/tt-llk.git
          if git fetch origin "$MIRRORED_BRANCH:$MIRRORED_BRANCH" 2>/dev/null; then
            echo "branch-exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Mirrored branch '$MIRRORED_BRANCH' exists in submodule"

            cd "${{ github.workspace }}"
            PARENT_PINNED_COMMIT=$(git ls-tree main "$SUBMODULE_PATH" | awk '{print $3}')
            cd "$SUBMODULE_PATH"

            git checkout -b "$TEST_BRANCH_NAME" "$MIRRORED_BRANCH"

            echo "ðŸ” Checking if branch needs updates from latest submodule main..."
            BRANCH_VS_MAIN_COMMITS=$(git rev-list --count HEAD..origin/main)
            if [ "$BRANCH_VS_MAIN_COMMITS" -gt 0 ]; then
              echo "ðŸ”„ Branch is $BRANCH_VS_MAIN_COMMITS commits behind latest main - merging latest changes"
              if ! git merge origin/main --no-edit; then
                echo "âŒ Merge with latest main failed - conflicts need manual resolution."
                echo "   This usually means your mirrored branch is conflicting with recent changes on origin/main in the LLK submodule."
                echo "   Please resolve the merge conflicts locally (e.g., checkout '$MIRRORED_BRANCH', merge origin/main, fix conflicts), push the updated branch to origin, and re-run this workflow."
                exit 1
              fi
              echo "âœ… Successfully merged latest submodule main into branch"
            else
              echo "âœ… Branch is up to date with latest submodule main"
            fi

            if ! git push origin "$TEST_BRANCH_NAME"; then
              echo "âŒ Failed to push test branch to origin"
              exit 1
            fi

            cd "${{ github.workspace }}"
            git checkout -b "${{ env.PARENT_BRANCH_NAME }}"
            git add "$SUBMODULE_PATH"
            git commit -m "test: update LLK submodule to test branch $TEST_BRANCH_NAME from mirrored branch $MIRRORED_BRANCH"
            if ! git push origin "${{ env.PARENT_BRANCH_NAME }}"; then
              echo "âŒ Failed to push parent branch to origin"
              exit 1
            fi

            echo "test-branch-name=$TEST_BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "âœ… Created test branch '$TEST_BRANCH_NAME' and updated parent repository"
          else
            echo "branch-exists=false" >> $GITHUB_OUTPUT
            echo "âŒ Mirrored branch '$MIRRORED_BRANCH' does not exist in submodule"
          fi

  # Job 2: Run tests using matrix strategy for parallel execution
  run-tests:
    needs: setup
    if: |
      needs.setup.outputs.branch-exists == 'true' &&
      (inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true)
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.workflow_timeout || 720 }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - workflow: "all-post-commit-workflows.yaml"
            name: "All Post Commit Workflows"
            output-key: "all-post-commit-result"
            should-run: ${{ inputs.run_all_post_commit }}
            arch: ""  # all-post-commit doesn't use architecture parameter
          - workflow: "blackhole-post-commit.yaml"
            name: "Blackhole Post Commit"
            output-key: "blackhole-result"
            should-run: ${{ inputs.run_blackhole_post_commit }}
            arch: ""  # blackhole-post-commit doesn't use architecture parameter
          - workflow: "tt-metal-l2-nightly.yaml"
            name: "TT-Metal L2 Nightly APC"
            output-key: "tt-metal-l2-nightly-result"
            should-run: ${{ inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true }}
            arch: "dynamic"  # architecture determined at runtime based on enabled tests
          - workflow: "perf-device-models.yaml"
            name: "Device Perf Regressions"
            output-key: "perf-device-models-result"
            should-run: ${{ inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true }}
            arch: "dynamic"  # architecture determined at runtime based on enabled tests
    outputs:
      all-post-commit-result: ${{ steps.monitor.outputs.all-post-commit-result }}
      blackhole-result: ${{ steps.monitor.outputs.blackhole-result }}
      tt-metal-l2-nightly-result: ${{ steps.monitor.outputs.tt-metal-l2-nightly-result }}
      perf-device-models-result: ${{ steps.monitor.outputs.perf-device-models-result }}
    steps:
      - name: Skip if not enabled
        if: matrix.should-run != true && matrix.should-run != 'true'
        run: |
          echo "âšª Skipping ${{ matrix.name }} - not enabled for this run"

      - name: Trigger and monitor workflow
        id: monitor
        if: matrix.should-run == true || matrix.should-run == 'true'
        env:
          GH_TOKEN: ${{ secrets.LLK_UPLIFT_PAT }}
          WORKFLOW_TIMEOUT: ${{ inputs.workflow_timeout || 720 }}
          MAX_RETRIES: 3
          POLL_INTERVAL: ${{ env.POLL_INTERVAL }}
          PARENT_BRANCH_NAME: ${{ needs.setup.outputs.parent-branch-name }}
        run: |
          WORKFLOW="${{ matrix.workflow }}"
          DISPLAY_NAME="${{ matrix.name }}"
          OUTPUT_KEY="${{ matrix.output-key }}"
          ARCH_TYPE="${{ matrix.arch }}"

          echo "ðŸš€ Triggering $DISPLAY_NAME ($WORKFLOW)..."

          # Build architecture parameter dynamically if needed
          if [ "$ARCH_TYPE" = "dynamic" ]; then
            if [ "${{ inputs.run_all_post_commit }}" = "true" ] && [ "${{ inputs.run_blackhole_post_commit }}" = "true" ]; then
              ARCH_PARAM='["wormhole_b0", "blackhole"]'
            elif [ "${{ inputs.run_all_post_commit }}" = "true" ]; then
              ARCH_PARAM='["wormhole_b0"]'
            else
              ARCH_PARAM='["blackhole"]'
            fi
            echo "ðŸ“‹ Using architecture parameter: $ARCH_PARAM"
          fi

          # Trigger workflow with appropriate inputs
          if [ "$WORKFLOW" = "tt-metal-l2-nightly.yaml" ]; then
            gh workflow run "$WORKFLOW" --ref "$PARENT_BRANCH_NAME" --repo "${{ env.METAL_REPO }}" \
              -f architecture="$ARCH_PARAM" \
              -f run_cpp_tests=true \
              -f run_metal_iommu_tests=true \
              -f run_sd_unit_tests=true \
              -f run_fd_unit_tests=true \
              -f run_profiler_regression=true \
              -f run_tt_train_cpp_unit_tests=true \
              -f run_models_unit_tests=true \
              -f run_tt_cnn_unit_tests=true
          elif [ "$WORKFLOW" = "perf-device-models.yaml" ]; then
            gh workflow run "$WORKFLOW" --ref "$PARENT_BRANCH_NAME" --repo "${{ env.METAL_REPO }}" \
              -f architecture="$ARCH_PARAM"
          else
            gh workflow run "$WORKFLOW" --ref "$PARENT_BRANCH_NAME" --repo "${{ env.METAL_REPO }}"
          fi

          # Poll for run ID
          run_id=""
          for i in {1..12}; do
            sleep 5
            run_data=$(gh run list --workflow "$WORKFLOW" --branch "$PARENT_BRANCH_NAME" --limit 1 \
              --json databaseId,url --jq '.[0] | select(.databaseId != null) | "\(.databaseId)|\(.url)"' \
              --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "")
            if [ -n "$run_data" ] && [ "$run_data" != "null" ]; then
              run_id=$(echo "$run_data" | cut -d'|' -f1)
              run_url=$(echo "$run_data" | cut -d'|' -f2)
              break
            fi
          done

          if [ -z "$run_id" ]; then
            echo "âŒ Failed to get run ID for $DISPLAY_NAME"
            echo "$OUTPUT_KEY=failure:unknown" >> $GITHUB_OUTPUT
            exit 1
          fi

          run_url="https://github.com/${{ env.METAL_REPO }}/actions/runs/$run_id"
          echo "âœ… $DISPLAY_NAME triggered (run ID: $run_id): $run_url"

          # Monitor workflow with retry logic for failed jobs
          attempt=1
          timeout_seconds=$((WORKFLOW_TIMEOUT * 60))
          max_attempts=$MAX_RETRIES

          while [ $attempt -le $max_attempts ]; do
            echo "ðŸ“Š Monitoring $DISPLAY_NAME (attempt $attempt/$max_attempts)..."
            elapsed=0
            should_retry=false

            while [ $elapsed -lt $timeout_seconds ]; do
              status=$(gh run view "$run_id" --json status,conclusion \
                --jq '.status + ":" + (.conclusion // "")' \
                --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "unknown:")
              run_status=$(echo "$status" | cut -d: -f1)
              conclusion=$(echo "$status" | cut -d: -f2)

              if [ "$run_status" = "completed" ]; then
                if [ "$conclusion" = "success" ]; then
                  echo "ðŸŽ¯ $DISPLAY_NAME passed: $run_url"
                  echo "$OUTPUT_KEY=success:$run_url" >> $GITHUB_OUTPUT
                  exit 0
                else
                  echo "ðŸ›‘ $DISPLAY_NAME completed with status: $conclusion (attempt $attempt/$max_attempts)"

                  # Check if we should retry
                  if [ $attempt -lt $max_attempts ]; then
                    echo "ðŸ”„ Retrying failed jobs only (will be attempt $((attempt + 1))/$max_attempts)..."

                    if gh run rerun "$run_id" --failed --repo "${{ env.METAL_REPO }}"; then
                      echo "âœ… Rerun triggered for run ID: $run_id"
                      sleep 30  # Wait for rerun to start
                      should_retry=true
                      break  # Break inner loop to continue outer loop for next attempt
                    else
                      echo "âŒ Failed to trigger rerun"
                      echo "$OUTPUT_KEY=failure:$run_url" >> $GITHUB_OUTPUT
                      exit 1
                    fi
                  else
                    echo "âŒ Max retries reached ($max_attempts attempts)"
                    echo "$OUTPUT_KEY=failure:$run_url" >> $GITHUB_OUTPUT
                    exit 1
                  fi
                fi
              fi

              sleep $POLL_INTERVAL
              elapsed=$((elapsed + POLL_INTERVAL))
            done

            # Check if we broke out to retry or if we timed out
            if [ "$should_retry" = "true" ]; then
              attempt=$((attempt + 1))
              continue  # Continue to next retry attempt
            fi

            # If we didn't break for retry, we timed out
            if [ $elapsed -ge $timeout_seconds ]; then
              echo "â° $DISPLAY_NAME timed out after ${WORKFLOW_TIMEOUT}m: $run_url"
              echo "$OUTPUT_KEY=timeout:$run_url" >> $GITHUB_OUTPUT
              exit 1
            fi
          done

          # Fallback for unexpected exit from retry loop (shouldn't normally be reached)
          if [ "$attempt" -gt "$max_attempts" ]; then
            echo "âŒ $DISPLAY_NAME failed after $max_attempts attempts"
            echo "$OUTPUT_KEY=failure:$run_url" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "âŒ $DISPLAY_NAME monitoring ended unexpectedly (attempt: $attempt/$max_attempts, should_retry: $should_retry)"
            echo "$OUTPUT_KEY=unknown:$run_url" >> $GITHUB_OUTPUT
            exit 1
          fi

  # Job 3: Terminate spawned workflows if parent is cancelled
  cancel-on-failure:
    needs: [setup]
    if: always() && cancelled() && needs.setup.outputs.branch-exists == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Terminate spawned workflows
        env:
          GH_TOKEN: ${{ secrets.LLK_UPLIFT_PAT }}
          PARENT_BRANCH_NAME: ${{ needs.setup.outputs.parent-branch-name }}
        run: |
          echo "ðŸ”„ Parent workflow cancelled - cleaning up spawned workflows..."
          SPAWNED_WORKFLOWS=("all-post-commit-workflows.yaml" "blackhole-post-commit.yaml" "tt-metal-l2-nightly.yaml" "perf-device-models.yaml")
          STATUSES=("queued" "in_progress")

          for workflow in "${SPAWNED_WORKFLOWS[@]}"; do
            for status in "${STATUSES[@]}"; do
              echo "ðŸ” Checking for $status instances of $workflow on branch $PARENT_BRANCH_NAME..."
              run_ids=$(gh run list \
                --workflow "$workflow" \
                --branch "$PARENT_BRANCH_NAME" \
                --status "$status" \
                --limit 100 \
                --json databaseId \
                --jq '.[].databaseId' \
                --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "")
              if [ -n "$run_ids" ]; then
                for run_id in $run_ids; do
                  echo "ðŸ›‘ Cancelling $status spawned workflow run $run_id ($workflow)..."
                  if gh run cancel "$run_id" --repo "${{ env.METAL_REPO }}"; then
                    echo "âœ… Successfully cancelled run $run_id"
                  else
                    echo "âš ï¸ Failed to cancel run $run_id (may have already completed)"
                  fi
                done
              else
                echo "â„¹ï¸ No $status instances of $workflow found"
              fi
            done
          done
          echo "âœ… Spawned workflow cleanup completed"

  cleanup-and-report:
    needs: [setup, run-tests]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Cleanup test branches
        if: needs.setup.outputs.branch-exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.LLK_UPLIFT_PAT }}
        run: |
          TEST_BRANCH_NAME="${{ needs.setup.outputs.test-branch-name }}"
          PARENT_BRANCH_NAME="${{ needs.setup.outputs.parent-branch-name }}"

          # Clean up test branch in submodule
          gh api --method DELETE "repos/${{ env.LLK_REPO }}/git/refs/heads/$TEST_BRANCH_NAME" 2>/dev/null || echo "Test branch already deleted or doesn't exist"

          # Clean up parent branch
          gh api --method DELETE "repos/${{ env.METAL_REPO }}/git/refs/heads/$PARENT_BRANCH_NAME" 2>/dev/null || echo "Parent branch already deleted or doesn't exist"

          echo "âœ… Cleaned up test branches"

      - name: Generate test report
        env:
          GH_TOKEN: ${{ secrets.LLK_UPLIFT_PAT }}
          PARENT_BRANCH_NAME: ${{ needs.setup.outputs.parent-branch-name }}
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ inputs.mirrored_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.setup.outputs.branch-exists }}" = "true" ]; then
            echo "**Test Branch:** ${{ needs.setup.outputs.test-branch-name }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Test Configuration:**" >> $GITHUB_STEP_SUMMARY
            echo "- All Post-Commit Tests: ${{ inputs.run_all_post_commit && 'ðŸŸ¢ Enabled' || 'âšª Disabled' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Blackhole Post-Commit Tests: ${{ inputs.run_blackhole_post_commit && 'ðŸŸ¢ Enabled' || 'âšª Disabled' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "**Test Results:**" >> $GITHUB_STEP_SUMMARY

            # Function to check workflow status from GitHub API
            check_workflow_result() {
              local workflow_file="$1"
              local test_name="$2"
              local enabled="$3"

              if [ "$enabled" != "true" ]; then
                echo "- âšª **$test_name:** Not run" >> $GITHUB_STEP_SUMMARY
                return
              fi

              # Get the latest run for this workflow on our branch
              local run_data=$(gh run list \
                --workflow "$workflow_file" \
                --branch "$PARENT_BRANCH_NAME" \
                --limit 1 \
                --json conclusion,url,status \
                --jq '.[0] // empty' \
                --repo "${{ env.METAL_REPO }}" 2>/dev/null || echo "")

              if [ -z "$run_data" ] || [ "$run_data" = "null" ]; then
                echo "- âšª **$test_name:** No run found" >> $GITHUB_STEP_SUMMARY
                return
              fi

              local status=$(echo "$run_data" | jq -r '.status // "unknown"')
              local conclusion=$(echo "$run_data" | jq -r '.conclusion // "unknown"')
              local url=$(echo "$run_data" | jq -r '.url // ""')

              if [ "$status" != "completed" ]; then
                echo "- ðŸ”„ **$test_name:** In progress - [View run]($url)" >> $GITHUB_STEP_SUMMARY
              elif [ "$conclusion" = "success" ]; then
                echo "- ðŸŽ¯ **$test_name:** Passed - [View run]($url)" >> $GITHUB_STEP_SUMMARY
              elif [ "$conclusion" = "failure" ]; then
                echo "- ðŸ›‘ **$test_name:** Failed - [View run]($url)" >> $GITHUB_STEP_SUMMARY
              elif [ "$conclusion" = "cancelled" ]; then
                echo "- â¹ï¸ **$test_name:** Cancelled - [View run]($url)" >> $GITHUB_STEP_SUMMARY
              elif [ "$conclusion" = "timed_out" ]; then
                echo "- â° **$test_name:** Timed Out - [View run]($url)" >> $GITHUB_STEP_SUMMARY
              else
                echo "- âšª **$test_name:** Status: $conclusion - [View run]($url)" >> $GITHUB_STEP_SUMMARY
              fi
            }

            # Check results for each workflow type
            check_workflow_result "all-post-commit-workflows.yaml" "All Post-Commit Tests" "${{ inputs.run_all_post_commit }}"
            check_workflow_result "blackhole-post-commit.yaml" "Blackhole Post-Commit Tests" "${{ inputs.run_blackhole_post_commit }}"
            check_workflow_result "tt-metal-l2-nightly.yaml" "TT-Metal L2 Nightly APC Tests" "${{ inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true }}"
            check_workflow_result "perf-device-models.yaml" "Device Perf Regressions" "${{ inputs.run_all_post_commit == true || inputs.run_blackhole_post_commit == true }}"

            echo "" >> $GITHUB_STEP_SUMMARY

            # Overall status
            if [ "${{ needs.run-tests.result }}" = "success" ]; then
              echo "### âœ… All tests passed!" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.run-tests.result }}" = "failure" ]; then
              echo "### âŒ Some tests failed" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.run-tests.result }}" = "cancelled" ]; then
              echo "### â¹ï¸ Tests were cancelled" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.run-tests.result }}" = "skipped" ]; then
              echo "### âšª Tests were skipped" >> $GITHUB_STEP_SUMMARY
            fi

          else
            echo "âŒ **Branch Setup:** Mirrored branch '${{ inputs.mirrored_branch }}' does not exist" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please ensure the branch has been mirrored using the mirror workflow first." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

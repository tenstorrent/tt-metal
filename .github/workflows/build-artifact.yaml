name: "Build tt-metal artifacts"

permissions:
  packages: write

on:
  workflow_call:
    inputs:
      build-type:
        required: false
        type: string
        default: "Release"
      tracy:
        required: false
        type: boolean
        default: false
        description: "Build with tracy enabled"
      distributed:
        required: false
        type: boolean
        default: true
        description: "Build with distributed enabled (Adds OpenMPI dependency)"
      build-wheel:
        required: false
        type: boolean
        default: false
        description: "Build Python Wheel"
      architecture:
        required: false
        type: string
        default: "amd64"
      toolchain:
        required: false
        type: string
        default: "cmake/x86_64-linux-clang-20-libstdcpp-toolchain.cmake"
        description: "Toolchain file to use for build"
      publish-artifact:
        required: false
        type: boolean
        default: true
        description: "Make resulting artifact available in the workflow"
      publish-package:
        required: false
        type: boolean
        default: true
        description: "Make resulting debian packages available in the workflow"
      skip-tt-train:
        # FIXME: TT-Train needs to get fixed to not assume a specific toolchain.
        #        Fow now enabling an opt-out. But this should get removed.
        required: false
        type: boolean
        default: true
      profile:
        required: false
        type: boolean
        default: false
        description: "Profile the compilation"
      build-umd-tests:
        required: false
        type: boolean
        default: false
        description: "Build UMD tests"
      enable-lto:
        required: false
        type: boolean
        default: false
        description: "Enable Link Time Optimization (LTO)"
      platform:
        required: false
        type: string
        default: ""
        description: >-
          Platform string (e.g., 'Ubuntu 22.04', 'Ubuntu 24.04').
          If provided, overrides distro/version/toolchain.
      fetch-depth:
        required: false
        type: number
        default: 500
        description: >-
          Git fetch depth for the checkout step. Must be large enough to
          include all tags and history needed for `git describe`.
      ref:
        required: false
        type: string
        default: ""
        description: 'Commit SHA to test (default: HEAD)'
      use-artifacts-from-run:
        required: false
        type: string
        default: ""
        description: "Workflow run ID to download artifacts from (skips build)"
      # Pre-built Docker image tags (optional - if provided, skips docker build)
      ci-build-docker-image:
        required: false
        type: string
        default: ""
        description: "Pre-built CI Build Docker image tag"
      ci-test-docker-image:
        required: false
        type: string
        default: ""
        description: "Pre-built CI Test Docker image tag"
      dev-docker-image:
        required: false
        type: string
        default: ""
        description: "Pre-built Dev Docker image tag"
      basic-dev-docker-image:
        required: false
        type: string
        default: ""
        description: "Pre-built Basic Dev Docker image tag"
      basic-ttnn-runtime-docker-image:
        required: false
        type: string
        default: ""
        description: "Pre-built Basic TTNN Runtime Docker image tag"
      manylinux-docker-image:
        required: false
        type: string
        default: ""
        description: "Pre-built ManyLinux Docker image tag"
    outputs:
      ci-build-docker-image:
        description: >-
          Docker tag for the CI Build Docker image for building TT-Metalium et al
        value: >-
          ${{ inputs.ci-build-docker-image || jobs.build-docker-image.outputs.ci-build-tag }}
      ci-test-docker-image:
        description: "Docker tag for the CI Test Docker image for testing TT-Metalium et al"
        value: ${{ inputs.ci-test-docker-image || jobs.build-docker-image.outputs.ci-test-tag }}
      dev-docker-image:
        description: "Docker tag for the dev Docker image for developing TT-Metalium et al"
        value: ${{ inputs.dev-docker-image || jobs.build-docker-image.outputs.dev-tag }}
      basic-dev-docker-image:
        description: "Docker tag for the basic dev Docker image for basic development"
        value: ${{ inputs.basic-dev-docker-image || jobs.build-docker-image.outputs.basic-dev-tag }}
      basic-ttnn-runtime-docker-image:
        description: "Docker tag for the basic TTNN runtime Docker image for running TTNN"
        value: ${{ inputs.basic-ttnn-runtime-docker-image || jobs.build-docker-image.outputs.basic-ttnn-runtime-tag }}
      manylinux-docker-image:
        description: "Docker tag for the ManyLinux Docker image"
        value: ${{ inputs.manylinux-docker-image || jobs.build-docker-image.outputs.manylinux-tag }}
      packages-artifact-name:
        description: "Name to give download-artifact to get the packages"
        value: >-
          ${{ jobs.build-artifact.result == 'success' &&
              jobs.build-artifact.outputs.packages-artifact-name ||
              (jobs.download-artifacts.result == 'success' &&
               jobs.download-artifacts.outputs.packages-artifact-name || '') }}
      build-artifact-name:
        description: "Name of the published build artifact"
        value: >-
          ${{ jobs.build-artifact.result == 'success' &&
              jobs.build-artifact.outputs.build_artifact_name ||
              (jobs.download-artifacts.result == 'success' &&
               jobs.download-artifacts.outputs.build_artifact_name || '') }}
      wheel-artifact-name:
        description: "Name of the published wheel artifact"
        value: >-
          ${{ jobs.build-wheel.result == 'success' &&
              jobs.build-wheel.outputs.artifact-name ||
              (jobs.download-artifacts.result == 'success' &&
               jobs.download-artifacts.outputs.wheel_artifact_name || '') }}

  workflow_dispatch:
    inputs:
      tracy:
        required: false
        type: boolean
        default: false
        description: "Build with tracy enabled"
      distributed:
        required: false
        type: boolean
        default: true
        description: "Build with distributed enabled (Adds OpenMPI dependency)"
      build-wheel:
        required: false
        type: boolean
        default: false
        description: "Build Python Wheel"
      architecture:
        required: false
        type: string
        default: "amd64"
      toolchain:
        required: false
        type: string
        default: "cmake/x86_64-linux-clang-20-libstdcpp-toolchain.cmake"
        description: "Toolchain file to use for build"
      profile:
        required: false
        type: boolean
        default: false
        description: "Profile the compilation"
      build-umd-tests:
        required: false
        type: boolean
        default: false
        description: "Build UMD tests"
      platform:
        required: false
        type: choice
        default: "Ubuntu 22.04"
        options:
          - "Ubuntu 22.04"
          - "Ubuntu 24.04"
        description: "Target Platform"
      build-type:
        required: false
        type: string
        default: "Release"
      enable-lto:
        required: false
        type: boolean
        default: false
        description: "Enable Link Time Optimization (LTO)"

jobs:
  # =============================================================================
  # ARCHITECTURE NOTE: Platform Parsing
  # =============================================================================
  # This workflow handles platform parsing internally via the parse-platform job.
  # Callers should NOT run their own parse-platform job - just pass:
  #   - platform: "Ubuntu 22.04" or "Ubuntu 24.04"
  #   - enable-lto: true/false (optional, defaults based on platform)
  #
  # The parse-platform job converts the platform string to distro/version/toolchain
  # and applies platform-specific defaults (e.g., LTO settings).
  # =============================================================================

  # Parse platform dropdown to extract distro/version/toolchain
  parse-platform:
    runs-on: ubuntu-latest
    outputs:
      distro: ${{ steps.parse.outputs.distro }}
      version: ${{ steps.parse.outputs.version }}
      toolchain: ${{ steps.parse.outputs.toolchain }}
      enable-lto: ${{ steps.parse.outputs.enable-lto }}
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: .github/actions
          sparse-checkout-cone-mode: true
      - id: parse
        uses: ./.github/actions/parse-platform
        with:
          platform: ${{ inputs.platform }}
          enable-lto: ${{ inputs.enable-lto || false }}

  # =============================================================================
  # ARCHITECTURE NOTE: Docker Image Caching
  # =============================================================================
  # Docker images can be provided in two ways:
  # 1. Pre-built: Pass ci-build-docker-image, dev-docker-image, etc. as inputs
  #    (used by merge-gate.yaml which builds all images once upfront)
  # 2. On-demand: Leave docker image inputs empty; build-docker-image job runs
  #
  # The "always() && !failure() && !cancelled()" pattern is used throughout to
  # allow jobs to run even when upstream jobs are SKIPPED (not just successful).
  # This is necessary because pre-built image inputs cause build-docker-image
  # to be skipped, but downstream jobs still need to run.
  # =============================================================================

  # Only build docker images if pre-built tags are not provided
  build-docker-image:
    if: ${{ always() && !failure() && !cancelled() && inputs.ci-build-docker-image == '' }}
    uses: ./.github/workflows/build-docker-artifact.yaml
    secrets: inherit
    with:
      platform: ${{ inputs.platform || 'Ubuntu 22.04' }}
      architecture: ${{ inputs.architecture }}

  download-artifacts:
    if: ${{ inputs.use-artifacts-from-run != '' }}
    runs-on: ubuntu-latest
    outputs:
      build_artifact_name: ${{ steps.download.outputs.build-artifact-name }}
      wheel_artifact_name: ${{ steps.download.outputs.wheel-artifact-name }}
      packages-artifact-name: ${{ steps.download.outputs.packages-artifact-name }}
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          sparse-checkout: .github/actions
          sparse-checkout-cone-mode: true

      - name: Download artifacts from workflow run
        id: download
        env:
          GH_TOKEN: ${{ github.token }}
        uses: ./.github/actions/download-artifacts-from-run
        with:
          workflow_run_id: ${{ inputs.use-artifacts-from-run }}
          working-directory: ${{ github.workspace }}/artifacts
          tracy: ${{ inputs.tracy }}

      - name: Upload build artifact for downstream jobs
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.download.outputs.build-artifact-name }}
          path: ${{ github.workspace }}/artifacts/ttm_any.tar.zst
          if-no-files-found: error
          retention-days: 1

      - name: Upload wheel artifact
        if: ${{ steps.download.outputs.wheel-artifact-name != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.download.outputs.wheel-artifact-name }}
          path: ${{ github.workspace }}/artifacts/*.whl
          if-no-files-found: ignore
          retention-days: 1

      - name: Upload packages artifact
        if: ${{ steps.download.outputs.packages-artifact-name != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.download.outputs.packages-artifact-name }}
          path: ${{ github.workspace }}/artifacts/*.deb
          if-no-files-found: ignore
          retention-days: 1

  build-artifact:
    # Use always() so this job runs even when build-docker-image is skipped (pre-built tags provided)
    if: ${{ always() && !failure() && !cancelled() && inputs.use-artifacts-from-run == '' }}
    name: >-
      üõ†Ô∏è Build ${{ inputs.build-type }}
      ${{ needs.parse-platform.outputs.distro }}
      ${{ needs.parse-platform.outputs.version }}
    needs: [parse-platform, build-docker-image]
    timeout-minutes: 100
    runs-on: tt-ubuntu-2204-large-stable
    environment: ${{ github.ref == 'refs/heads/main' && 'mainline' || '' }}
    outputs:
      packages-artifact-name: ${{ steps.set-artifact-name.outputs.name }}
      build_artifact_name: ${{ steps.set_build_artifact_name.outputs.build_artifact_name }}
    env:
      # Platform values from parse-platform job (handles both workflow_dispatch and workflow_call)
      DISTRO: ${{ needs.parse-platform.outputs.distro }}
      VERSION: ${{ needs.parse-platform.outputs.version }}
      TOOLCHAIN: ${{ inputs.toolchain || needs.parse-platform.outputs.toolchain }}
    container:
      image: >-
        harbor.ci.tenstorrent.net/${{
          inputs.ci-build-docker-image ||
          needs.build-docker-image.outputs.ci-build-tag ||
          'docker-image-unresolved!' }}
      env:
        CCACHE_REMOTE_ONLY: "true"
        CCACHE_TEMPDIR: /tmp/ccache
        # TODO: Revisit the addition of these env vars https://github.com/tenstorrent/tt-metal/issues/20161
        TRACY_NO_INVARIANT_CHECK: 1
        TRACY_NO_ISA_EXTENSIONS: 1
      volumes:
        - ${{ github.workspace }}:/work
        # HOME is hardcoded for no clear reason: https://github.com/actions/runner/issues/863
        - /home/ubuntu/.ccache-ci:/github/home/.ccache
      # Group 1457 is for the shared ccache drive
      # tmpfs is for efficiency
      options: >
        --group-add 1457
        --tmpfs /tmp
    defaults:
      run:
        shell: bash
        working-directory: /work # https://github.com/actions/runner/issues/878

    steps:
      - name: Check Redis credentials
        # Failing internal jobs draws attention immediately so we can fix them and make them fast.
        # Forks will never have secrets; don't fail the job for them, they'll just run slower
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        run: |
          if [ -z "${{ secrets.REDIS_PASSWORD }}" ]; then
            echo "Redis password is missing. Did you forget 'secrets: inherit'?"
            exit 1
          fi
          # Conditionally set this here so that it remains unset on forks,
          # otherwise it resolves an invalid URL and the job fails
          REDIS_USER="${{ vars.REDIS_USER }}"
          REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
          REDIS_HOST="${{ vars.REDIS_HOST }}"
          REDIS_PORT="${{ vars.REDIS_PORT }}"
          REDIS_READONLY="${{ vars.REDIS_IS_READONLY }}"
          CCACHE_PARTS=(
            "redis://${REDIS_USER}:${REDIS_PASSWORD}"
            "@${REDIS_HOST}:${REDIS_PORT}"
            "|read-only=${REDIS_READONLY}"
          )
          CCACHE_REMOTE_STORAGE=$(IFS=''; echo "${CCACHE_PARTS[*]}")
          echo "CCACHE_REMOTE_STORAGE=${CCACHE_REMOTE_STORAGE}" >> $GITHUB_ENV
          echo "CCACHE_REMOTE_STORAGE: ${CCACHE_REMOTE_STORAGE}"

      - name: Set artifact name
        id: set-artifact-name
        run: |
          TOOLCHAIN_CLEANED=$(echo "${{ env.TOOLCHAIN }}" | sed -E 's/^cmake\///; s/-toolchain\.cmake$//')
          # Use full sanitized ref/SHA and workflow run ID to ensure uniqueness
          # Sanitize ref/SHA by replacing invalid characters with hyphens
          RAW_REF="${{ inputs.ref || github.sha }}"
          SANITIZED_REF=$(echo "$RAW_REF" | sed 's/[\/:"<>|*?\r\n\\]/-/g')
          TRACY_SUFFIX="${{ (inputs.tracy && '-profiler') || '' }}"
          DIST_SUFFIX="${{ (inputs.distributed == false && '-no-distributed') || '' }}"
          DISTRO="${{ env.DISTRO }}"
          VERSION="${{ env.VERSION }}"
          ARCH="${{ inputs.architecture }}"
          BUILD_TYPE="${{ inputs.build-type }}"
          RUN_ID="${{ github.run_id }}"
          ARTIFACT_PARTS=(
            "packages"
            "${DISTRO}"
            "${VERSION}"
            "${ARCH}"
            "${BUILD_TYPE}"
            "${TOOLCHAIN_CLEANED}${TRACY_SUFFIX}${DIST_SUFFIX}"
            "${SANITIZED_REF}"
            "${RUN_ID}"
          )
          ARTIFACT_NAME=$(IFS='-'; echo "${ARTIFACT_PARTS[*]}")

          echo "name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"
          echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> "$GITHUB_ENV"

      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          ref: ${{ inputs.ref || github.sha }}
          fetch-depth: ${{ inputs.fetch-depth }}
          fetch-tags: true # Need tags for `git describe`

      - name: Create ccache tmpdir
        run: |
          mkdir -p /tmp/ccache

      - name: Prepare ccache summary
        run: |
          # Zero out the stats so we can see how we did this build
          # NOTE: may be inaccurate if we have >1 build runner on the same machine, using the same local cache
          ccache -z

      - name: üîß Configure git safe.directory
        run: |
          # The checkout action adds $GITHUB_WORKSPACE (/__w/tt-metal/tt-metal) as a safe directory,
          # but not /work which is mounted from the host. Git commands from /work fail due to
          # ownership mismatch (host uid vs container root). Add /work to safe.directory.
          git config --global --add safe.directory /work

      - name: üîß CMake configure
        run: |
          set -eu # basic shell hygiene

          if [ "${{ inputs.skip-tt-train }}" = "true" ]; then
            args_fixme="--build-metal-tests --build-ttnn-tests --build-programming-examples"
          else
            args_fixme="--build-all"
          fi
          echo "Args: ${args_fixme}"

          build_args=(
            "./build_metal.sh"
            "--build-dir" "build"
            "--build-type" "${{ inputs.build-type }}"
            "--toolchain-path" "${{ env.TOOLCHAIN }}"
            ${args_fixme}
            "--enable-ccache"
            "--configure-only"
          )

          echo "Build tracy: ${{ inputs.tracy }}"
          if [ "${{ inputs.tracy }}" = "false" ]; then
            build_args+=("--disable-profiler")
          fi
          echo "Build distributed: ${{ inputs.distributed }}"
          if [ "${{ inputs.distributed }}" = "false" ]; then
            build_args+=("--without-distributed")
          fi
          if [ "${{ inputs.profile }}" = "true" ]; then
            build_args+=("--enable-time-trace" "--disable-unity-builds")
          fi
          if [ "${{ inputs.build-umd-tests }}" = "true" ]; then
            build_args+=("--build-umd-tests")
          fi
          if [ "${{ inputs.enable-lto }}" = "true" ]; then
            build_args+=("--enable-lto")
          fi
          echo "build-artifact.yaml running: ${build_args[*]}"
          "${build_args[@]}"

      - name: üõ†Ô∏è Compile
        timeout-minutes: 90
        run: |
          # --target install is for the tarball that should get replaced by proper packaging later
          cmake --build build --target install

      - name: üõ†Ô∏è Profile
        if: ${{ inputs.profile }}
        run: |
          echo "maxNameLength = 300" > ClangBuildAnalyzer.ini
          ClangBuildAnalyzer --all build capture.bin
          ClangBuildAnalyzer --analyze capture.bin

      - name: üì¶ Package
        timeout-minutes: 10
        run: |
          cmake --build build --target package

          if [[ "${{ env.DISTRO }}" == "fedora" ]]; then
            ls -1sh build/*.rpm || true
          else
            ls -1sh build/*.deb build/*.ddeb || true
          fi

      - name: Publish ccache summary
        run: |
          echo '## CCache Summary' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ccache -s >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: ‚òÅÔ∏è Upload packages
        if: ${{ inputs.publish-package }}
        uses: actions/upload-artifact@v4
        timeout-minutes: 10
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: |
            /work/build/*.deb
            /work/build/*.ddeb
          compression-level: 0
          if-no-files-found: error

      - name: 'Tar files'
        if: ${{ inputs.publish-artifact }}
        run: |
          ARTIFACT_PATHS="ttnn/ttnn/*.so build/lib build/programming_examples build/test build/tools runtime"
          if [[ "${{ inputs.skip-tt-train }}" != "true" ]]; then
            ARTIFACT_PATHS="$ARTIFACT_PATHS build/tt-train data"
          fi
          tar -I 'zstd --adapt=min=9 -T0' -cvhf /work/ttm_any.tar.zst $ARTIFACT_PATHS

      - name: Set build artifact name
        id: set_build_artifact_name
        run: |
          TOOLCHAIN_CLEANED=$(echo "${{ env.TOOLCHAIN }}" | sed -E 's/^cmake\///; s/-toolchain\.cmake$//')
          # Use full sanitized ref/SHA and workflow run ID to ensure uniqueness
          # Sanitize ref/SHA by replacing invalid characters with hyphens
          RAW_REF="${{ inputs.ref || github.sha }}"
          SANITIZED_REF=$(echo "$RAW_REF" | sed 's/[\/:"<>|*?\r\n\\]/-/g')
          TRACY_SUFFIX="${{ (inputs.tracy && '_profiler') || '' }}"
          DIST_SUFFIX="${{ (inputs.distributed == false && '_no_distributed') || '' }}"
          VERSION="${{ env.VERSION }}"
          ARCH="${{ inputs.architecture }}"
          RUN_ID="${{ github.run_id }}"
          BUILD_ARTIFACT_PARTS=(
            "TTMetal_build_any"
            "${VERSION}"
            "${ARCH}"
            "${TOOLCHAIN_CLEANED}${TRACY_SUFFIX}${DIST_SUFFIX}"
            "${SANITIZED_REF}"
            "${RUN_ID}"
          )
          BUILD_ARTIFACT_NAME=$(IFS='_'; echo "${BUILD_ARTIFACT_PARTS[*]}")
          echo "build_artifact_name=$BUILD_ARTIFACT_NAME" >> "$GITHUB_ENV"
          echo "build_artifact_name=$BUILD_ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: ‚òÅÔ∏è Upload tarball
        if: ${{ inputs.publish-artifact }}
        uses: actions/upload-artifact@v4
        timeout-minutes: 10
        with:
          name: ${{ env.build_artifact_name }}
          path: /work/ttm_any.tar.zst
          if-no-files-found: error
          compression-level: 0

  # Determine Python version based on platform
  determine-python-version:
    needs: parse-platform
    runs-on: ubuntu-latest
    outputs:
      python-version: ${{ steps.set-python-version.outputs.version }}
    steps:
      - id: set-python-version
        run: |
          # Get distro and version from parse-platform outputs (which handles both workflow_dispatch and workflow_call)
          DISTRO="${{ needs.parse-platform.outputs.distro }}"
          VERSION="${{ needs.parse-platform.outputs.version }}"

          # Use Python 3.12 for Ubuntu 24.04, Python 3.10 for Ubuntu 22.04
          if [ "$VERSION" = "24.04" ]; then
            PYTHON_VERSION="3.12"
          else
            PYTHON_VERSION="3.10"
          fi

          echo "version=$PYTHON_VERSION" >> "$GITHUB_OUTPUT"
          echo "Determined Python version: $PYTHON_VERSION for distro=$DISTRO, version=$VERSION"

  build-wheel:
    # Use always() so this job runs even when build-docker-image is skipped (pre-built tags provided)
    if: ${{ always() && !failure() && !cancelled() && inputs.build-wheel && inputs.use-artifacts-from-run == '' }}
    name: üêç Build wheel (Python ${{ needs.determine-python-version.outputs.python-version }})
    uses: ./.github/workflows/wheels.yaml
    needs: [parse-platform, build-docker-image, determine-python-version]
    secrets: inherit
    with:
      python-version: ${{ needs.determine-python-version.outputs.python-version }}
      docker-image: >-
        ${{ inputs.manylinux-docker-image ||
            needs.build-docker-image.outputs.manylinux-tag ||
            'docker-image-unresolved!' }}
      ref: ${{ inputs.ref || '' }}
      tracy: ${{ inputs.tracy }}
      enable-lto: ${{ inputs.enable-lto || false }}

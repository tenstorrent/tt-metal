name: Build test and publish upstream tests

on:
  workflow_dispatch:
    inputs:
      request-force-publish:
        default: "passing-only"
        type: string
        description: "Control image publishing: 'passing-only' (default), 'all', or JSON array of hw_topology values like [\"wh-6u\", \"bh\"]"
  schedule:
    - cron: '0 12 * * *'

# any reason to bake the test script in as entrypoint??? WHY NOT ONE IMAGE
# well, that's because of the two builds...
env:
  WH_6U_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-tests-wh-6u
  WH_6U_PROFILER_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-profiler-tests-wh-6u
  BLACKHOLE_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-tests-bh
  BLACKHOLE_PROFILER_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-profiler-tests-bh
  BLACKHOLE_LLMBOX_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-tests-bh-llmbox
  BLACKHOLE_DESKBOX_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-tests-bh-deskbox
  BLACKHOLE_LOUDBOX_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-tests-bh-loudbox
  BLACKHOLE_P300_IMAGE_NAME: ghcr.io/tenstorrent/tt-metal/upstream-tests-bh-p300

jobs:
  build-artifact:
    uses: ./.github/workflows/build-artifact.yaml
    permissions:
      packages: write
    secrets: inherit
    with:
      version: 22.04
      build-wheel: true
      build-umd-tests: true
      tracy: true
  get-image-tags:
    runs-on: ubuntu-latest
    outputs:
      image-tag-suffix: ${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}
      wh-6u-image-tag: ${{ steps.set-image-tags.outputs.wh-6u-image-tag }}
      wh-6u-profiler-image-tag: ${{ steps.set-image-tags.outputs.wh-6u-profiler-image-tag }}
      bh-image-tag: ${{ steps.set-image-tags.outputs.bh-image-tag }}
      bh-profiler-image-tag: ${{ steps.set-image-tags.outputs.bh-profiler-image-tag }}
      bh-llmbox-image-tag: ${{ steps.set-image-tags.outputs.bh-llmbox-image-tag }}
      bh-deskbox-image-tag: ${{ steps.set-image-tags.outputs.bh-deskbox-image-tag }}
      bh-loudbox-image-tag: ${{ steps.set-image-tags.outputs.bh-loudbox-image-tag }}
      bh-p300-image-tag: ${{ steps.set-image-tags.outputs.bh-p300-image-tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
      - name: Get tag to use everywhere
        id: set-image-tag-suffix
        run: echo "image-tag-suffix=$(git describe)" >> "$GITHUB_OUTPUT"
      - name: Set image tags
        id: set-image-tags
        run: |
          echo "wh-6u-image-tag=${{ env.WH_6U_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
          echo "wh-6u-profiler-image-tag=${{ env.WH_6U_PROFILER_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
          echo "bh-image-tag=${{ env.BLACKHOLE_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
          echo "bh-profiler-image-tag=${{ env.BLACKHOLE_PROFILER_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
          echo "bh-llmbox-image-tag=${{ env.BLACKHOLE_LLMBOX_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
          echo "bh-deskbox-image-tag=${{ env.BLACKHOLE_DESKBOX_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
          echo "bh-loudbox-image-tag=${{ env.BLACKHOLE_LOUDBOX_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
          echo "bh-p300-image-tag=${{ env.BLACKHOLE_P300_IMAGE_NAME }}:${{ steps.set-image-tag-suffix.outputs.image-tag-suffix }}" >> "$GITHUB_OUTPUT"
  build-images:
    needs:
      - build-artifact
      - build-artifact
      - get-image-tags
    permissions:
      packages: write
      contents: read
    strategy:
      matrix:
        # Ultimate goal will be to have a master script that people can call via
        # <url_to_script_on_main.sh> | sh -c or something like that which will download
        # the images and run them.
        image-config:
          - image-tag: ${{ needs.get-image-tags.outputs.wh-6u-image-tag }}
            test-command: dockerfile/upstream_test_images/run_upstream_tests_vanilla.sh
            hw-topology: wh_6u
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
            techdebt-install-ttt-reqs: true
          - image-tag: ${{ needs.get-image-tags.outputs.wh-6u-profiler-image-tag }}
            test-command: tests/scripts/wh_6u/run_wh_6u_upstream_profiler_tests.sh
            hw-topology: wh_6u
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
            techdebt-install-ttt-reqs: true
          - image-tag: ${{ needs.get-image-tags.outputs.bh-image-tag }}
            dockerfile: dockerfile/upstream_test_images/Dockerfile
            test-command: dockerfile/upstream_test_images/run_upstream_tests_vanilla.sh
            hw-topology: blackhole
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
          - image-tag: ${{ needs.get-image-tags.outputs.bh-profiler-image-tag }}
            test-command: tests/scripts/single_card/run_bh_upstream_profiler_tests.sh
            hw-topology: blackhole
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
          - image-tag: ${{ needs.get-image-tags.outputs.bh-llmbox-image-tag }}
            dockerfile: dockerfile/upstream_test_images/Dockerfile
            test-command: dockerfile/upstream_test_images/run_upstream_tests_vanilla.sh
            hw-topology: blackhole_llmbox
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
            techdebt-install-ttt-reqs: true
          - image-tag: ${{ needs.get-image-tags.outputs.bh-deskbox-image-tag }}
            dockerfile: dockerfile/upstream_test_images/Dockerfile
            test-command: dockerfile/upstream_test_images/run_upstream_tests_vanilla.sh
            hw-topology: blackhole_deskbox
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
            techdebt-install-ttt-reqs: true
          - image-tag: ${{ needs.get-image-tags.outputs.bh-loudbox-image-tag }}
            dockerfile: dockerfile/upstream_test_images/Dockerfile
            test-command: dockerfile/upstream_test_images/run_upstream_tests_vanilla.sh
            hw-topology: blackhole_loudbox
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
            techdebt-install-ttt-reqs: true
          - image-tag: ${{ needs.get-image-tags.outputs.bh-p300-image-tag }}
            dockerfile: dockerfile/upstream_test_images/Dockerfile
            test-command: dockerfile/upstream_test_images/run_upstream_tests_vanilla.sh
            hw-topology: blackhole_p300
            build-artifact-name: ${{ needs.build-artifact.outputs.build-artifact-name }}
            wheel-artifact-name: ${{ needs.build-artifact.outputs.wheel-artifact-name }}
            techdebt-install-ttt-reqs: true
    runs-on: tt-ubuntu-2204-large-stable
    steps:
      - uses: actions/checkout@v4
      - name: Download artifacts from metal
        id: download-artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0
        with:
          # 22.04 artifact... we'll probably need to key on that in the original action in metal
          name: ${{ matrix.image-config.build-artifact-name }}
      - run: mkdir -p _tt-metal
      - run: tar --zstd -xvf ttm_any.tar.zst -C _tt-metal/
      - run: ls -hal _tt-metal
      - name: ðŸ§ª Download Python Wheel
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0
        with:
          name: ${{ matrix.image-config.wheel-artifact-name }}
      - name: ðŸ’¿ Verify Wheel exists
        shell: bash
        run: |
          echo "ðŸ“‚ In directory: $(pwd)"
          echo "ðŸ“„ Files:"
          ls -la .
      # Do not set up docker buildx because of https://github.com/docker/setup-buildx-action/issues/57
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Generate Dockerfile
        shell: bash
        run: |
          sudo apt update
          sudo apt install -y gettext
          export TEST_COMMAND=${{ matrix.image-config.test-command }}
          export HW_TOPOLOGY=${{ matrix.image-config.hw-topology }}
          export TT_METAL_DEV_VERSION=latest
          export TT_METAL_COMMIT_SHA=${{ github.sha }}
          envsubst < dockerfile/upstream_test_images/Dockerfile.template > dockerfile/upstream_test_images/Dockerfile-generated
          cat dockerfile/upstream_test_images/Dockerfile-generated
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          file: dockerfile/upstream_test_images/Dockerfile-generated
          platforms: linux/amd64
          pull: true
          push: true
          tags: ${{ matrix.image-config.image-tag }}
          context: ${{ github.workspace }}
          build-args: |
            TECHDEBT_INSTALL_TTT_REQS=${{ matrix.image-config.techdebt-install-ttt-reqs && 'true' || 'false' }}
  test-wh-6u-image:
    needs:
      - get-image-tags
      - build-images
    runs-on:
      - arch-wormhole_b0
      - topology-6u
      - in-service
      - pipeline-functional
    steps:
      # TODO -likely need to put this into a script which can be parameterized on the build number
      # and whether to only pull
      - name: Pull image
        timeout-minutes: 10
        run: docker pull ${{ needs.get-image-tags.outputs.wh-6u-image-tag }}
      - name: Run image
        timeout-minutes: 45
        env:
          SOURCE_LLAMA_DIR: /mnt/MLPerf/tt_dnn-models/llama/Llama3.3-70B-Instruct
          LLAMA_DIR: /mnt/MLPerf/tt_dnn-models/llama/Llama3.3-70B-Instruct
        run: docker run --network none -v /dev/hugepages-1G:/dev/hugepages-1G --device /dev/tenstorrent -v $SOURCE_LLAMA_DIR:$LLAMA_DIR:ro -e LLAMA_DIR ${{ needs.get-image-tags.outputs.wh-6u-image-tag }}
      - name: Run profiler image
        timeout-minutes: 10
        run: docker run --network none -v /dev/hugepages-1G:/dev/hugepages-1G --device /dev/tenstorrent ${{ needs.get-image-tags.outputs.wh-6u-profiler-image-tag }}
  test-bh-multicard-image:
    needs:
      - get-image-tags
      - build-images
    strategy:
      fail-fast: false
      matrix:
        bh-config:
          - runner-label: BH-LLMBox
            image-name: ${{ needs.get-image-tags.outputs.bh-llmbox-image-tag }}
          - runner-label: BH-DeskBox
            image-name: ${{ needs.get-image-tags.outputs.bh-deskbox-image-tag }}
          - runner-label: BH-LoudBox
            image-name: ${{ needs.get-image-tags.outputs.bh-loudbox-image-tag }}
    runs-on:
      - ${{ matrix.bh-config.runner-label }}
      - in-service
      - pipeline-perf
    steps:
      - name: Run image
        timeout-minutes: 30
        env:
          LLAMA_DIR: /localdev/blackhole_demos/huggingface_data/meta-llama/Llama-3.1-8B-Instruct
        run: docker run --network none -v /dev/hugepages-1G:/dev/hugepages-1G --device /dev/tenstorrent -v $LLAMA_DIR:$LLAMA_DIR:ro -e LLAMA_DIR ${{ matrix.bh-config.image-name }}
  test-bh-p300-image:
    needs:
      - get-image-tags
      - build-images
    strategy:
      fail-fast: false
      matrix:
        bh-config:
          - runner-label: P300
            image-name: ${{ needs.get-image-tags.outputs.bh-p300-image-tag }}
    runs-on:
      - ${{ matrix.bh-config.runner-label }}
      - in-service
    steps:
      - name: Download Llama model weights from LFC
        timeout-minutes: 15
        run: |
          mkdir -p /localdev/blackhole_demos/huggingface_data/meta-llama
          wget -r -nH -x --cut-dirs=5 -np --progress=dot:giga -R "index.html*" -P /localdev/blackhole_demos/huggingface_data/meta-llama http://yyz2-lfcache564.yyz2.tenstorrent.com/mldata/model_checkpoints/pytorch/huggingface/meta-llama/Llama-3.1-8B-Instruct/
      - name: Run image
        timeout-minutes: 60
        env:
          LLAMA_DIR: /localdev/blackhole_demos/huggingface_data/meta-llama/Llama-3.1-8B-Instruct
        run: docker run --network none --device /dev/tenstorrent -v $LLAMA_DIR:$LLAMA_DIR:ro -e LLAMA_DIR ${{ matrix.bh-config.image-name }}
  test-bh-image:
    needs:
      - get-image-tags
      - build-images
    strategy:
      fail-fast: false
      matrix:
        bh-card:
          - P100
          - P150
    runs-on:
      - ${{ matrix.bh-card }}
      - in-service
      - cloud-virtual-machine
      # Targeting cloud machines with pipeline-functional per now per
      # https://github.com/tenstorrent/tt-metal/issues/21738#issuecomment-2925788342
      - pipeline-functional
    steps:
      - name: Run image
        timeout-minutes: 30
        env:
          # For different environments, yyz BH VLAN vs. cloud
          LLAMA_DIR: ${{ contains(runner.name, 'gh') && '/localdev/blackhole_demos/huggingface_data' || '/mnt/MLPerf/tt_dnn-models' }}/meta-llama/Llama-3.1-8B-Instruct
        run: docker run -v /dev/hugepages-1G:/dev/hugepages-1G --device /dev/tenstorrent -v $LLAMA_DIR:$LLAMA_DIR:ro -e LLAMA_DIR ${{ needs.get-image-tags.outputs.bh-image-tag }}
      - name: Run profiler image
        timeout-minutes: 10
        run: docker run -v /dev/hugepages-1G:/dev/hugepages-1G --device /dev/tenstorrent ${{ needs.get-image-tags.outputs.bh-profiler-image-tag }}
  calculate-to-publish:
    if: ${{ !cancelled() }}
    needs:
      - get-image-tags
      - test-wh-6u-image
      - test-bh-image
      - test-bh-p300-image
      - test-bh-multicard-image
    runs-on: ubuntu-latest
    outputs:
      images-to-push: ${{ steps.calculate-images.outputs.images-to-push }}
    steps:
      - uses: actions/checkout@v4
      - name: Calculate images to publish
        id: calculate-images
        shell: bash
        run: |
          set -euo pipefail

          # Load configuration from external JSON file
          config_file=".github/workflows/job_configs/upstream-tests.json"
          if [[ ! -f "$config_file" ]]; then
            echo "ERROR: Configuration file $config_file not found" >&2
            exit 1
          fi

          echo "Using configuration from $config_file"

          # Get all hw_topology keys
          hw_topologies=($(jq -r '.hw_topologies | keys[]' "$config_file"))

          # Create mapping of image output names to actual image tags
          declare -A image_output_to_tag=(
            ["bh-image-tag"]="${{ needs.get-image-tags.outputs.bh-image-tag }}"
            ["bh-profiler-image-tag"]="${{ needs.get-image-tags.outputs.bh-profiler-image-tag }}"
            ["wh-6u-image-tag"]="${{ needs.get-image-tags.outputs.wh-6u-image-tag }}"
            ["wh-6u-profiler-image-tag"]="${{ needs.get-image-tags.outputs.wh-6u-profiler-image-tag }}"
            ["bh-llmbox-image-tag"]="${{ needs.get-image-tags.outputs.bh-llmbox-image-tag }}"
            ["bh-deskbox-image-tag"]="${{ needs.get-image-tags.outputs.bh-deskbox-image-tag }}"
            ["bh-loudbox-image-tag"]="${{ needs.get-image-tags.outputs.bh-loudbox-image-tag }}"
            ["bh-p300-image-tag"]="${{ needs.get-image-tags.outputs.bh-p300-image-tag }}"
          )

          # Get test job results
          declare -A test_job_results=(
            ["test-bh-image"]="${{ needs.test-bh-image.result }}"
            ["test-wh-6u-image"]="${{ needs.test-wh-6u-image.result }}"
            ["test-bh-multicard-image"]="${{ needs.test-bh-multicard-image.result }}"
            ["test-bh-p300-image"]="${{ needs.test-bh-p300-image.result }}"
          )

          # Initialize array for images to push (optimized approach)
          images_to_push_array=()

          # Parse the request-force-publish input
          request_input="${{ inputs.request-force-publish || 'passing-only' }}"

          echo "Processing request: $request_input"

          # Function to add images for a hw_topology
          add_images_for_topology() {
            local hw_topology="$1"
            local reason="$2"

            echo "Adding images for $hw_topology ($reason)"

            # Get image outputs for this hw_topology from config
            local image_outputs
            image_outputs=($(jq -r ".hw_topologies[\"$hw_topology\"].image_outputs[]" "$config_file"))

            # Add each image to our array
            for image_output in "${image_outputs[@]}"; do
              if [[ -v image_output_to_tag[$image_output] ]]; then
                local image_tag="${image_output_to_tag[$image_output]}"
                echo "  Adding: $image_tag"
                images_to_push_array+=("$image_tag")
              else
                echo "ERROR: Unknown image output '$image_output' for hw_topology '$hw_topology'" >&2
                exit 1
              fi
            done
          }

          if [[ "$request_input" == "passing-only" ]]; then
            echo "Mode: Publishing only passing images"

            # Check each hw_topology's test job result
            for hw_topology in "${hw_topologies[@]}"; do
              test_job=$(jq -r ".hw_topologies[\"$hw_topology\"].test_job" "$config_file")
              test_result="${test_job_results[$test_job]}"

              echo "Checking $hw_topology (test job: $test_job, result: $test_result)"

              if [[ "$test_result" == "success" ]]; then
                add_images_for_topology "$hw_topology" "test passed"
              else
                echo "Skipping images for $hw_topology (test failed or skipped: $test_result)"
              fi
            done

          elif [[ "$request_input" == "all" ]]; then
            echo "Mode: Publishing all images regardless of test status"

            # Add all images for all hw_topologies
            for hw_topology in "${hw_topologies[@]}"; do
              add_images_for_topology "$hw_topology" "forced all"
            done

          else
            echo "Mode: Publishing specific hw_topology list"

            # Validate JSON format
            if ! echo "$request_input" | jq empty 2>/dev/null; then
              echo "ERROR: request-force-publish must be 'passing-only', 'all', or a valid JSON array" >&2
              exit 1
            fi

            # Validate it's an array
            if [[ $(echo "$request_input" | jq 'type') != '"array"' ]]; then
              echo "ERROR: When providing specific hw_topology values, input must be a JSON array like [\"wh-6u\", \"bh\"]" >&2
              exit 1
            fi

            # Get valid hw_topology values for error messages
            valid_topologies=$(printf '%s ' "${hw_topologies[@]}")

            # Process each requested hw_topology
            while IFS= read -r hw_topology; do
              hw_topology=$(echo "$hw_topology" | jq -r '.')
              echo "Processing requested hw_topology: $hw_topology"

              # Validate hw_topology exists in config
              if ! jq -e ".hw_topologies[\"$hw_topology\"]" "$config_file" >/dev/null; then
                echo "ERROR: Unknown hw_topology '$hw_topology'. Valid values are: $valid_topologies" >&2
                exit 1
              fi

              add_images_for_topology "$hw_topology" "forced specific"
            done < <(echo "$request_input" | jq -r '.[]')
          fi

          # Convert bash array to JSON (optimized single conversion)
          if [[ ${#images_to_push_array[@]} -eq 0 ]]; then
            images_to_push_json="[]"
            # TODO: I wonder if we want to just fail here and print a helpful error message?
            echo "No images to push"
          else
            echo "Converting ${#images_to_push_array[@]} images to JSON for next job's matrix"
            images_to_push_json=$(printf '%s\n' "${images_to_push_array[@]}" | jq -R '.' | jq -s 'map({"image-tag": .})')
          fi

          echo "Final images to push:"
          echo "$images_to_push_json" | jq '.'

          # Set output
          echo "images-to-push=$images_to_push_json" >> "$GITHUB_OUTPUT"
  push-latest:
    # Push images based on the dynamic matrix calculated by calculate-to-publish
    # This job will only run if calculate-to-publish has images to push
    if: >-
      ${{
        !cancelled() &&
        needs.calculate-to-publish.result == 'success' &&
        needs.calculate-to-publish.outputs.images-to-push != '[]'
      }}
    needs:
      - calculate-to-publish
    permissions:
      packages: write
      contents: read
    strategy:
      matrix:
        image-config: ${{ fromJSON(needs.calculate-to-publish.outputs.images-to-push) }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/push-latest-image-to-ghcr
        with:
          docker-image-tag: ${{ matrix.image-config.image-tag }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

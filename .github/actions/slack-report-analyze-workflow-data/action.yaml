name: "Report Workflow Status to Slack"
description: "Report the workflow status to Slack to help identify breakages faster."
inputs:
  slack_webhook_url:
    description: "Webhook URL for the Slack channel to be posted to. Generated via slack app!"
    required: true
  regressed_workflows:
    description: "JSON array from analyze step output 'regressed_workflows'"
    required: true
  alert_all_message:
    description: "Optional Slack-ready alert text from analyze step output 'alert_all_message'"
    required: false
runs:
  using: "composite"
  steps:
    - name: Build Slack message from regressions
      id: build
      shell: bash
      run: |
        set -euo pipefail
        tmp_file="$(mktemp)"
        printf "%s" '${{ inputs.regressed_workflows }}' > "$tmp_file"
        if ! jq -e . "$tmp_file" >/dev/null 2>&1; then
          echo "payload={\"text\":\"Failed to parse regression list\"}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # This part is unchanged: it generates the main regression text
        TEXT=$(jq -r '
          if (type=="array" and length==0) then
            "✅ No new regressions."
          elif (type=="array") then
            "❌ *Regressions (Pass → Fail):*\n" + (map(
              "- " + .name
              + (if .workflow_url then " — <" + .workflow_url + "|workflow>" else "" end)
              + (if .run_url then " — <" + .run_url + "|run>" else "" end)
              + (if .commit_url and .commit_short then " — <" + .commit_url + "|" + .commit_short + ">" else "" end)
              + (if .created_at then " (" + .created_at + ")" else "" end)
            ) | join("\n"))
          else
            "Malformed regressions payload"
          end' "$tmp_file")

        # MINIMAL CHANGE: Define message parts and build a Block Kit payload
        # 1. Define the components of the message as separate variables
        HEADER="Aggregate Workflow Data run: <https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}|this run>"
        ALERT_RAW='${{ inputs.alert_all_message }}'
        ALERT=$(printf '%b' "$ALERT_RAW") # Safely interprets newlines like \n

        # 2. Build the payload using blocks for guaranteed line breaks, with text fallback
        PAYLOAD=$(jq -cn \
          --arg header "$HEADER" \
          --arg body "$TEXT" \
          --arg alert "$ALERT" \
          '
          (
            [
              { "type": "section", "text": { "type": "mrkdwn", "text": $header } },
              { "type": "section", "text": { "type": "mrkdwn", "text": $body } }
            ]
            + (if ($alert | length > 0) then
                 [ { "type": "divider" }, { "type": "section", "text": { "type": "mrkdwn", "text": $alert } } ]
               else [] end)
          ) as $blocks
          | {
              text: ($header + "\n" + $body + (if $alert == "" then "" else "\n\n" + $alert end)),
              blocks: $blocks
            }
        ')

        echo "payload=$PAYLOAD" >> "$GITHUB_OUTPUT"

    - name: Report Github Pipeline Status Slack Action
      uses: slackapi/slack-github-action@v1.26.0
      with:
        payload: ${{ steps.build.outputs.payload }}
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.slack_webhook_url }}
